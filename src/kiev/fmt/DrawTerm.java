/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.fmt;

import kiev.Kiev;
import kiev.CError;
import kiev.stdlib.*;
import kiev.vlang.*;
import kiev.vlang.types.*;
import kiev.transf.*;
import kiev.parser.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;


@node(copyable=false)
public abstract class DrawTerm extends Drawable {
	public		int     x;
	public		int     y;
	public		int     lineno; // line number for text-kind draw/print formatters
	public		int		_metric;
	@packed:12,_metric,0
	public		int		w;
	@packed:8,_metric,12
	public		int		h;
	@packed:8,_metric,20
	public		int		b;
	@packed:3,_metric,28
	public		int		do_newline; // used by formatter to mark actual new-lines after a DrawTerm
	@packed:1,_metric,31
	public		boolean	hidden_as_auto_generated;
	
	private		String	text;

	public DrawTerm(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}
	
	public boolean isUnvisible() {
		return hidden_as_auto_generated;
	}  

	public DrawTerm getFirstLeaf() { return isUnvisible() ? null : this; }
	public DrawTerm getLastLeaf()  { return isUnvisible() ? null : this; }

	public final int getMaxLayout() {
		int max_layout = syntax.lout.count;
		if (attr_syntax != null)
			max_layout = Math.max(max_layout, attr_syntax.lout.count);
		return max_layout;
	}


	public final void preFormat(DrawContext cont) {
		this.x = 0;
		this.y = 0;
		ANode node = this.drnode;
		if (node instanceof ASTNode && ((ASTNode)node).isAutoGenerated()) {
			if (cont.fmt.getShowAutoGenerated())
				this.hidden_as_auto_generated = false;
			else
				this.hidden_as_auto_generated = true;
		}
		if (this.isUnvisible()) return;
		try {
			this.text = makeText(cont.fmt);
		} catch (Throwable t) {
			this.text = "???";
		}
		cont.formatAsText(this);
	}

	public final boolean postFormat(DrawContext cont) {
		this.do_newline = 0;
		return cont.addLeaf(this);
	}

	public String getPrefix() { return ""; }	
	public String getSuffix() { return ""; }	
	abstract String makeText(Formatter fmt);
	public final String getText() { return text; }
}

@node(copyable=false)
public final class DrawToken extends DrawTerm {

	public DrawToken(ANode node, SyntaxToken syntax) {
		super(node, syntax);
	}

	String makeText(Formatter fmt) { return ((SyntaxToken)this.syntax).text; } 
}

@node(copyable=false)
public final class DrawPlaceHolder extends DrawTerm {

	public DrawPlaceHolder(ANode node, SyntaxPlaceHolder syntax) {
		super(node, syntax);
		//this.hidden_as_auto_generated = true;
	}

	String makeText(Formatter fmt) {
		if (fmt instanceof GfxFormatter)
			return ((SyntaxPlaceHolder)this.syntax).text;
		return "";
	} 

}

@node(copyable=false)
public class DrawNodeTerm extends DrawTerm {

	String attr;

	public DrawNodeTerm(ANode node, SyntaxElem syntax, String attr) {
		super(node, syntax);
		this.attr = attr.intern();
	}

	String makeText(Formatter fmt) {
		ANode node = this.drnode;
		if (node instanceof ConstExpr && attr == "value") {
			return String.valueOf(node);
		} else {
			Object o = getAttrPtr().get();
			if (o == null)
				return null;
			return String.valueOf(o);
		}
	}
	
	public final AttrPtr getAttrPtr() {
		return drnode.getAttrPtr(attr);
	}
}

@node(copyable=false)
public class DrawIdent extends DrawNodeTerm {

	private boolean escaped;

	public DrawIdent(ANode node, SyntaxIdentAttr syntax, String attr) {
		super(node, syntax, attr);
	}

	String makeText(Formatter fmt) {
		String text = super.makeText(fmt);
		escaped = false;
		if (text == null)
			return null;
		text = text.intern();
		SyntaxIdentAttr si = (SyntaxIdentAttr)this.syntax;
		if (si.isOk(text))
			return text;
		escaped = true;
		return getPrefix()+text+getSuffix();
	}
	
	public String getPrefix() { if (escaped) return ((SyntaxIdentAttr)this.syntax).getPrefix(); return ""; }
	public String getSuffix() { if (escaped) return ((SyntaxIdentAttr)this.syntax).getSuffix(); return ""; }
}

@node(copyable=false)
public class DrawCharTerm extends DrawNodeTerm {

	public DrawCharTerm(ANode node, SyntaxElem syntax, String attr) {
		super(node, syntax, attr);
	}

	public String getPrefix() { return "'"; }	
	public String getSuffix() { return "'"; }	
	String makeText(Formatter fmt) {
		Character ch = (Character)getAttrPtr().get();
		return "'"+Convert.escape(ch.charValue())+"'";
	}
}

@node(copyable=false)
public class DrawStrTerm extends DrawNodeTerm {

	public DrawStrTerm(ANode node, SyntaxElem syntax, String attr) {
		super(node, syntax, attr);
	}

	public String getPrefix() { return "\""; }	
	public String getSuffix() { return "\""; }	
	String makeText(Formatter fmt) {
		Object o = getAttrPtr().get();
		if (o == null)
			return null;
		String str = String.valueOf(o);
		return '\"'+new String(Convert.string2source(str), 0)+'\"';
	}
}

@node(copyable=false)
public class DrawXmlStrTerm extends DrawNodeTerm {

	public DrawXmlStrTerm(ANode node, SyntaxElem syntax, String attr) {
		super(node, syntax, attr);
	}

	private String escapeString(String str) {
		StringBuffer sb = new StringBuffer(str);
		boolean changed = false;
		for(int i=0; i < sb.length(); i++) {
			switch (sb.charAt(i)) {
			case '&':  sb.setCharAt(i, '&'); sb.insert(i+1,"amp;");  i += 4; changed = true; continue;
			case '<':  sb.setCharAt(i, '&'); sb.insert(i+1,"lt;");   i += 3; changed = true; continue;
			case '>':  sb.setCharAt(i, '&'); sb.insert(i+1,"gt;");   i += 3; changed = true; continue;
			case '\"': sb.setCharAt(i, '&'); sb.insert(i+1,"quot;"); i += 5; changed = true; continue;
			case '\'': sb.setCharAt(i, '&'); sb.insert(i+1,"apos;"); i += 5; changed = true; continue;
			}
		}
		if (changed) return sb.toString();
		return str;
	}

	String makeText(Formatter fmt) {
		Object o = getAttrPtr().get();
		if (o == null)
			return "";
		String str = String.valueOf(o);
		return escapeString(str);
	}
}

