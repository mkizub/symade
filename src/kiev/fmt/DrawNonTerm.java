package kiev.fmt;

import kiev.Kiev;
import kiev.CError;
import kiev.stdlib.*;
import kiev.vlang.*;
import kiev.vlang.types.*;
import kiev.transf.*;
import kiev.parser.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;


@node
public abstract class DrawNonTerm extends Drawable {
	@att
	public Drawable[] args;
	
	public DrawNonTerm() {}
	public DrawNonTerm(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}

	public DrawTerm getFirstLeaf() {
		if (this.isUnvisible())
			return null;
		for (int i=0; i < args.length; i++) {
			DrawTerm d = args[i].getFirstLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}
	public DrawTerm getLastLeaf()  {
		if (this.isUnvisible())
			return null;
		for (int i=args.length-1; i >= 0 ; i--) {
			DrawTerm d = args[i].getLastLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}

	public final boolean postFormat(DrawContext context, boolean parent_last_layout) {
		context.pushDrawable(this);
		try {
			// for each possible layout. assign it to all sub-components
			// and try to layout them;
			final int layouts_size = syntax.lout.count;
		next_layout:
			for (int i=0; i < layouts_size; i++) {
				context = context.pushState(i);
				boolean save = false;
				boolean fits = true;
				try {
					boolean last = (i == layouts_size-1);
					fits = (context.x < context.width);
					for (int j=0; j < args.length; j++) {
						Drawable dr = args[j];
						if (dr.isUnvisible())
							continue;
						fits &= dr.postFormat(context, last && parent_last_layout);
						if (!fits && !last)
							continue next_layout;
					}
					save = true;
				} finally {
					context = context.popState(save); 
				}
				return fits;
			}
		} finally {
			context.popDrawable(this);
		}
		return false;
	}

}

@node
public class DrawNonTermList extends DrawNonTerm {

	@att public boolean draw_optional;
	ANode[] oarr;
	
	public DrawNonTermList() {}
	public DrawNonTermList(ANode node, SyntaxList syntax) {
		super(node, syntax);
	}

	public void preFormat(DrawContext cont, SyntaxElem expected_stx, ANode expected_node) {
		if (!expected_stx.check(cont, syntax, expected_node, this.node)) {
			Drawable dr = expected_stx.makeDrawable(cont.fmt, expected_node);
			replaceWithNode(dr);
			dr.preFormat(cont, expected_stx, expected_node);
		}
		SyntaxList slst = (SyntaxList)this.syntax;
		ANode[] narr = (ANode[])oarr;
		try {
			oarr = (ANode[])node.getVal(slst.name);
		} catch (RuntimeException e) {
			oarr = new ANode[0];
		}
		if (narr != oarr) {
			narr = (ANode[])oarr;
			int sz = narr.length;
			if (sz == 0) {
				if (args.length != 1) {
					args.delAll();
					if (slst.empty != null) {
						args.append(slst.empty.makeDrawable(cont.fmt, node));
					} else {
						if (slst.prefix != null)
							args.append(slst.prefix.makeDrawable(cont.fmt, node));
						if (slst.sufix != null)
							args.append(slst.sufix.makeDrawable(cont.fmt, node));
					}
				}
			} else {
				Drawable[] old_args = args.delToArray();
				boolean need_sep = false;
				if (slst.prefix != null)
					args.append(slst.prefix.makeDrawable(cont.fmt, node));
			next_node:
				for (int i=0; i < sz; i++) {
					ANode n = narr[i];
					if (n instanceof ASTNode && n.isAutoGenerated())
						continue;
					if (slst.filter != null && !slst.filter.calc(n))
						continue;
					if (need_sep && slst.separator != null)
						args.append(slst.separator.makeDrawable(cont.fmt, null));
					foreach (Drawable dr; old_args; dr.node == n) {
						args.append(dr);
						need_sep = true;
						continue next_node;
					}
					args.append(slst.element.makeDrawable(cont.fmt, n));
					need_sep = true;
				}
				if (slst.sufix != null)
					args.append(slst.sufix.makeDrawable(cont.fmt, node));
			}
		}
		if (this.isUnvisible())
			return;
		int x = 0;
		if (narr.length == 0) {
			if (args.length > 0) {
				if (slst.empty != null) {
					if (slst.empty.fmt.is_hidden)
						args[x].geometry.is_hidden = !draw_optional;
					args[x].preFormat(cont,slst.empty,this.node);
				} else {
					if (slst.prefix != null)
						args[x++].preFormat(cont,slst.prefix,this.node);
					if (slst.sufix != null)
						args[x++].preFormat(cont,slst.sufix,this.node);
				}
			}
		}
		else if (slst.separator != null) {
			int n = args.length;
			if (slst.sufix != null)
				n--;
			if (slst.prefix != null) {
				args[x++].preFormat(cont,slst.prefix,this.node);
				for (; x < n; x++) {
					if ((x & 1) == 1)
						args[x].preFormat(cont,slst.element,args[x].node);
					else
						args[x].preFormat(cont,slst.separator,this.node);
				}
			} else {
				for (; x < n; x++) {
					if ((x & 1) == 0)
						args[x].preFormat(cont,slst.element,args[x].node);
					else
						args[x].preFormat(cont,slst.separator,this.node);
				}
			}
			if (slst.sufix != null)
				args[x].preFormat(cont,slst.sufix,this.node);
		}
		else {
			int n = args.length;
			if (slst.sufix != null)
				n--;
			if (slst.prefix != null)
				args[x++].preFormat(cont,slst.prefix,this.node);
			for (; x < n; x++)
				args[x].preFormat(cont,slst.element,args[x].node);
			if (slst.sufix != null)
				args[x].preFormat(cont,slst.sufix,this.node);
		}
	}
	
	public int getInsertIndex(Drawable dr) {
		assert (dr.parent() == this);
		if (oarr.length == 0)
			return 0;
		SyntaxList slst = (SyntaxList)this.syntax;
		if (slst.separator != null) {
			if (slst.prefix != null) {
				for (int i=0; i < args.length; i++) {
					if (args[i] == dr)
						return i/2;
				}
			} else {
				for (int i=0; i < args.length; i++) {
					if (args[i] == dr)
						return (1+i)/2;
				}
			}
			return oarr.length;
		} else {
			if (slst.prefix != null) {
				if (args[0] == dr)
					return 0;
				for (int i=1; i < args.length; i++) {
					if (args[i] == dr)
						return i-1;
				}
			} else {
				for (int i=0; i < args.length; i++) {
					if (args[i] == dr)
						return i;
				}
			}
		}
		return oarr.length;
	}
}

@node
public class DrawNonTermSet extends DrawNonTerm {

	public DrawNonTermSet() {}
	public DrawNonTermSet(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}

	public void preFormat(DrawContext cont, SyntaxElem expected_stx, ANode expected_node) {
		if (!expected_stx.check(cont, syntax, expected_node, this.node)) {
			Drawable dr = expected_stx.makeDrawable(cont.fmt, expected_node);
			replaceWithNode(dr);
			dr.preFormat(cont, expected_stx, expected_node);
		}
		if (this.isUnvisible())
			return;
		SyntaxSet sset = (SyntaxSet)this.syntax;
		if (args.length != sset.elements.length) {
			args.delAll();
			foreach (SyntaxElem se; sset.elements)
				args.append(se.makeDrawable(cont.fmt, this.node));
		}
		for (int i=0; i < args.length; i++) {
			Drawable dr = args[i];
			dr.preFormat(cont,sset.elements[i],this.node);
		}
	}
}


