/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.fmt;

import syntax kiev.Syntax;


@node(copyable=false)
public abstract class DrawNonTerm extends Drawable {
	@att public Drawable	folded;
	@att public Drawable[]	args;
	@att public boolean		draw_folded;
	     public int			max_layout;

	public DrawNonTerm(ANode node, SyntaxElem syntax, ATextSyntax text_syntax) {
		super(node, syntax, text_syntax);
	}
	
	public String getText() {
		if (folded != null)
			return folded.getText();
		StringBuffer sb = new StringBuffer();
		foreach (Drawable arg; args)
			sb.append(arg.getText());
		return sb.toString();
	}

	public DrawTerm getFirstLeaf() {
		if (this.isUnvisible())
			return null;
		for (int i=0; i < args.length; i++) {
			DrawTerm d = args[i].getFirstLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}
	public DrawTerm getLastLeaf()  {
		if (this.isUnvisible())
			return null;
		for (int i=args.length-1; i >= 0 ; i--) {
			DrawTerm d = args[i].getLastLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}

	public final int getMaxLayout() { return max_layout; }

	protected final void calcMaxLayout() {
		max_layout = syntax.lout.count;
		foreach (Drawable dr; args; !dr.isUnvisible())
			max_layout = Math.max(max_layout, dr.getMaxLayout());
	}

	public final void lnkFormat(DrawContext cont) {
		if (this.isUnvisible())
			return;
		cont.processSpaceBefore(this);
		foreach (Drawable arg; args)
			arg.lnkFormat(cont);
		cont.processSpaceAfter(this);
	}

	public final void postFormat(DrawContext context) {
		context = context.pushDrawable(this);
		try {
			if (max_layout <= 0 || context.parent_has_more_attempts) {
				for (int j=0; j < args.length; j++) {
					Drawable dr = args[j];
					if (dr.isUnvisible())
						continue;
					dr.postFormat(context);
				}
			} else {
				// for each possible layout. assign it to all sub-components and try to layout them
			next_layout:
				for (int i=0; i <= this.max_layout; i++) {
					context = context.pushState(i);
					boolean last = (i == this.max_layout);
					if (!last && !context.parent_has_more_attempts)
						context.parent_has_more_attempts = true;
					try {
						for (int j=0; j < args.length; j++) {
							Drawable dr = args[j];
							if (dr.isUnvisible())
								continue;
							dr.postFormat(context);
							if (!last && context.x < context.width)
								continue next_layout;
						}
						last = true;
						return;
					} finally {
						context = context.popState(last); 
					}
				}
			}
		} finally {
			context.popDrawable(this);
		}
	}
}

@node(copyable=false)
public final class DrawWrapList extends DrawNonTerm {

	public boolean		draw_empty;
	public AttrSlot		slst_attr;

	public DrawWrapList(ANode node, SyntaxList syntax, ATextSyntax text_syntax) {
		super(node, syntax, text_syntax);
		this.draw_folded = syntax.folded_by_default;
		foreach (AttrSlot a; node.values(); a.name == syntax.name) {
			slst_attr = a;
			break;
		}
		try {
			if (((ANode[])slst_attr.get(node)).length != 0)
				draw_empty = true;
		} catch (RuntimeException e) {}
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible()) return;
		SyntaxList slst = (SyntaxList)this.syntax;
		ANode node = this.drnode;
		
		if (folded == null && slst.folded != null) {
			folded = slst.folded.makeDrawable(cont.fmt, node, text_syntax);
			if (draw_folded) {
				folded.preFormat(cont,slst.folded,node);
				return;
			}
		}
		
		ANode[] narr = null;
		try {
			narr = (ANode[])slst_attr.get(node);
		} catch (RuntimeException e) {
			narr = null;
		}
		int lst_len = 0;
		if (narr != null) {
			foreach (ANode n; narr) {
				if (n instanceof ASTNode && n.isAutoGenerated() && !cont.fmt.getShowAutoGenerated())
					continue;
				if (slst.filter != null && !slst.filter.calc(n))
					continue;
				lst_len++;
			}
		}
		if (lst_len == 0) {
			if (!draw_empty || args.length == 0) {
				args.delAll();
				if (slst.empty != null) {
					args.append(slst.empty.makeDrawable(cont.fmt, node, text_syntax));
				} else {
					if (slst.prefix != null)
						args.append(slst.prefix.makeDrawable(cont.fmt, node, text_syntax));
					if (slst.sufix != null)
						args.append(slst.sufix.makeDrawable(cont.fmt, node, text_syntax));
				}
				draw_empty = true;
			}
		} else {
			if (draw_empty) {
				args.delAll();
				if (slst.prefix != null)
					args.append(slst.prefix.makeDrawable(cont.fmt, node, text_syntax));
				args.append(new DrawNonTermList(this.drnode,(SyntaxList)this.syntax,this.text_syntax));
				if (slst.sufix != null)
					args.append(slst.sufix.makeDrawable(cont.fmt, node, text_syntax));
				draw_empty = false;
			}
		}

		int x = 0;
		if (lst_len == 0) {
			if (args.length > 0) {
				if (slst.empty != null) {
					args[x].preFormat(cont,slst.empty,node);
				} else {
					if (slst.prefix != null)
						args[x++].preFormat(cont,slst.prefix,node);
					if (slst.sufix != null)
						args[x++].preFormat(cont,slst.sufix,node);
				}
			}
		} else {
			if (slst.prefix != null)
				args[x++].preFormat(cont,slst.prefix,node);
			args[x++].preFormat(cont);
			if (slst.sufix != null)
				args[x++].preFormat(cont,slst.sufix,node);
		}
		calcMaxLayout();
	}
	
	public int getInsertIndex(Drawable dr, boolean next) {
		assert (dr.parent() == this);
		SyntaxList slst = (SyntaxList)this.syntax;
		boolean first = (slst.prefix != null && args[0] == dr);
		if (first && !next)
			return 0;
		try {
			return ((ANode[])slst_attr.get(this.drnode)).length;
		} catch (RuntimeException e) {}
		return 0;
	}
}

@node(copyable=false)
public final class DrawNonTermList extends DrawNonTerm {

	private	ANode[] oarr;
	private boolean show_ag;
	public AttrSlot slst_attr;

	public DrawNonTermList(ANode node, SyntaxList syntax, ATextSyntax text_syntax) {
		super(node, syntax, text_syntax);
		this.draw_folded = syntax.folded_by_default;
		foreach (AttrSlot a; node.values(); a.name == syntax.name) {
			slst_attr = a;
			break;
		}
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible()) return;
		SyntaxList slst = (SyntaxList)this.syntax;
		ANode node = this.drnode;
		
		if (folded == null && slst.folded != null) {
			folded = slst.folded.makeDrawable(cont.fmt, node, text_syntax);
			if (draw_folded) {
				folded.preFormat(cont,slst.folded,node);
				return;
			}
		}
		
		ANode[] narr = (ANode[])oarr;
		try {
			oarr = (ANode[])slst_attr.get(node);
		} catch (RuntimeException e) {
			oarr = new ANode[0];
		}
		if (narr != oarr || show_ag != cont.fmt.getShowAutoGenerated()) {
			narr = (ANode[])oarr;
			show_ag = cont.fmt.getShowAutoGenerated();
			int sz = narr.length;
			Drawable[] old_args = args.delToArray();
			boolean need_sep = false;
	next_node:
			for (int i=0; i < sz; i++) {
				ANode n = narr[i];
				if (n instanceof ASTNode && n.isAutoGenerated() && !cont.fmt.getShowAutoGenerated())
					continue;
				if (slst.filter != null && !slst.filter.calc(n))
					continue;
				if (need_sep && slst.separator != null)
					args.append(slst.separator.makeDrawable(cont.fmt, null, text_syntax));
				foreach (Drawable dr; old_args; dr.drnode == n) {
					args.append(dr);
					need_sep = true;
					continue next_node;
				}
				args.append(slst.element.makeDrawable(cont.fmt, n, text_syntax));
				need_sep = true;
			}
		}

		int x = 0;
		int n = args.length;
		if (slst.separator != null) {
			for (; x < n; x++) {
				if ((x & 1) == 0)
					args[x].preFormat(cont,slst.element,args[x].drnode);
				else
					args[x].preFormat(cont,slst.separator,node);
			}
		} else {
			for (; x < n; x++)
				args[x].preFormat(cont,slst.element,args[x].drnode);
		}
		calcMaxLayout();
	}
	
	public int getInsertIndex(Drawable dr, boolean next) {
		assert (dr.parent() == this);
		SyntaxList slst = (SyntaxList)this.syntax;
		if (slst.separator != null) {
			for (int i=0; i < args.length; i++) {
				if (args[i] == dr)
					return next ? (i+2)/2 : (i+1)/2;
			}
		} else {
			for (int i=0; i < args.length; i++) {
				if (args[i] == dr)
					return next ? (i+1) : (i) ;
			}
		}
		for (int i=0; i < oarr.length; i++) {
			if (oarr[i] == dr.drnode)
				return next ? (i+1) : (i) ;
		}
		return oarr.length;
	}
}

@node(copyable=false)
public final class DrawNonTermSet extends DrawNonTerm {

	public DrawNonTermSet(ANode node, SyntaxSet syntax, ATextSyntax text_syntax) {
		super(node, syntax, text_syntax);
		this.draw_folded = syntax.folded_by_default;
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible()) return;
		SyntaxSet sset = (SyntaxSet)this.syntax;
		ANode node = this.drnode;

		if (folded == null && sset.folded != null)
			folded = sset.folded.makeDrawable(cont.fmt, node, text_syntax);
		if (folded != null)
			folded.preFormat(cont,sset.folded,node);
			
		if (!draw_folded || folded == null) {
			if (args.length != sset.elements.length) {
				args.delAll();
				foreach (SyntaxElem se; sset.elements)
					args.append(se.makeDrawable(cont.fmt, node, text_syntax));
			}
			for (int i=0; i < args.length; i++) {
				Drawable dr = args[i];
				dr.preFormat(cont,sset.elements[i],node);
			}
		}
		calcMaxLayout();
	}
}


@node(copyable=false)
public class DrawSyntaxSwitch extends DrawNonTerm {
	
	public DrawSyntaxSwitch(ANode node, SyntaxSwitch syntax, ATextSyntax text_syntax) {
		super(node, syntax, text_syntax);
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible()) return;
		SyntaxSwitch ssw = (SyntaxSwitch)this.syntax;
		ANode node = this.drnode;
		if (args.length == 0) {
			args.append(ssw.prefix.makeDrawable(cont.fmt, node, text_syntax));
			args.append(cont.fmt.getDrawable(node, null, ssw.target_syntax));
			args.append(ssw.suffix.makeDrawable(cont.fmt, node, text_syntax));
		}
		assert(args.length == 3);
		args[0].preFormat(cont,ssw.prefix,node);
		args[1].preFormat(cont,args[1].syntax,node);
		args[2].preFormat(cont,ssw.suffix,node);
		calcMaxLayout();
	}
}

