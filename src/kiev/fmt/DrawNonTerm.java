package kiev.fmt;

import kiev.Kiev;
import kiev.CError;
import kiev.stdlib.*;
import kiev.vlang.*;
import kiev.vlang.types.*;
import kiev.transf.*;
import kiev.parser.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;


@node
public abstract class DrawNonTerm extends Drawable {
	@att
	public Drawable[] args;
	
	public DrawNonTerm() {}
	public DrawNonTerm(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}

	public DrawTerm getFirstLeaf() {
		if (this.isUnvisible())
			return null;
		for (int i=0; i < args.length; i++) {
			DrawTerm d = args[i].getFirstLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}
	public DrawTerm getLastLeaf()  {
		if (this.isUnvisible())
			return null;
		for (int i=args.length-1; i >= 0 ; i--) {
			DrawTerm d = args[i].getLastLeaf();
			if (d != null && !d.isUnvisible())
				return d;
		}
		return null;
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible())
			return;
		for (int i=0; i < args.length; i++) {
			Drawable dr = args[i];
			dr.preFormat(cont);
		}
	}

	public void fillLayout(int i) {
		foreach (Drawable dr; args)
			dr.curr_layout = i;
	}

	public final boolean postFormat(DrawContext context, boolean parent_last_layout) {
		context.pushDrawable(this);
		try {
			context = context.pushState(); 
			// for each possible layout. assign it to all sub-components
			// and try to layout them;
			final int layouts_size = syntax.lout.count;
		next_layout:
			for (int i=0; i < layouts_size; i++) {
				boolean last = (i == layouts_size-1);
				fillLayout(i);
				context = context.popState(); 
				boolean fits = (context.x < context.width);
				for (int j=0; j < args.length; j++) {
					Drawable dr = args[j];
					if (dr.isUnvisible())
						continue;
					fits &= dr.postFormat(context, last && parent_last_layout);
					if (!fits && !last) {
						if (parent_last_layout)
							continue next_layout;
						return false;
					}
				}
				if (fits)
					return true;
			}
		} finally {
			context.popDrawable(this);
		}
		return false;
	}

}

@node
public class DrawNonTermList extends DrawNonTerm {

	Object oarr;
	
	public DrawNonTermList() {}
	public DrawNonTermList(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}
	public void init(Formatter fmt) {
		SyntaxList slst = (SyntaxList)this.syntax;
		oarr = node.getVal(slst.name);
		ANode[] narr = (ANode[])oarr;
		int sz = narr.length;
		if (sz == 0) {
			SyntaxElem empty = slst.empty;
			if (!(empty instanceof SyntaxEditSpace) || fmt.isForEditor())
				args.append(empty.makeDrawable(fmt, node));
		} else {
			boolean need_sep = false;
			for (int i=0; i < sz; i++) {
				ANode n = narr[i];
				if (n instanceof ASTNode && n.isAutoGenerated())
					continue;
				if (slst.filter != null && !slst.filter.calc(n))
					continue;
				if (need_sep && slst.separator != null)
					args.append(slst.separator.makeDrawable(fmt, null));
				args.append(slst.element.makeDrawable(fmt, n));
				need_sep = true;
			}
		}
	}

	public void preFormat(DrawContext cont) {
		SyntaxList slst = (SyntaxList)this.syntax;
		if (oarr != node.getVal(slst.name)) {
			args.delAll();
			this.init(cont.fmt);
		}
		super.preFormat(cont);
	}
}

@node
public class DrawNonTermSet extends DrawNonTerm {

	public DrawNonTermSet() {}
	public DrawNonTermSet(ANode node, SyntaxElem syntax) {
		super(node, syntax);
	}
	public void init(Formatter fmt) {
		SyntaxSet sset = (SyntaxSet)this.syntax;
		foreach (SyntaxElem se; sset.elements)
			args.append(se.makeDrawable(fmt, node));
	}

	public void preFormat(DrawContext cont) {
		if (this.isUnvisible())
			return;
		for (int i=0; i < args.length; i++) {
			Drawable dr = args[i];
			dr.preFormat(cont);
		}
	}
}


