package kiev.be.java;

import kiev.Kiev;
import kiev.CError;
import kiev.stdlib.*;
import kiev.vlang.*;
import kiev.transf.*;
import kiev.parser.*;

import static kiev.vlang.Instr.*;
import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;

@nodeview
public class JNewExprView extends JENodeView {
	final NewExpr.NewExprImpl impl;
	public JNewExprView(NewExpr.NewExprImpl impl) {
		super(impl);
		this.impl = impl;
	}
	@getter public final Type			get$type()				{ return this.impl.type.getType(); }
	@getter public final JENodeView[]	get$args()				{ return (JENodeView[])this.impl.args.toJViewArray(JENodeView.class); }
	@getter public final JENodeView		get$outer()				{ return this.impl.outer==null? null : this.impl.outer.getJENodeView(); }
	@getter public final JENodeView		get$temp_expr()			{ return this.impl.temp_expr.getJENodeView(); }
	@getter public final JMethodView	get$func()				{ return this.impl.func.getJMethodView(); }
	
	@setter public final void	set$temp_expr(JENodeView val)	{ this.impl.temp_expr = val==null? null : val.getENode(); }

	public void generate(Code code, Type reqType) {
		trace(Kiev.debugStatGen,"\t\tgenerating NewExpr: "+this);
		Type type = this.type;
		JENodeView[] args = this.args;
		code.setLinePos(this);
		if( type.isArgument() ) {
			if( outer != null || args.length > 0 ) {
				Kiev.reportError(this,"Constructor with arguments for type argument is not supported");
				return;
			} else {
				// If we have primitive type
				if( !type.isReference() ) {
					new ConstNullExpr().generate(code,type);
					return;
				}
				int i;
				for(i=0; i < code.clazz.type.args.length; i++)
					if( type.string_equals(code.clazz.type.args[i]) ) break;
				if( i >= code.clazz.type.args.length )
					throw new CompilerException(this,"Can't create an instance of argument type "+type);
				ENode tie = new IFldExpr(pos,new ThisExpr(pos),code.clazz.resolveField(nameTypeInfo));
				ENode e = new CastExpr(pos,type,
					new CallExpr(pos,tie,
						Type.tpTypeInfo.clazz.resolveMethod(
							KString.from("newInstance"),
							KString.from("(I)Ljava/lang/Object;")
							),
							new ENode[]{new ConstIntExpr(i)}),
					true);
				e.resolve(reqType);
				e.generate(code,reqType);
				return;
			}
		}
		code.addInstr(op_new,type);
		// First arg ('this' pointer) is generated by 'op_dup'
		if (reqType != Type.tpVoid)
			code.addInstr(op_dup);
		// Constructor call args (first args 'this' skipped)
		if( outer != null )
			outer.generate(code,null);
		if (func.getMethod().getTypeInfoParam() != null) {
			// Create static field for this type typeinfo
			temp_expr = pctx.clazz.accessTypeInfoField(this.getNode(),type).getJENodeView();
			temp_expr.generate(code,null);
			temp_expr = null;
		}
		for(int i=0; i < args.length; i++)
			args[i].generate(code,null);
		if( type.isLocalClazz() ) {
			Struct cl = ((BaseType)type).clazz;
			foreach (ASTNode n; cl.members; n instanceof Field) {
				Field f = (Field)n;
				if( !f.isNeedProxy() ) continue;
				Var v = ((LVarExpr)f.init).getVar();
				code.addInstr(Instr.op_load,v.getJVarView());
			}
		}
		code.addInstr(op_call,func.getMethod(),false,type);
	}

}


@nodeview
public class JNewArrayExprView extends JENodeView {
	final NewArrayExpr.NewArrayExprImpl impl;
	public JNewArrayExprView(NewArrayExpr.NewArrayExprImpl impl) {
		super(impl);
		this.impl = impl;
	}
	@getter public final Type			get$type()				{ return this.impl.type.getType(); }
	@getter public final JENodeView[]	get$args()				{ return (JENodeView[])this.impl.args.toJViewArray(JENodeView.class); }
	@getter public final int			get$dim()				{ return this.impl.dim; }
	@getter public final Type			get$arrtype()			{ return this.impl.arrtype; }
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debugStatGen,"\t\tgenerating NewArrayExpr: "+this);
		Type type = this.type;
		JENodeView[] args = this.args;
		code.setLinePos(this);
		if( dim == 1 ) {
			args[0].generate(code,null);
			code.addInstr(Instr.op_newarray,type);
		} else {
			for(int i=0; i < args.length; i++)
				args[i].generate(code,null);
			code.addInstr(Instr.op_multianewarray,arrtype,args.length);
		}
		if( reqType == Type.tpVoid ) code.addInstr(Instr.op_pop);
	}

}

@nodeview
public class JNewInitializedArrayExprView extends JENodeView {
	final NewInitializedArrayExpr.NewInitializedArrayExprImpl impl;
	public JNewInitializedArrayExprView(NewInitializedArrayExpr.NewInitializedArrayExprImpl impl) {
		super(impl);
		this.impl = impl;
	}
	@getter public final Type			get$type()				{ return this.impl.type.getType(); }
	@getter public final JENodeView[]	get$args()				{ return (JENodeView[])this.impl.args.toJViewArray(JENodeView.class); }
	@getter public final int			get$dim()				{ return this.impl.dims.length; }
	@getter public final int[]			get$dims()				{ return this.impl.dims; }
	@getter public final Type			get$arrtype()			{ return this.impl.arrtype; }

	public void generate(Code code, Type reqType) {
		trace(Kiev.debugStatGen,"\t\tgenerating NewInitializedArrayExpr: "+this);
		Type type = this.type;
		JENodeView[] args = this.args;
		code.setLinePos(this);
		if( dim == 1 ) {
			code.addConst(args.length);
			code.addInstr(Instr.op_newarray,type);
		} else {
			for(int i=0; i < dim; i++)
				code.addConst(dims[i]);
			code.addInstr(Instr.op_multianewarray,arrtype,dim);
		}
		for(int i=0; i < args.length; i++) {
			code.addInstr(Instr.op_dup);
			code.addConst(i);
			args[i].generate(code,null);
			code.addInstr(Instr.op_arr_store);
		}
		if( reqType == Type.tpVoid ) code.addInstr(op_pop);
	}
}

@nodeview
public class JNewClosureView extends JENodeView {
	final NewClosure.NewClosureImpl impl;
	public JNewClosureView(NewClosure.NewClosureImpl impl) {
		super(impl);
		this.impl = impl;
	}
	@getter public final ClosureType		get$type()				{ return (ClosureType)this.impl.type.getType(); }
	@getter public final Struct				get$clazz()				{ return this.impl.clazz; }
	@getter public final Method				get$func()				{ return this.impl.func; }
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debugStatGen,"\t\tgenerating NewClosure: "+this);
		ClosureType type = this.type;
		code.setLinePos(this);
		code.addInstr(op_new,type);
		// First arg ('this' pointer) is generated by 'op_dup'
		if( reqType != Type.tpVoid )
			code.addInstr(op_dup);
		// Constructor call args (first args 'this' skipped)
		if( code.method!=null && !code.method.isStatic() )
			code.addInstrLoadThis();
		if( type.args == null )
			code.addConst(0);
		else
			code.addConst(type.args.length);
		// Now, fill proxyed fields (vars)
		Struct cl = (Struct)type.clazz;
		foreach (ASTNode n; cl.members; n instanceof Field) {
			Field f = (Field)n;
			if( !f.isNeedProxy() ) continue;
			Var v = ((LVarExpr)f.init).getVar();
			code.addInstr(Instr.op_load,v.getJVarView());
		}
		code.addInstr(op_call,func,false);
	}
}

