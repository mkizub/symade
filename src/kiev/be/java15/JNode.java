/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.be.java15;
import syntax kiev.Syntax;

public class JNodeContext extends Context {
	SemContext semantic_context;
	public JNodeContext(SemContext semantic_context) {
		this.semantic_context = semantic_context;
	}
}

public class JNode extends AHandleData implements JConstants {

	@virtual typedef VT  ≤ ASTNode;

	private final AHandle p_handle_;

	protected JNode(ASTNode impl) {
		super(((WorkerThread)Thread.currentThread()).bend_context);
		p_handle_ = impl.handle();
		p_handle_.addData(this);
	}

	public VT vn() {
		SemContext semantic_context = ((JNodeContext)getDataContext()).semantic_context;
		foreach (ASTNode nh; p_handle_.getHandleData(); semantic_context.inherits(nh.getDataContext()))
			return (VT)nh;
		return null;
	}

    public final int getPosLine() { vn().getPosLine() }
	public final boolean isResolved() { vn().isResolved() }
	public final boolean isAutoGenerated() { vn().isAutoGenerated() }
	public final boolean isBad() { vn().isBad() }
	public final boolean isAttached() { vn().isAttached() }
	public final boolean isAttachedBy(AttrSlot attr_slot) { vn().isAttachedBy(attr_slot) }
	
	public final void walkTree(INode parent, AttrSlot slot, ITreeWalker walker) {
		vn().walkTree(parent,slot,walker);
	}
	
	public String toString() { vn().toString() }

	protected static JNode getJData(ANode n) {
		if !(n instanceof ASTNode)
			return null;
		Context bend_context = ((WorkerThread)Thread.currentThread()).bend_context;
		foreach (JNode nh; n.handle().getHandleData(); bend_context == nh.getDataContext())
			return nh;
		return null;
	}
	
	@unerasable
	public static <J extends JNode> J[] toJArray(NodeSpace<ASTNode> narr)
		alias operator "( T ) V"
		alias $cast
	{
		int sz = narr.length;
		J[] jarr = new J[sz];
		for (int i=0; i < sz; i++)
			jarr[i] = attachJNode(narr[i]);
		return jarr;
	}

	public static JNode attachJNode(ASTNode impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return jn;
		if (impl instanceof DNode)
			return JDNode.attachJDNode((DNode)impl);
		if (impl instanceof SNode)
			return JSNode.attachJSNode((SNode)impl);
		if (impl instanceof ENode)
			return JENode.attach((ENode)impl);
		return new JNode(impl);
	}
	
	public:ro @virtual @abstract JNode				jparent;
	public:ro @virtual @abstract JTypeDecl			jctx_tdecl;
	public:ro @virtual @abstract JMethod			jctx_method;

	@getter public final JNode get$jparent()        { return attachJNode((ASTNode)vn().parent()); }
	@getter public final JTypeDecl get$jctx_tdecl() { return (JTypeDecl)Env.ctxTDecl(vn()); }
	@getter public final JMethod get$jctx_method()  { return (JMethod)  Env.ctxMethod(vn()); }

	public boolean equals(Object:Object obj) { return false; }
	public boolean equals(JNode:Object jnv) { return this == jnv; }

	public final Type getType() { return vn().getType(Env.getEnv()); }
	
	public void generate(Code code, Type reqType) {
		throw new CompilerException(vn(),"Unresolved node ("+this.getClass()+") generation");
	}
	public void backendCleanup() {
		p_handle_.delData(this);
	}
}

public class JDNode extends JNode {

	@virtual typedef VT  ≤ DNode;

	@abstract
	public:ro	String		sname;
	
	public Attr[] jattrs = Attr.emptyArray;

	public final boolean isPublic() { vn().isPublic() }
	public final boolean isPrivate() { vn().isPrivate() }
	public final boolean isProtected() { vn().isProtected() }
	public final boolean isPkgPrivate() { vn().isPkgPrivate() }
	public final boolean isStatic() { vn().isStatic() }
	public final boolean isFinal() { vn().isFinal() }
	public final boolean isSynchronized() { vn().isSynchronized() }
	public final boolean isFieldTransient() { vn().isFieldTransient() }
	public final boolean isNative() { vn().isNative() }
	public final boolean isInterface() { vn().isInterface() }
	public final boolean isAbstract() { vn().isAbstract() }

	public final boolean isMacro() { vn().isMacro() }
	public final boolean isInterfaceOnly() { vn().isInterfaceOnly() }

	public final boolean hasRuntimeVisibleMetas() { vn().hasRuntimeVisibleMetas() }
	public final boolean hasRuntimeInvisibleMetas() { vn().hasRuntimeInvisibleMetas() }

	public short getJavaFlags() { vn().getJavaFlags() }

	public void setPrivate() { vn().setPrivate(); }

	public boolean isTypeUnerasable() { vn().isTypeUnerasable() }

	@getter public final String get$sname() {
		return vn().sname;
	}

	public static JDNode attachJDNode(DNode impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JDNode)jn;
		if (impl instanceof TypeDecl) {
			if (impl instanceof Struct)
				return JStruct.attachJStruct((Struct)impl);
			return JTypeDecl.attachJTypeDecl((TypeDecl)impl);
		}
		if (impl instanceof Method)
			return JMethod.attachJMethod((Method)impl);
		if (impl instanceof Initializer)
			return JInitializer.attachJInitializer((Initializer)impl);
		if (impl instanceof WBCCondition)
			return JWBCCondition.attachJWBCCondition((WBCCondition)impl);
		if (impl instanceof Var) {
			if (impl instanceof Field)
				return JField.attachJField((Field)impl);
			return JVar.attachJVar((Var)impl);
		}
		if (impl instanceof Label)
			return JLabel.attachJLabel((Label)impl);
		return new JDNode(impl);
	}
	
	protected JDNode(DNode impl) {
		super(impl);
	}

	/** Add information about new attribute that belongs to this class */
	public Attr addAttr(Attr a) {
		for(int i=0; i < jattrs.length; i++) {
			if(jattrs[i].name == a.name) {
				jattrs[i] = a;
				return a;
			}
		}
		jattrs = (Attr[])Arrays.append(jattrs,a);
		return a;
	}

	public Attr getAttr(String name) {
		for(int i=0; i < jattrs.length; i++)
			if( jattrs[i].name.equals(name) )
				return jattrs[i];
		return null;
	}
	
	public Attr[] getJAttrs() {
		return jattrs;
	}

	public void backendCleanup() {
		jattrs = Attr.emptyArray;
		super.backendCleanup();
	}

}


public class JSNode extends JNode {

	@virtual typedef VT  ≤ SNode;

	public static JNode attachJSNode(SNode impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JSNode)jn;
		if (impl instanceof FileUnit)
			return JFileUnit.attachJFileUnit((FileUnit)impl);
		return new JSNode(impl);
	}
	
	protected JSNode(SNode impl) {
		super(impl);
	}
}

public class JENode extends JNode {

	@virtual typedef VT  ≤ ENode;

	public static JENode attach(ENode impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JENode)jn;
		if (impl instanceof BoolExpr) return JBoolExpr.attach((BoolExpr)impl);
		if (impl instanceof CallExpr) return JCallExpr.attach((CallExpr)impl);
		if (impl instanceof CtorCallExpr) return JCtorCallExpr.attach((CtorCallExpr)impl);
		if (impl instanceof ClosureCallExpr) return JClosureCallExpr.attach((ClosureCallExpr)impl);
		if (impl instanceof CaseLabel) return JCaseLabel.attach((CaseLabel)impl);
		if (impl instanceof CatchInfo) return JCatchInfo.attach((CatchInfo)impl);
		if (impl instanceof FinallyInfo) return JFinallyInfo.attach((FinallyInfo)impl);
		if (impl instanceof TryStat) return JTryStat.attach((TryStat)impl);
		if (impl instanceof SynchronizedStat) return JSynchronizedStat.attach((SynchronizedStat)impl);
		if (impl instanceof WithStat) return JWithStat.attach((WithStat)impl);
		if (impl instanceof ConstExpr) return JConstExpr.attach((ConstExpr)impl);
		if (impl instanceof Shadow) return JShadow.attach((Shadow)impl);
		if (impl instanceof TypeClassExpr) return JTypeClassExpr.attach((TypeClassExpr)impl);
		if (impl instanceof TypeInfoExpr) return JTypeInfoExpr.attach((TypeInfoExpr)impl);
		if (impl instanceof AssignExpr) return JAssignExpr.attach((AssignExpr)impl);
		if (impl instanceof ModifyExpr) return JModifyExpr.attach((ModifyExpr)impl);
		if (impl instanceof BinaryExpr) return JBinaryExpr.attach((BinaryExpr)impl);
		if (impl instanceof UnaryExpr) return JUnaryExpr.attach((UnaryExpr)impl);
		if (impl instanceof StringConcatExpr) return JStringConcatExpr.attach((StringConcatExpr)impl);
		if (impl instanceof CommaExpr) return JCommaExpr.attach((CommaExpr)impl);
		if (impl instanceof Block) return JBlock.attach((Block)impl);
		if (impl instanceof IncrementExpr) return JIncrementExpr.attach((IncrementExpr)impl);
		if (impl instanceof ConditionalExpr) return JConditionalExpr.attach((ConditionalExpr)impl);
		if (impl instanceof CastExpr) return JCastExpr.attach((CastExpr)impl);
		if (impl instanceof LoopStat) return JLoopStat.attach((LoopStat)impl);
		if (impl instanceof LvalueExpr) return JLvalueExpr.attach((LvalueExpr)impl);
		if (impl instanceof SuperExpr) return JSuperExpr.attach((SuperExpr)impl);
		if (impl instanceof OuterThisAccessExpr) return JOuterThisAccessExpr.attach((OuterThisAccessExpr)impl);
		if (impl instanceof NewExpr) return JNewExpr.attach((NewExpr)impl);
		if (impl instanceof NewEnumExpr) return JNewEnumExpr.attach((NewEnumExpr)impl);
		if (impl instanceof NewArrayExpr) return JNewArrayExpr.attach((NewArrayExpr)impl);
		if (impl instanceof NewInitializedArrayExpr) return JNewInitializedArrayExpr.attach((NewInitializedArrayExpr)impl);
		if (impl instanceof NewClosure) return JNewClosure.attach((NewClosure)impl);
		if (impl instanceof NopExpr) return JNopExpr.attach((NopExpr)impl);
		if (impl instanceof TypeRef) return JTypeRef.attach((TypeRef)impl);
		if (impl instanceof InlineMethodStat) return JInlineMethodStat.attach((InlineMethodStat)impl);
		if (impl instanceof ExprStat) return JExprStat.attach((ExprStat)impl);
		if (impl instanceof ReturnStat) return JReturnStat.attach((ReturnStat)impl);
		if (impl instanceof ThrowStat) return JThrowStat.attach((ThrowStat)impl);
		if (impl instanceof IfElseStat) return JIfElseStat.attach((IfElseStat)impl);
		if (impl instanceof CondStat) return JCondStat.attach((CondStat)impl);
		if (impl instanceof LabeledStat) return JLabeledStat.attach((LabeledStat)impl);
		if (impl instanceof BreakStat) return JBreakStat.attach((BreakStat)impl);
		if (impl instanceof ContinueStat) return JContinueStat.attach((ContinueStat)impl);
		if (impl instanceof GotoStat) return JGotoStat.attach((GotoStat)impl);
		if (impl instanceof GotoCaseStat) return JGotoCaseStat.attach((GotoCaseStat)impl);
		return new JENode(impl);
	}
	
	protected JENode(ENode impl) {
		super(impl);
	}

	public final String getIdent() { vn().ident }
	public final Symbol getSymbol() { vn().symbol }
	public final DNode getDnode() { vn().dnode }

	//
	// Expr specific
	//

	public final boolean isAsField() { vn().isAsField() }
	public final boolean isGenVoidExpr() { vn().isGenVoidExpr() }
	public final boolean isForWrapper() { vn().isForWrapper() }
	public final boolean isCastCall() { vn().isCastCall() }

	//
	// Statement specific flags
	//
	
	public final boolean isAbrupted() { vn().isAbrupted() }
	public final boolean isBreaked() { vn().isBreaked() }
	public final boolean isMethodAbrupted() { vn().isMethodAbrupted() }
	public final boolean isAutoReturnable() { vn().isAutoReturnable() }
	public final boolean isBreakTarget() { vn().isBreakTarget() }
	public final void setAutoReturnable(boolean on) { vn().setAutoReturnable(on); }
	
	public boolean isConstantExpr(Env env) { vn().isConstantExpr(env) }
	public Object	getConstValue(Env env) { vn().getConstValue(env) }
	
	public Operator getOper() { vn().getOper() }
}

public final class JNopExpr extends JENode {

	@virtual typedef VT  ≤ NopExpr;

	public static JNopExpr attach(NopExpr impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JNopExpr)jn;
		return new JNopExpr(impl);
	}
	
	protected JNopExpr(NopExpr impl) {
		super(impl);
	}

	public void generate(Code code, Type reqType) {
		// nothing to generate - noop
		if (Kiev.debugOutputA || Kiev.debugOutputT) {
			trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NopExpr: "+this);
			code.setLinePos(this);
			code.addInstr(Instr.op_nop);
		}
	}
}

public class JTypeDecl extends JDNode {

	@virtual typedef VT  ≤ TypeDecl;

	@abstract
	public:ro	TypeRef[]			super_types;

	public static JTypeDecl attachJTypeDecl(TypeDecl impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JTypeDecl)jn;
		if (impl instanceof Struct)
			return JStruct.attachJStruct((Struct)impl);
		return new JTypeDecl(impl);
	}
	
	protected JTypeDecl(TypeDecl impl) {
		super(impl);
	}
	
	public void backendCleanup() {
		jattrs = Attr.emptyArray;
	}

	@getter public final TypeRef[] get$super_types() {
		return vn().super_types;
	}

	public final JType getJType(JTypeEnv jtenv) {
		return jtenv.getJType(this.getType());
	}

	public final boolean isClazz() { vn().isClazz() }
	public final boolean isAnnotation() { vn().isAnnotation() }
	public final boolean isEnum() { vn().isEnum() }
	public final boolean isTypeDeclNotLoaded() { vn().isTypeDeclNotLoaded() }
	public final boolean isStructInner() { vn().isStructInner() }

	public void checkResolved(Env env) { vn().checkResolved(env); }
}

public final class JTypeRef extends JENode {

	@virtual typedef VT  ≤ TypeRef;

	public final Type type_lnk;

	public static JTypeRef attach(TypeRef impl)
		operator "new T"
		operator "( T ) V"
	{
		if (impl == null)
			return null;
		JNode jn = getJData(impl);
		if (jn != null)
			return (JTypeRef)jn;
		return new JTypeRef(impl);
	}
	
	protected JTypeRef(TypeRef impl) {
		super(impl);
		this.type_lnk = impl.type_lnk;
	}

	public void generate(Code code, Type reqType) {
		// don't generate here
	}
}


