/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.be.java15;
import syntax kiev.Syntax;

import static kiev.be.java15.Instr.*;

@ViewOf(vcast=true, iface=true)
public final view JNewExpr of NewExpr extends JENode {

	public:ro	JMethod			func;
	public:ro	JENode			outer;
	public:ro	JENode			tpinfo;
	public:ro	JENode[]		args;
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NewExpr: "+this);
		Type ntype = this.getType();
		JENode[] args = this.args;
		code.setLinePos(this);
		while( ntype instanceof ArgType && !ntype.isUnerasable())
			ntype = ntype.getErasedType();
		if( ntype instanceof ArgType ) {
			if( outer != null || args.length > 0 ) {
				Kiev.reportError(this,"Constructor with arguments for type argument is not supported");
				return;
			} else {
				// If we have primitive type
				if( !ntype.isReference() ) {
					((JENode)new ConstNullExpr()).generate(code,ntype);
					return;
				}
				int i;
				for(i=0; i < ((Struct)code.clazz).args.length; i++)
					if (ntype ≈ ((Struct)code.clazz).args[i].getAType()) break;
				if( i >= ((Struct)code.clazz).args.length )
					throw new CompilerException(this,"Can't create an instance of argument type "+ntype);
				ENode tie = new IFldExpr(pos,new ThisExpr(pos),((Struct)code.clazz).resolveField(nameTypeInfo));
				ENode e = new CastExpr(pos,ntype,
					new CallExpr(pos,tie,
						Type.tpTypeInfo.tdecl.resolveMethod("newInstance",Type.tpObject,Type.tpInt),
						new ENode[]{new ConstIntExpr(i)}
					)
				);
				e.resolve(reqType);
				((JENode)e).generate(code,reqType);
				return;
			}
		}
		code.addInstr(op_new,ntype);
		// First arg ('this' pointer) is generated by 'op_dup'
		if (reqType ≢ Type.tpVoid)
			code.addInstr(op_dup);
		// Generate outer instance argument for this constructor call
		if( outer != null )
			outer.generate(code,null);
		// Generate typeinfo argument for this constructor call
		if (tpinfo != null)
			tpinfo.generate(code,null);
		// Constructor call args (first args 'this' skipped)
		for(int i=0; i < args.length; i++)
			args[i].generate(code,null);
		if (ntype.getStruct() != null) {
			JStruct cl = (JStruct)ntype.getStruct();
			foreach (JField f; cl.members) {
				if( !f.isNeedProxy() ) continue;
				JVar v = ((JLVarExpr)f.init).var;
				code.addInstr(Instr.op_load,v);
			}
		}
		code.addInstr(op_call,func,true,ntype);
	}
}

@ViewOf(vcast=true, iface=true)
public final view JNewEnumExpr of NewEnumExpr extends JENode {

	public:ro	JMethod			func;
	public:ro	JENode[]		args;
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NewEnumExpr: "+this);
		Type ntype = this.getType();
		JENode[] args = this.args;
		code.setLinePos(this);
		code.addInstr(op_new,ntype);
		// First arg ('this' pointer) is generated by 'op_dup'
		if (reqType ≢ Type.tpVoid)
			code.addInstr(op_dup);
		JAssignExpr assign = (JAssignExpr)jparent;
		Field f = (Field)((JSFldExpr)assign.lval).var;
		int idx = ((JavaEnum)(TypeDecl)this.jctx_tdecl).getIndexOfEnumField(f);
		// Generate field name constant
		code.addConst(KString.from(f.sname));
		// Generate field index
		code.addConst(idx);
		// Constructor call args
		for(int i=0; i < args.length; i++)
			args[i].generate(code,null);
		code.addInstr(op_call,func,true,ntype);
	}
}


@ViewOf(vcast=true, iface=true)
public final view JNewArrayExpr of NewArrayExpr extends JENode {
	public:ro	Type				ntype;
	public:ro	JENode[]			args;
	public:ro	Type				arrtype;
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NewArrayExpr: "+this);
		Type ntype = this.ntype;
		JENode[] args = this.args;
		code.setLinePos(this);
		if( args.length == 1 ) {
			args[0].generate(code,null);
			code.addInstr(Instr.op_newarray,ntype);
		} else {
			int n = 0;
			for(int i=0; i < args.length; i++) {
				JENode arg = args[i];
				if !(((ENode)arg) instanceof NopExpr) {
					arg.generate(code,null);
					n++;
				}
			}
			code.addInstr(Instr.op_multianewarray,arrtype,n);
		}
		if( reqType ≡ Type.tpVoid ) code.addInstr(Instr.op_pop);
	}

}

@ViewOf(vcast=true, iface=true)
public final view JNewInitializedArrayExpr of NewInitializedArrayExpr extends JENode {
	public:ro	Type				ntype;
	public:ro	JENode[]			args;

	public void generate(Code code, Type reqType) {
		trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NewInitializedArrayExpr: "+this);
		Type ntype = this.ntype;
		JENode[] args = this.args;
		code.setLinePos(this);
		ntype = ((ArrayType)ntype).arg;
		code.addConst(args.length);
		code.addInstr(Instr.op_newarray,ntype);
		for(int i=0; i < args.length; i++) {
			code.addInstr(Instr.op_dup);
			code.addConst(i);
			args[i].generate(code,null);
			code.addInstr(Instr.op_arr_store);
		}
		if( reqType ≡ Type.tpVoid ) code.addInstr(op_pop);
	}
}

@ViewOf(vcast=true, iface=true)
public final view JNewClosure of NewClosure extends JENode {
	public:ro	JStruct		clazz;

	@getter public final CallType	getCallType()	{
		return (CallType) ((NewClosure)this).getType();
	}
	
	public void generate(Code code, Type reqType) {
		trace(Kiev.debug && Kiev.debugStatGen,"\t\tgenerating NewClosure: "+this);
		CallType xtype = this.getCallType();
		JStruct cl = clazz;
		code.setLinePos(this);
		code.addInstr(op_new,clazz.xtype);
		// First arg ('this' pointer) is generated by 'op_dup'
		if( reqType ≢ Type.tpVoid )
			code.addInstr(op_dup);
		// Constructor call args (first args 'this' skipped)
		if( code.method!=null && !code.method.isStatic() )
			code.addInstrLoadThis();
		code.addConst(xtype.arity);
		// Now, fill proxyed fields (vars)
		foreach (JField f; cl.members) {
			if( !f.isNeedProxy() ) continue;
			JVar v = ((JLVarExpr)f.init).var;
			code.addInstr(Instr.op_load,v);
		}
		JMethod func = clazz.resolveMethod(null,KString.from("(I)V"));
		code.addInstr(op_call,func,true);
	}
}

