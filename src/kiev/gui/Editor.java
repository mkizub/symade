/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.gui;

import kiev.Kiev;
import kiev.Compiler;
import kiev.CompilerThread;
import kiev.EditorThread;
import kiev.CError;
import kiev.stdlib.*;
import kiev.vlang.*;
import kiev.vlang.types.*;
import kiev.transf.*;
import kiev.parser.*;
import kiev.fmt.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;

import java.util.EnumSet;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.Graphics;

import java.awt.datatransfer.*;

import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.ComboBoxEditor;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTextField;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.PopupMenuEvent;
import javax.swing.text.TextAction;

/**
 * @author mkizub
 */
@node(copyable=false)
public class Editor extends InfoView implements KeyListener {
	
	/** Symbols used by editor */
	
	/** Current editor mode */
	private KeyListener		item_editor;
	/** Current x position for scrolling up/down */
	int						cur_x;
	/** Current item */
	public final CurElem	cur_elem;
	/** The object in clipboard */
	public final Clipboard	clipboard = java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
	
	private Stack<Transaction>		changes = new Stack<Transaction>();
	
	{
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_LEFT),      new NavigateEditor(this,NavigateView.LEFT));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_RIGHT),     new NavigateEditor(this,NavigateView.RIGHT));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_UP),        new NavigateEditor(this,NavigateView.LINE_UP));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_DOWN),      new NavigateEditor(this,NavigateView.LINE_DOWN));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_HOME),      new NavigateEditor(this,NavigateView.LINE_HOME));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_END),       new NavigateEditor(this,NavigateView.LINE_END));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_PAGE_UP),   new NavigateEditor(this,NavigateView.PAGE_UP));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_PAGE_DOWN), new NavigateEditor(this,NavigateView.PAGE_DOWN));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_E),         new ChooseItemEditor(this));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_N),         new NewElemEditor(this,NewElemEditor.SETNEW_HERE));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_A),         new NewElemEditor(this,NewElemEditor.INSERT_NEXT));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_F),         new FolderTrigger(this));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_O),         new OptionalTrigger(this));
		this.naviMap.put(Integer.valueOf(KeyEvent.VK_X),         new FunctionExecuter(this));
	}
	
	public Editor(Window window, ATextSyntax syntax, Canvas view_canvas) {
		super(window, syntax, view_canvas);
		cur_elem = new CurElem();
	}
	
	public void setRoot(ANode root) {
		super.setRoot(root);
		cur_elem.set(view_root.getFirstLeaf());
	}
	
	public void setSyntax(ATextSyntax syntax) {
		super.setSyntax(syntax);
		cur_elem.restore();
	}

	public void formatAndPaint(boolean full) {
		if (cur_elem == null)
			return;
		cur_elem.restore();
		view_canvas.current = cur_elem.dr;
		if (full) {
			this.formatter.setWidth(view_canvas.imgWidth);
			this.formatter.setShowAutoGenerated(this.show_auto_generated);
			view_canvas.root = null;
			if (the_root != null && full)
				view_canvas.root = view_root = formatter.format(the_root, view_root);
			cur_elem.restore();
		}
		view_canvas.repaint();
		ANode src = cur_elem.dr != null ? cur_elem.dr.drnode : null;
		parent_window.info_view.the_root = src;
		parent_window.info_view.formatAndPaint(true);
	}
	
	public ActionPoint getActionPoint() {
		Drawable dr = cur_elem.dr;
		while (dr != null) {
			Drawable p = (Drawable)dr.parent();
			if (p instanceof DrawNonTermList)
				return new ActionPoint(p,p.slst_attr,p.getInsertIndex(dr));
			if (p instanceof DrawWrapList)
				return new ActionPoint(p,p.slst_attr,p.getInsertIndex(dr));
			dr = p;
		}
		return null;
	}

	private boolean isSpaceOrHidden(Drawable dr) {
		return dr.isUnvisible() || isSpace(dr);
	}
	
	private boolean isSpace(Drawable dr) {
		return dr instanceof DrawSpace;
	}
	
	public void keyReleased(KeyEvent evt) {}
	public void keyTyped(KeyEvent evt) {}
	
	public void keyPressed(KeyEvent evt) {
		if (item_editor != null) {
			item_editor.keyPressed(evt);
			return;
		}
		//System.out.println(evt);
		int code = evt.getKeyCode();
		int mask = evt.getModifiersEx() & (KeyEvent.CTRL_DOWN_MASK|KeyEvent.SHIFT_DOWN_MASK|KeyEvent.ALT_DOWN_MASK);
		if (mask == 0) {
			KeyHandler kh = naviMap.get(Integer.valueOf(code));
			if (kh != null) {
				kh.process();
				evt.consume();
				return;
			}
			return;
		}
		else if (mask == KeyEvent.ALT_DOWN_MASK) {
			switch (code) {
			//case KeyEvent.VK_UP:
			//	if (cur_elem.dr.isAttached()) {
			//		cur_elem.set((Drawable)cur_elem.parent());
			//		view_canvas.repaint();
			//	}
			//	evt.consume(); 
			//	break;
			case KeyEvent.VK_H:
				evt.consume(); 
				this.show_auto_generated = !this.show_auto_generated;
				formatAndPaint(true);
				break;
			case KeyEvent.VK_DOWN:
				evt.consume(); 
				if (cur_elem.dr instanceof DrawNonTerm) {
					cur_elem.set(cur_elem.dr.getFirstLeaf());
					view_canvas.repaint();
				}
				break;
			case KeyEvent.VK_C:
				evt.consume();
				System.out.println("Running backend compiler...");
				CompilerThread thr = CompilerThread;
				thr.errCount = 0;
				thr.warnCount = 0;
				Compiler.runBackEnd(thr, Env.root, null, false);
				break;
			case KeyEvent.VK_V:
				evt.consume();
				runFrontEndCompiler(the_root);
				break;
			}
		}
		else if (mask == (KeyEvent.CTRL_DOWN_MASK|KeyEvent.ALT_DOWN_MASK)) {
			switch (code) {
			case KeyEvent.VK_V:
				evt.consume();
				runFrontEndCompiler(Env.root);
				break;
			case KeyEvent.VK_M:
				evt.consume();
				getVersion(Env.root).mergeTree();
				formatAndPaint(true);
				System.out.println("Tree merged to the editor version.");
				break;
			}
		}
		else if (mask == KeyEvent.CTRL_DOWN_MASK) {
			evt.consume(); 
			switch (code) {
			case KeyEvent.VK_F:
				// 'Find' dialog
				{
					ANode src = cur_elem.dr != null ? cur_elem.dr.drnode : null;
					FindDialog fd = new FindDialog(parent_window,this);
					fd.pack();
					fd.setVisible(true);
				}
				break;
			case KeyEvent.VK_Z:
				if (changes.length > 0) {
					Transaction tr = changes.pop();
					tr.rollback(false);
					formatAndPaint(true);
				}
				break;
			case KeyEvent.VK_W:
				if (item_editor != null) {
					stopItemEditor(true);
					item_editor = null;
				}
				parent_window.closeEditor(this);
				break;
			case KeyEvent.VK_X:
				if (cur_elem.dr != null) {
					ANode node = cur_elem.dr.drnode;
					changes.push(Transaction.open());
					node.detach();
					changes.peek().close();
					TransferableANode tr = new TransferableANode(node);
					clipboard.setContents(tr, tr);
					formatAndPaint(true);
				}
				break;
			case KeyEvent.VK_C:
				if (cur_elem.dr instanceof DrawNodeTerm) {
					AttrPtr pattr = ((DrawNodeTerm)cur_elem.dr).getAttrPtr();
					Object obj = pattr.get();
					Transferable tr = null;
					if (obj instanceof ANode)
						tr = new TransferableANode((ANode)obj);
					else
						tr = new StringSelection(String.valueOf(obj));
					clipboard.setContents(tr, (ClipboardOwner)tr);
				} else {
					Transferable tr = new TransferableANode(cur_elem.dr.drnode);
					clipboard.setContents(tr, (ClipboardOwner)tr);
				}
				break;
			case KeyEvent.VK_A:
				{
					Transferable content = clipboard.getContents(null);
					if (content.isDataFlavorSupported(TransferableANode.transferableANodeFlavor)) {
						ANode node = (ANode)content.getTransferData(TransferableANode.transferableANodeFlavor);
						ActionPoint ap = getActionPoint();
						if (ap != null) {
							if (node.isAttached())
								node = node.ncopy();
							if (ap.slot.typeinfo.$instanceof(node)) {
								int idx = ap.index + 1;
								if (idx > ap.length)
									idx = ap.length;
								changes.push(Transaction.open());
								try {
									((SpaceAttrSlot)ap.slot).insert(ap.node,idx,node);
								} finally {
									changes.peek().close();
								}
								this.formatAndPaint(true);
							}
						}
					}
				}
				break;
			case KeyEvent.VK_V:
				{
					Transferable content = clipboard.getContents(null);
					if (content.isDataFlavorSupported(TransferableANode.transferableANodeFlavor)) {
						ANode node = (ANode)content.getTransferData(TransferableANode.transferableANodeFlavor);
						Drawable dr = cur_elem.dr;
						if (dr instanceof DrawNodeTerm) {
							AttrPtr pattr;
							if (dr.drnode instanceof SymbolRef)
								pattr = new AttrPtr(dr.drnode.parent(),dr.drnode.pslot());
							else
								pattr = ((DrawNodeTerm)dr).getAttrPtr();
							if (pattr.slot.typeinfo.clazz == SymbolRef.class) {
								DNode dn = null;
								if (node instanceof Symbol)
									dn = (DNode)node.parent();
								else if (node instanceof DNode)
									dn = (DNode)node;
								if (dn != null) {
									changes.push(Transaction.open());
									try {
										SymbolRef obj = (SymbolRef)pattr.get();
										if (obj != null) {
											obj=obj.open();
											obj.name = dn.sname;
											obj.symbol = dn;
										} else {
											pattr.node.open();
											obj = (SymbolRef)pattr.slot.typeinfo.newInstance();
											obj.symbol = dn;
											pattr.set(obj);
										}
									} finally {
										changes.peek().close();
									}
									this.formatAndPaint(true);
									return;
								}
							}
						}
						ActionPoint ap = getActionPoint();
						if (ap != null) {
							if (node.isAttached())
								node = node.ncopy();
							if (ap.slot.typeinfo.$instanceof(node)) {
								changes.push(Transaction.open());
								try {
									((SpaceAttrSlot)ap.slot).insert(ap.node,ap.index,node);
								} finally {
									changes.peek().close();
								}
								this.formatAndPaint(true);
							}
						}
					}
				}
				break;
			case KeyEvent.VK_R:
				setSyntax(this.syntax);
				cur_elem.set(view_root.getFirstLeaf());
				view_canvas.root = view_root;
				formatAndPaint(false);
				break;
			}
		}
		super.keyPressed(evt);
	}
	
	private void runFrontEndCompiler(ANode root) {
		System.out.println("Running frontend compiler...");
		Transaction tr = Transaction.open();
		changes.push(tr);
		EditorThread thr = EditorThread;
		try {
			thr.errCount = 0;
			thr.warnCount = 0;
			Compiler.runFrontEnd(thr,null,root,true);
		} catch (Throwable t) { t.printStackTrace(); }
		System.out.println("Frontend compiler completed with "+thr.errCount+" error(s)");
		if (tr.isEmpty()) {
			tr.close();
			changes.pop();
		} else {
			tr.close();
		}
		formatAndPaint(true);
	}
	
	public void startItemEditor(ANode obj, KeyListener item_editor) {
		assert (this.item_editor == null);
		this.item_editor = item_editor;
		changes.push(Transaction.open());
		obj.open();
		view_canvas.repaint();
	}

	public void stopItemEditor(boolean revert) {
		if (item_editor == null)
			return;
		item_editor = null;
		if (revert) {
			Transaction tr = changes.pop();
			tr.close();
			tr.rollback(false);
		} else {
			changes.peek().close();
		}
		this.formatAndPaint(true);
	}
	
	public void mousePressed(MouseEvent e) {
		int x = e.getX();
		int y = e.getY() + view_canvas.translated_y;
		DrawTerm dr = view_canvas.first_visible;
		for (; dr != null; dr = dr.getNextLeaf()) {
			if (dr.x < x && dr.y < y && dr.x+dr.w >= x && dr.y+dr.h >= y) {
				cur_elem.set(dr);
				cur_x = cur_elem.dr.x;
				formatAndPaint(false);
				break;
			}
			if (dr == view_canvas.last_visible)
				break;
		}
	}
	
	public void goToPath(ANode[] path) {
		if (view_root == null)
			return;
		try {
			foreach (ANode node; path) {
				view_root.walkTree(new TreeWalker() {
					public boolean pre_exec(ANode n) {
						if (n instanceof Drawable) {
							if (n instanceof DrawNodeTerm && n.getAttrPtr().get() == node || n.drnode == node) {
								DrawTerm dr = n.getFirstLeaf();
								cur_elem.set(dr);
								cur_x = cur_elem.dr.x;
								makeCurrentVisible();
								formatAndPaint(false);
								throw new RuntimeException();
							}
						}
						return true; 
					}
				});
			}
		} catch (Throwable t) {}
	}

	void makeCurrentVisible() {
		try {
			int top_lineno = view_canvas.first_visible.lineno;
			int bot_lineno = view_canvas.last_visible.lineno;
			int height = bot_lineno - top_lineno;
			int first_line = view_canvas.first_line;
			
			if (top_lineno > 0 && cur_elem.dr.getFirstLeaf().lineno <= top_lineno)
				first_line = cur_elem.dr.getFirstLeaf().lineno -1;
			if (bot_lineno < view_canvas.num_lines && cur_elem.dr.getFirstLeaf().lineno >= bot_lineno)
				first_line = cur_elem.dr.getFirstLeaf().lineno - height + 1;
			view_canvas.setFirstLine(first_line);
		} catch (NullPointerException e) {}
	}

	final class CurElem {
		DrawTerm		dr;
		int				x, y;
		Drawable[]		path = Drawable.emptyArray;
	
		void set(DrawTerm dr) {
			Editor.this.view_canvas.current = dr;
			this.dr = dr;
			if (dr != null) {
				this.x = dr.x + dr.w / 2;
				this.y = dr.y;
				Vector<Drawable> v = new Vector<Drawable>();
				while (dr != null) {
					v.append(dr);
					dr = (Drawable)dr.parent();
				}
				path = v.toArray();
			} else {
				path = Drawable.emptyArray;
			}
		}
		void restore() {
			Drawable dr = this.dr;
			Drawable root = Editor.this.view_root;
			if (root == null) {
				set(null);
				return;
			}
			if (dr == null) {
				set(root.getFirstLeaf());
				return;
			}
			if (dr.ctx_root == root)
				return;
			if (path.length == 0) {
				set(root.getFirstLeaf());
				return;
			}
			Drawable last = path[path.length-1];
			Drawable bad = null;
			for (int i=path.length-1; i >= 0 && bad == null; i--) {
				if (path[i].ctx_root == root)
					last = path[i];
				else
					bad = path[i];
			}
			set(last.getFirstLeaf());
			return;
		}
	}
}

public class ActionPoint {
	public final Drawable	dr;
	public final ANode		node;
	public final AttrSlot	slot;
	public final int		index, length;
	public ActionPoint(Drawable dr, AttrSlot slot) {
		this.dr = dr;
		this.node = dr.drnode;
		this.slot = slot;
		if (slot instanceof SpaceAttrSlot) {
			this.index = 0;
			this.length = ((ANode[])slot.get(node)).length;
		} else {
			this.index = -1;
			this.length = -1;
		}
	}
	public ActionPoint(Drawable dr, AttrSlot slot, int idx) {
		this.dr = dr;
		this.node = dr.drnode;
		this.slot = slot;
		if (idx <= 0) {
			this.index = 0;
		} else {
			this.length = ((ANode[])slot.get(node)).length;
			if (idx >= this.length)
				this.index = this.length;
			else
				this.index = idx;
		}
	}
}

public class TransferableANode implements Transferable, ClipboardOwner {
	static DataFlavor transferableANodeFlavor = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType+";class=kiev.vlang.ANode");
	public final ANode node;
	public TransferableANode(ANode node) {
		this.node = node;
	}
    public DataFlavor[] getTransferDataFlavors() {
		return new DataFlavor[] {
			DataFlavor.stringFlavor,
			transferableANodeFlavor
		};
	}
    public boolean isDataFlavorSupported(DataFlavor flavor) {
		foreach (DataFlavor df; getTransferDataFlavors(); df.equals(flavor))
			return true;
		return false;
	}
    public Object getTransferData(DataFlavor flavor)
		throws UnsupportedFlavorException
	{
		if (transferableANodeFlavor.equals(flavor))
			return node;
		if (DataFlavor.stringFlavor.equals(flavor))
			return String.valueOf(node);
		throw new UnsupportedFlavorException(flavor);
	}
	public void lostOwnership(Clipboard clipboard, Transferable contents) {}
}


public interface KeyHandler {
	public void process();
}

final class NavigateEditor extends NavigateView implements KeyHandler {

	NavigateEditor(Editor uiv, int cmd) {
		super(uiv,cmd);
	}

	public void process() {
		switch (cmd) {
		case LEFT:       navigatePrev(true); return;
		case RIGHT:      navigateNext(true); return;
		case LINE_UP:    navigateUp(true);   return;
		case LINE_DOWN:  navigateDn(true); return;
		case LINE_HOME:  navigateLineHome(true); return;
		case LINE_END:   navigateLineEnd(true);  return;
		case PAGE_UP:    navigatePageUp();  return;
		case PAGE_DOWN:  navigatePageDn();  return;
		}
	}

	private void navigatePrev(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		DrawTerm prev = uiv.cur_elem.dr.getFirstLeaf().getPrevLeaf();
		if (prev != null) {
			uiv.cur_elem.set(prev);
			uiv.cur_x = prev.x;
		}
		if (repaint) {
			uiv.makeCurrentVisible();
			uiv.formatAndPaint(false);
		}
	}
	private void navigateNext(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		DrawTerm next = uiv.cur_elem.dr.getFirstLeaf().getNextLeaf();
		if (next != null) {
			uiv.cur_elem.set(next);
			uiv.cur_x = next.x;
		}
		if (repaint) {
			uiv.makeCurrentVisible();
			uiv.formatAndPaint(false);
		}
	}
	private void navigateUp(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		DrawTerm n = null;
		DrawTerm prev = uiv.cur_elem.dr.getFirstLeaf();
		if (prev != null)
			prev = prev.getPrevLeaf();
		while (prev != null) {
			if (prev.do_newline > 0) {
				n = prev;
				break;
			}
			prev = prev.getPrevLeaf();
		}
		while (n != null) {
			if (n.x <= uiv.cur_x && n.x+n.w >= uiv.cur_x)
				break;
			prev = n.getPrevLeaf();
			if (prev == null || prev.do_newline > 0)
				break;
			if (prev.x+prev.w < uiv.cur_x)
				break;
			n = prev;
		}
		if (n != null)
			uiv.cur_elem.set(n);
		if (repaint) {
			uiv.makeCurrentVisible();
			uiv.formatAndPaint(false);
		}
	}
	private void navigateDn(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		DrawTerm n = null;
		DrawTerm next = uiv.cur_elem.dr.getFirstLeaf();
		while (next != null) {
			if (next.do_newline > 0) {
				n = next.getNextLeaf();
				break;
			}
			next = next.getNextLeaf();
		}
		while (n != null) {
			if (n.x <= uiv.cur_x && n.x+n.w >= uiv.cur_x)
				break;
			next = n.getNextLeaf();
			if (next == null)
				break;
			if (next.x > uiv.cur_x)
				break;
			if (next.do_newline > 0)
				break;
			n = next;
		}
		if (n != null)
			uiv.cur_elem.set(n);
		if (repaint) {
			uiv.makeCurrentVisible();
			uiv.formatAndPaint(false);
		}
	}
	private void navigateLineHome(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		int lineno = uiv.cur_elem.dr.getFirstLeaf().lineno;
		DrawTerm res = uiv.cur_elem.dr;
		for (;;) {
			DrawTerm dr = res.getPrevLeaf();
			if (dr == null || dr.lineno != lineno)
				break;
			res = dr;
		}
		if (res != uiv.cur_elem.dr) {
			uiv.cur_elem.set(res);
			uiv.cur_x = uiv.cur_elem.dr.x;
		}
		if (repaint)
			uiv.formatAndPaint(false);
	}
	private void navigateLineEnd(boolean repaint) {
		final Editor uiv = (Editor)this.uiv;
		int lineno = uiv.cur_elem.dr.getFirstLeaf().lineno;
		DrawTerm res = uiv.cur_elem.dr;
		for (;;) {
			DrawTerm dr = res.getNextLeaf();
			if (dr == null || dr.lineno != lineno)
				break;
			res = dr;
		}
		if (res != uiv.cur_elem.dr) {
			uiv.cur_elem.set(res);
			uiv.cur_x = uiv.cur_elem.dr.x;
		}
		if (repaint)
			uiv.formatAndPaint(false);
	}
	private void navigatePageUp() {
		final Editor uiv = (Editor)this.uiv;
		if (uiv.view_canvas.first_visible == null) {
			uiv.view_canvas.setFirstLine(0);
			return;
		}
		int offs = uiv.view_canvas.last_visible.lineno - uiv.view_canvas.first_visible.lineno -1;
		uiv.view_canvas.incrFirstLine(-offs);
		for (int i=offs; i >= 0; i--)
			navigateUp(i==0);
		return;
	}
	private void navigatePageDn() {
		final Editor uiv = (Editor)this.uiv;
		if (uiv.view_canvas.first_visible == null) {
			uiv.view_canvas.setFirstLine(0);
			return;
		}
		int offs = uiv.view_canvas.last_visible.lineno - uiv.view_canvas.first_visible.lineno -1;
		uiv.view_canvas.incrFirstLine(+offs);
		for (int i=offs; i >= 0; i--)
			navigateDn(i==0);
		return;
	}

}

final class ChooseItemEditor implements KeyHandler {

	private final Editor	editor;
	private final Drawable	drawable;

	ChooseItemEditor(Editor editor) {
		this.editor = editor;
	}

	ChooseItemEditor(Editor editor, Drawable drawable) {
		this.editor = editor;
		this.drawable = drawable;
	}

	public void process() {
		Drawable dr = this.drawable;
		if (dr == null)
			dr = editor.cur_elem.dr;
		if (dr instanceof DrawNodeTerm) {
			DrawNodeTerm dt = (DrawNodeTerm)dr;
			AttrPtr pattr = dt.getAttrPtr();
			Object obj = pattr.get();
			if (obj instanceof Symbol)
				editor.startItemEditor((Symbol)obj, new SymbolEditor((Symbol)obj, editor, dt));
			else if (obj instanceof SymbolRef)
				editor.startItemEditor((SymbolRef)obj, new SymRefEditor((SymbolRef)obj, editor, dt));
			else if (obj instanceof String || obj == null && pattr.slot.typeinfo.clazz == String.class) {
				if (pattr.node instanceof SymbolRef)
					editor.startItemEditor((SymbolRef)pattr.node, new SymRefEditor((SymbolRef)pattr.node, editor, dt));
				else
					editor.startItemEditor(pattr.node, new StrEditor(pattr, editor, dt));
			}
			else if (obj instanceof Integer)
				editor.startItemEditor(pattr.node, new IntEditor(pattr, editor, dt));
			else if (obj instanceof Boolean)
				editor.startItemEditor(pattr.node, new BoolEditor(pattr, dt, editor));
			else if (obj instanceof ConstIntExpr)
				editor.startItemEditor((ConstIntExpr)obj, new IntEditor(obj.getAttrPtr("value"), editor, dt));
			else if (Enum.class.isAssignableFrom(pattr.slot.typeinfo.clazz))
				editor.startItemEditor(pattr.node, new EnumEditor(pattr, dt, editor));
		}
		else if (dr instanceof DrawEnumChoice) {
			DrawEnumChoice dec = (DrawEnumChoice)dr;
			SyntaxEnumChoice stx = (SyntaxEnumChoice)dec.syntax;
			DrawTerm dt = dr.getFirstLeaf();
			if (dt == null) {
				dt = editor.cur_elem.dr.getFirstLeaf();
				if (dt == null)
					dt = editor.cur_elem.dr.getNextLeaf();
			}
			editor.startItemEditor(dec.drnode, new EnumEditor(dec.drnode.getAttrPtr(stx.name), dt, editor));
		}
		else if (dr instanceof DrawBoolChoice) {
			DrawBoolChoice dec = (DrawBoolChoice)dr;
			SyntaxBoolChoice stx = (SyntaxBoolChoice)dec.syntax;
			DrawTerm dt = dr.getFirstLeaf();
			if (dt == null) {
				dt = editor.cur_elem.dr.getFirstLeaf();
				if (dt == null)
					dt = editor.cur_elem.dr.getNextLeaf();
			}
			editor.startItemEditor(dec.drnode, new BoolEditor(dec.drnode.getAttrPtr(stx.name), dt, editor));
		}
		else if (dr.parent() instanceof DrawBoolChoice) {
			DrawBoolChoice dec = (DrawBoolChoice)dr.parent();
			SyntaxBoolChoice stx = (SyntaxBoolChoice)dec.syntax;
			editor.startItemEditor(dec.drnode, new BoolEditor(dec.drnode.getAttrPtr(stx.name), dr.getFirstLeaf(), editor));
		}
		else if (dr.parent() instanceof DrawEnumChoice) {
			DrawEnumChoice dec = (DrawEnumChoice)dr.parent();
			SyntaxEnumChoice stx = (SyntaxEnumChoice)dec.syntax;
			editor.startItemEditor(dec.drnode, new EnumEditor(dec.drnode.getAttrPtr(stx.name), dr.getFirstLeaf(), editor));
		}
	}
}

final class FolderTrigger implements KeyHandler {

	private final Editor	editor;

	FolderTrigger(Editor editor) {
		this.editor = editor;
	}

	public void process() {
		for (Drawable dr = editor.cur_elem.dr; dr != null; dr = (Drawable)dr.parent()) {
			if (dr instanceof DrawFolded) {
				dr.draw_folded = !dr.draw_folded;
				editor.formatAndPaint(true);
				return;
			}
		}
	}
}

final class OptionalTrigger implements KeyHandler {

	private final Editor	editor;

	OptionalTrigger(Editor editor) {
		this.editor = editor;
	}

	public void process() {
		ANode n = editor.cur_elem.dr;
		while (n != null && !(n instanceof DrawNonTerm))
			n = n.parent();
		if (n == null)
			return;
		boolean repaint = false;
		DrawNonTerm drnt = (DrawNonTerm)n;
		foreach (Drawable dr; drnt.args) {
			if (dr instanceof DrawOptional) {
				dr.draw_optional = !dr.draw_optional;
				repaint = true;
			}
		}
		if (repaint)
			editor.formatAndPaint(true);
	}
}

final class FunctionExecuter implements KeyHandler {

	public final Editor		editor;
	public JPopupMenu		menu;

	FunctionExecuter(Editor editor) {
		this.editor = editor;
	}

	public void process() {
		if (menu != null) {
			editor.view_canvas.remove(menu);
			menu = null;
		}
		Drawable dr = editor.cur_elem.dr;
		if (dr == null)
			return;
		SyntaxFunctions sfs = dr.syntax.funcs;
		if (sfs == null || sfs.funcs.length == 0)
			return;
		next_func:
		foreach (SyntaxFunction sf; sfs.funcs) {
			try {
				dr = getTarget(sf);
				if (dr == null)
					continue;
				if (sf.act == SyntaxFuncActions.FuncNewElemOfEmptyList) {
					if (dr.syntax instanceof SyntaxList) {
						SyntaxList slst = (SyntaxList)dr.syntax;
						if (((Object[])dr.drnode.getVal(slst.name)).length == 0)
							addMenu(new NewElemAction(sf.title, dr.drnode, slst));
					}
					else if (dr.attr_syntax instanceof SyntaxList) {
						SyntaxList slst = (SyntaxList)dr.attr_syntax;
						if (((Object[])dr.drnode.getVal(slst.name)).length == 0)
							addMenu(new NewElemAction(sf.title, dr.drnode, slst));
					}
				}
				else if (sf.act == SyntaxFuncActions.FuncNewElemOfNull) {
					if (dr.syntax instanceof SyntaxAttr) {
						SyntaxAttr satr = (SyntaxAttr)dr.syntax;
						if (dr.drnode.getVal(satr.name) == null)
							addMenu(new NewElemAction(sf.title, dr.drnode, satr));
					}
					else if (dr.attr_syntax instanceof SyntaxAttr) {
						SyntaxAttr satr = (SyntaxAttr)dr.attr_syntax;
						if (dr.drnode.getVal(satr.name) == null)
							addMenu(new NewElemAction(sf.title, dr.drnode, satr));
					}
				}
				else if (sf.act == SyntaxFuncActions.FuncEditElem) {
					if (dr.syntax instanceof SyntaxAttr) {
						SyntaxAttr satr = (SyntaxAttr)dr.syntax;
						addMenu(new EditElemAction(sf.title, dr));
					}
					else if (dr.attr_syntax instanceof SyntaxAttr) {
						SyntaxAttr satr = (SyntaxAttr)dr.attr_syntax;
						addMenu(new EditElemAction(sf.title, dr));
					}
				}
			} catch (Throwable t) {}
		}

		if (menu != null) {
			int x = editor.cur_elem.dr.x;
			int y = editor.cur_elem.dr.y + editor.cur_elem.dr.h - editor.view_canvas.translated_y;
			menu.show(editor.view_canvas, x, y);
		}
	}
	
	private Drawable getTarget(SyntaxFunction sf) {
		Drawable dr = editor.cur_elem.dr;
		String[] attrs = sf.attr.split("\\.");
		next_attr:
		foreach(String attr; attrs) {
			while (dr.parent() instanceof DrawCtrl)
				dr = (Drawable)dr.parent();
			if !(dr.parent() instanceof DrawNonTerm)
				return null;
			foreach (Drawable d; ((DrawNonTerm)dr.parent()).args) {
				if (d.syntax instanceof SyntaxAttr && attr.equals(((SyntaxAttr)d.syntax).name)) {
					dr = d;
					continue next_attr;
				}
				if (d.attr_syntax instanceof SyntaxAttr && attr.equals(((SyntaxAttr)d.attr_syntax).name)) {
					dr = d;
					continue next_attr;
				}
			}
			return null;
		}
		return dr;
	}

	private void addMenu(TextAction action) {
		if (menu == null)
			menu = new JPopupMenu();
		menu.add(new JMenuItem(action));
	}

	class NewElemAction extends TextAction {
		private String		text;
		private ANode		node;
		private SyntaxAttr	stx;
		NewElemAction(String text, ANode node, SyntaxAttr stx) {
			super(text);
			this.text = text;
			this.node = node;
			this.stx = stx;
		}
		public void actionPerformed(ActionEvent e) {
			if (menu != null) {
				editor.view_canvas.remove(menu);
				menu = null;
			}
			new NewElemEditor(editor,NewElemEditor.SETNEW_HERE).makeMenu(text, node, stx);
		}
	}

	class EditElemAction extends TextAction {
		private String		text;
		private Drawable	dr;
		EditElemAction(String text, Drawable dr) {
			super(text);
			this.text = text;
			this.dr = dr;
		}
		public void actionPerformed(ActionEvent e) {
			if (menu != null) {
				editor.view_canvas.remove(menu);
				menu = null;
			}
			new ChooseItemEditor(editor, dr).process();
		}
	}
}

final class NewElemEditor implements KeyHandler, KeyListener, PopupMenuListener {

	static final int SETNEW_HERE = 0;
	static final int INSERT_NEXT = 1;

	final Editor		editor;
	final int			mode;
	      int			idx;
	      JPopupMenu	menu;

	NewElemEditor(Editor editor, int mode) {
		this.editor = editor;
		this.mode = mode;
	}
	
	private void assItems(JPopupMenu menu, SymbolRef[] expected_types, ANode n, String name) {
		foreach (SymbolRef sr; expected_types) {
			if (sr.dnode instanceof Struct)
				menu.add(new JMenuItem(new NewElemAction((Struct)sr.dnode, n, name)));
			else if (sr.dnode instanceof SyntaxExpectedTemplate)
				assItems(menu, ((SyntaxExpectedTemplate)sr.dnode).expected_types, n, name);
		}
	}

	public void makeMenu(String title, ANode n, SyntaxAttr satt) {
		menu = new JPopupMenu(title);
		assItems(menu, satt.expected_types, n, satt.name);
		menu.addPopupMenuListener(this);
		int x = editor.cur_elem.dr.x;
		int y = editor.cur_elem.dr.y + editor.cur_elem.dr.h - editor.view_canvas.translated_y;
		menu.show(editor.view_canvas, x, y);
		editor.startItemEditor(n, this);
	}

	public void process() {
		if (mode == SETNEW_HERE) {
			Drawable dr = editor.cur_elem.dr;
			if (dr instanceof DrawPlaceHolder && ((SyntaxPlaceHolder)dr.syntax).parent instanceof SyntaxAttr) {
				ANode n = dr.drnode;
				SyntaxAttr satt = (SyntaxAttr)((SyntaxPlaceHolder)dr.syntax).parent;
				makeMenu("Set new item", n, satt);
				return;
			}
			if (dr instanceof DrawNodeTerm && (dr.drnode == null || dr.getAttrPtr().get() == null)) {
				ANode n = dr.drnode;
				while (n == null) {
					dr = (Drawable)dr.parent();
					n = dr.drnode;
				}
				SyntaxAttr satt = (SyntaxAttr)dr.syntax;
				makeMenu("Set new item", n, satt);
				return;
			}
			ActionPoint ap = editor.getActionPoint();
			if (ap != null && ap.length >= 0) {
				SyntaxList slst = (SyntaxList)ap.dr.syntax;
				this.idx = ap.index;
				makeMenu("Insert new item", ap.node, slst);
				return;
			}
		}
		else if (mode == INSERT_NEXT) {
			ActionPoint ap = editor.getActionPoint();
			if (ap != null && ap.length >= 0) {
				SyntaxList slst = (SyntaxList)ap.dr.syntax;
				this.idx = ap.index+1;
				if (this.idx > ap.length)
					this.idx = ap.length;
				makeMenu("Append new item", ap.node, slst);
				return;
			}
		}
	}
	
	public void keyReleased(KeyEvent evt) {}
	public void keyTyped(KeyEvent evt) {}
	public void keyPressed(KeyEvent evt) {}
	public void popupMenuCanceled(PopupMenuEvent e) {
		if (menu != null)
			editor.view_canvas.remove(menu);
		editor.stopItemEditor(true);
	}
	public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
	public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}
	class NewElemAction extends TextAction {
		private Struct	cls;
		private ANode	node;
		private String	attr;
		NewElemAction(Struct cls, ANode node, String attr) {
			super(cls.sname);
			this.cls = cls;
			this.node = node;
			this.attr = attr;
		}
		public void actionPerformed(ActionEvent e) {
			if (menu != null)
				editor.view_canvas.remove(menu);
			node = ANode.getVersion(node).open();
			foreach (AttrSlot a; node.values(); a.name == attr) {
				try {
					ANode obj = (ANode)Class.forName(cls.qname()).newInstance();
					if (a.is_space) {
						SpaceAttrSlot<ANode> sas = (SpaceAttrSlot<ANode>)a;
						if (idx < 0)
							idx = 0;
						else if (idx > sas.get(node).length)
							idx = sas.get(node).length;
						sas.insert(node,idx,obj);
					} else {
						a.set(node, obj);
					}
				} catch (Throwable t) {
					t.printStackTrace();
					editor.stopItemEditor(true);
					a = null;
				}
				if (a != null)
					editor.stopItemEditor(false);
				return;
			}
			editor.stopItemEditor(true);
			return;
		}
	}
}

abstract class TextEditor implements KeyListener {
	
	protected final Editor		editor;
	protected final DrawTerm	dr_term;
	protected       int			edit_offset;
	protected       boolean		in_combo;
	protected       JComboBox	combo;

	TextEditor(Editor editor, DrawTerm dr_term) {
		this.editor = editor;
		this.dr_term = dr_term;
		this.editor.view_canvas.cursor_offset = edit_offset;
	}

	abstract String getText();
	abstract void setText(String text);

	public void keyReleased(KeyEvent evt) {}
	public void keyTyped(KeyEvent evt) {}
	
	public void keyPressed(KeyEvent evt) {
		int code = evt.getKeyCode();
		int mask = evt.getModifiersEx() & (KeyEvent.CTRL_DOWN_MASK|KeyEvent.SHIFT_DOWN_MASK|KeyEvent.ALT_DOWN_MASK);
		if (mask != 0 && mask != KeyEvent.SHIFT_DOWN_MASK)
			return;
		evt.consume();
		String text = this.getText();
		if (text == null) { text = ""; }
		int prefix_offset = dr_term.getPrefix().length();
		if (edit_offset < 0) {
			edit_offset = 0;
			editor.view_canvas.cursor_offset = edit_offset+prefix_offset;
		}
		if (edit_offset > text.length()) {
			edit_offset = text.length();
			editor.view_canvas.cursor_offset = edit_offset+prefix_offset;
		}
		switch (code) {
		case KeyEvent.VK_DOWN:
			if (in_combo) {
				int count = combo.getItemCount();
				if (count == 0) {
					in_combo = false;
					break;
				}
				int idx = combo.getSelectedIndex();
				idx++;
				if (idx >= count)
					idx = 0;
				combo.setSelectedIndex(idx);
				break;
			}
			else if (combo != null && combo.getItemCount() > 0) {
				in_combo = true;
				if (combo.getSelectedIndex() < 0)
					combo.setSelectedIndex(0);
			}
			break;
		case KeyEvent.VK_UP:
			if (in_combo) {
				int count = combo.getItemCount();
				if (count == 0) {
					in_combo = false;
					break;
				}
				int idx = combo.getSelectedIndex();
				idx--;
				if (idx < 0)
					idx = count-1;
				combo.setSelectedIndex(idx);
				break;
			}
			else if (combo != null && combo.getItemCount() > 0) {
				in_combo = true;
				if (combo.getSelectedIndex() < 0)
					combo.setSelectedIndex(combo.getItemCount()-1);
			}
			break;
		case KeyEvent.VK_HOME:
			edit_offset = 0;
			break;
		case KeyEvent.VK_END:
			edit_offset = text.length();
			break;
		case KeyEvent.VK_LEFT:
			if (edit_offset > 0)
				edit_offset--;
			break;
		case KeyEvent.VK_RIGHT:
			if (edit_offset < text.length())
				edit_offset++;
			break;
		case KeyEvent.VK_DELETE:
			if (edit_offset < text.length()) {
				text = text.substring(0, edit_offset)+text.substring(edit_offset+1);
				this.setText(text);
			}
			break;
		case KeyEvent.VK_BACK_SPACE:
			if (edit_offset > 0) {
				edit_offset--;
				text = text.substring(0, edit_offset)+text.substring(edit_offset+1);
				this.setText(text);
			}
			break;
		case KeyEvent.VK_ENTER:
			if (in_combo) {
				in_combo = false;
				String text = (String)combo.getSelectedItem();
				this.setText(text);
				edit_offset = text.length();
				combo.setPopupVisible(false);
				break;
			} else {
				editor.view_canvas.cursor_offset = edit_offset = -1;
				editor.stopItemEditor(false);
				if (combo != null)
					editor.view_canvas.remove(combo);
				return;
			}
		case KeyEvent.VK_ESCAPE:
			if (in_combo) {
				in_combo = false;
				combo.setSelectedIndex(-1);
				combo.setPopupVisible(false);
				if (combo.getItemCount() > 0)
					combo.setPopupVisible(true);
				break;
			} else {
				editor.view_canvas.cursor_offset = edit_offset = -1;
				editor.stopItemEditor(true);
				if (combo != null)
					editor.view_canvas.remove(combo);
				return;
			}
		default:
			if (evt.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {
				text = text.substring(0, edit_offset)+evt.getKeyChar()+text.substring(edit_offset);
				edit_offset++;
				this.setText(text);
			}
		}
		editor.view_canvas.cursor_offset = edit_offset+prefix_offset;
		editor.formatAndPaint(true);
	}
}

final class SymbolEditor extends TextEditor {
	
	private final Symbol	symbol;

	SymbolEditor(Symbol symbol, Editor editor, DrawTerm dr_term) {
		super(editor, dr_term);
		this.symbol = symbol;
		String text = this.getText();
		if (text != null) {
			edit_offset = text.length();
			editor.view_canvas.cursor_offset = edit_offset + dr_term.getPrefix().length();
		}
	}
	
	String getText() {
		return ANode.getVersion(symbol).sname;
	}
	void setText(String text) {
		ANode.getVersion(symbol).sname = text;
	}
}

final class SymRefEditor extends TextEditor implements ComboBoxEditor {
	
	private final SymbolRef<DNode>		symref;

	SymRefEditor(SymbolRef<DNode> symref, Editor editor, DrawTerm dr_term) {
		super(editor, dr_term);
		this.symref = symref;
		String text = this.getText();
		if (text != null) {
			edit_offset = text.length();
			editor.view_canvas.cursor_offset = edit_offset + dr_term.getPrefix().length();
		}
		showAutoComplete();
	}
	
	String getText() {
		return ANode.getVersion(symref).name;
	}
	void setText(String text) {
		SymbolRef<DNode> symref = ANode.getVersion(this.symref);
		String name = symref.name;
		if (name == null || !name.equals(text)) {
			symref.name = text;
			symref.symbol = null;
			showAutoComplete();
		}
	}
	
	void showAutoComplete() {
		SymbolRef<DNode> symref = ANode.getVersion(this.symref);
		String name = symref.name;
		if (name == null || name.length() == 0)
			return;
		DNode[] decls = symref.findForResolve(false);
		if (decls == null)
			return;
		if (combo == null) {
			combo = new JComboBox();
			combo.setOpaque(false);
			combo.setEditable(true);
			combo.setEditor(this);
			combo.configureEditor(this, name);
			combo.setMaximumRowCount(10);
			combo.setPopupVisible(false);
			editor.view_canvas.add(combo);
		} else {
			combo.removeAllItems();
		}
		combo.setPopupVisible(false);
		int x = dr_term.x;
		int y = dr_term.y - editor.view_canvas.translated_y;
		int w = dr_term.w;
		int h = dr_term.h;
		combo.setBounds(x, y, w+100, h);
		boolean popup = false;
		foreach (DNode dn; decls) {
			combo.addItem(dn.sname);
			popup = true;
		}
		if (popup) {
			if (!in_combo)
				combo.setSelectedIndex(-1);
			combo.setPopupVisible(true);
		} else {
			in_combo = false;
		}
	}
	
	public void addActionListener(ActionListener l) {}
	public void removeActionListener(ActionListener l) {}
	public Component getEditorComponent() { return null; }
	public Object getItem() { return ANode.getVersion(this.symref).name; }
	public void selectAll() {}
	public void setItem(Object text) {
		if (text != null) {
			setText((String)text);
			editor.formatAndPaint(true);
		}
	}
}

final class StrEditor extends TextEditor {
	
	private final AttrPtr	pattr;

	StrEditor(AttrPtr pattr, Editor editor, DrawTerm dr_term) {
		super(editor, dr_term);
		this.pattr = pattr;
		String text = this.getText();
		if (text != null) {
			edit_offset = text.length();
			editor.view_canvas.cursor_offset = edit_offset + dr_term.getPrefix().length();
		}
	}
	
	String getText() {
		return (String)pattr.get();
	}
	void setText(String text) {
		pattr.set(text);
	}
}

final class IntEditor extends TextEditor {
	
	private final AttrPtr	pattr;

	IntEditor(AttrPtr pattr, Editor editor, DrawTerm dr_term) {
		super(editor, dr_term);
		this.pattr = pattr;
		String text = this.getText();
		if (text != null) {
			edit_offset = text.length();
			editor.view_canvas.cursor_offset = edit_offset + dr_term.getPrefix().length();
		}
	}
	
	String getText() {
		Object o = pattr.get();
		if (o == null)
			return null;
		return String.valueOf(o);
	}
	void setText(String text) {
		pattr.set(Integer.valueOf(text));
	}
}

final class BoolEditor implements KeyListener, PopupMenuListener {
	
	private final Editor		editor;
	private final AttrPtr		pattr;
	private final JPopupMenu	menu;

	BoolEditor(AttrPtr pattr, DrawTerm cur_elem, Editor editor) {
		this.editor = editor;
		this.pattr = pattr;
		menu = new JPopupMenu();
		menu.add(new JMenuItem(new SetSyntaxAction(Boolean.FALSE)));
		menu.add(new JMenuItem(new SetSyntaxAction(Boolean.TRUE)));
		int x = cur_elem.x;
		int y = cur_elem.y + cur_elem.h - editor.view_canvas.translated_y;
		menu.addPopupMenuListener(this);
		menu.show(editor.view_canvas, x, y);
	}
	
	public void popupMenuCanceled(PopupMenuEvent e) {
		editor.view_canvas.remove(menu);
		editor.stopItemEditor(true);
	}
	public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
	public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}

	public void keyReleased(KeyEvent evt) {}
	public void keyTyped(KeyEvent evt) {}
	public void keyPressed(KeyEvent evt) {
/*		int code = evt.getKeyCode();
		int mask = evt.getModifiersEx() & (KeyEvent.CTRL_DOWN_MASK|KeyEvent.SHIFT_DOWN_MASK|KeyEvent.ALT_DOWN_MASK);
		if (mask != 0)
			return;
		evt.consume();
		switch (code) {
		case KeyEvent.VK_SPACE:
			Boolean val = (Boolean)pattr.get();
			if (val.booleanValue())
				pattr.set(Boolean.FALSE);
			else
				pattr.set(Boolean.TRUE);
			editor.stopItemEditor(false);
			break;
		case KeyEvent.VK_T:
			pattr.set(Boolean.TRUE);
			editor.stopItemEditor(false);
			break;
		case KeyEvent.VK_F:
			pattr.set(Boolean.FALSE);
			editor.stopItemEditor(false);
			break;
		case KeyEvent.VK_ENTER:
			editor.stopItemEditor(false);
			return;
		case KeyEvent.VK_ESCAPE:
			editor.stopItemEditor(true);
			return;
		}
		editor.formatAndPaint(true);
*/	}

	class SetSyntaxAction extends TextAction {
		private Boolean val;
		SetSyntaxAction(Boolean val) {
			super(val.toString());
			this.val = val;
		}
		public void actionPerformed(ActionEvent e) {
			editor.view_canvas.remove(menu);
			try {
				pattr.set(val);
			} catch (Throwable t) {
				editor.stopItemEditor(true);
				e = null;
			}
			if (e != null)
				editor.stopItemEditor(false);
		}
	}
}

class EnumEditor implements KeyListener, PopupMenuListener {
	private final Editor		editor;
	private final AttrPtr		pattr;
	private final JPopupMenu	menu;
	EnumEditor(AttrPtr pattr, DrawTerm cur_elem, Editor editor) {
		this.editor = editor;
		this.pattr = pattr;
		menu = new JPopupMenu();
		EnumSet ens = EnumSet.allOf(pattr.slot.typeinfo.clazz);
		foreach (Enum e; ens.toArray())
			menu.add(new JMenuItem(new SetSyntaxAction(e)));
		int x = cur_elem.x;
		int y = cur_elem.y + cur_elem.h - editor.view_canvas.translated_y;
		menu.addPopupMenuListener(this);
		menu.show(editor.view_canvas, x, y);
	}

	public void keyReleased(KeyEvent evt) {}
	public void keyTyped(KeyEvent evt) {}
	public void keyPressed(KeyEvent evt) {}
	
	public void popupMenuCanceled(PopupMenuEvent e) {
		editor.view_canvas.remove(menu);
		editor.stopItemEditor(true);
	}
	public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
	public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}

	class SetSyntaxAction extends TextAction {
		private Enum val;
		SetSyntaxAction(Enum val) {
			super(val.toString());
			this.val = val;
		}
		public void actionPerformed(ActionEvent e) {
			editor.view_canvas.remove(menu);
			try {
				pattr.set(val);
			} catch (Throwable t) {
				editor.stopItemEditor(true);
				e = null;
			}
			if (e != null)
				editor.stopItemEditor(false);
		}
	}
}

final class FindDialog extends JDialog implements ActionListener {
	private Editor the_view;
	private ANode cur_node;
	private JTextField text;
	private JOptionPane optionPane;
	FindDialog(JFrame parent, Editor the_view) {
		super(parent,"Find",false);
		this.the_view = the_view;
		cur_node = the_view.cur_elem.dr.drnode;
		this.text = new JTextField();
		JButton bnFind = new JButton("Find");
		JButton bnCancel = new JButton("Cancel");
		bnFind.setActionCommand("find");
		bnFind.addActionListener(this);
		bnCancel.setActionCommand("cancel");
		bnCancel.addActionListener(this);
		this.optionPane = new JOptionPane(
			text,
			JOptionPane.QUESTION_MESSAGE,
			JOptionPane.OK_CANCEL_OPTION,
			null,
			new Object[]{bnFind,bnCancel},
			bnFind
		);
		setContentPane(this.optionPane);
	}
	public void actionPerformed(ActionEvent e) {
		if ("find".equals(e.getActionCommand())) {
			System.out.println("Find: "+text.getText());
			String txt = text.getText();
			if (txt != null && txt.length() > 0)
				lookup(txt);
		}
		else if ("cancel".equals(e.getActionCommand())) {
			this.dispose();
		}
	}
	private void lookup(String txt) {
		try {
			cur_node.walkTree(new TreeWalker() {
				public boolean pre_exec(ANode n) {
					if (n.getClass().getName().indexOf(txt) >= 0)
						throw new FoundException(n);
					return true;
				}
			});
		} catch (FoundException e) {
			setNode(e.node);
		}
	}
	private void setNode(ANode n) {
		Vector<ANode> path = new Vector<ANode>();
		path.append(n);
		while (n.parent() != null) {
			n = n.parent();
			path.append(n);
		}
		the_view.goToPath(path.toArray());
	}
	static class FoundException extends RuntimeException {
		final ANode node;
		FoundException(ANode n) { this.node = n; }
	}
}
