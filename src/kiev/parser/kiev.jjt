/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = true;
  MULTI = true;
  NODE_PACKAGE = "kiev.parser";
  NODE_USES_DESCRIPTOR_ID = false;
  BUILD_NODE_FILES = false;
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev020)

package kiev.parser;

import kiev.Kiev;
import kiev.Kiev.Ext;
import kiev.vlang.*;

/*{

import syntax kiev.parser.TypeAliases;
import static kiev.vlang.AccessFlags.*;

typedef NArr<ASTArgumentDeclaration> NArrArgDecls;
typedef NArr<TypeRef> NArrTypeRefs;

}*/ 

public class kiev020 {

	public static boolean	interface_only = false;
	public static boolean	reparse_body = false;
	public static int		reparse_pos = 0;
	public static PreScanneable		presc = null;

	public static boolean	declMode = true;

	static JJTkiev020State getJJTree() { return jjtree; }

    /** Report Parser Error (Exception) */
	public static void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	public static void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	public void reset() {
		jjtree.reset();
	}

	private static boolean checkNoSpace(Token t1, Token t2) {
		return t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn;
	}

	public static final int[] noColonTokenSet = new int[]{COLON};

	public static int[] no_tokens;

	private static boolean notAToken(Token t) {
		if( no_tokens == null ) return true;
		for(int i=0; i < no_tokens.length; i++) {
			if( t.kind == no_tokens[i] ) return false;
		}
		return true;
	}

	private static boolean labledStatementLA() {
		for(int idx=1; ;idx+=2) {
			if (getToken(idx).kind != IDENTIFIER || getToken(idx+1).kind != COLON)
				return false;
			switch(getToken(idx+2).kind) {
			case LBRACE:
			case SEMICOLON:
			case SWITCH:
			case IF:
			case WHILE:
			case DO:
			case FOR:
			case FOREACH:
			case BREAK:
			case CONTINUE:
			case RETURN:
			case THROW:
			case SYNCHRONIZED:
			case WITH:
			case TRY:
			case GOTO:
			case REPARSE_STATEMENT:
				return true;
			}
		}
	}

	private static boolean operatorLA(int tk) {
		switch( getToken(tk).kind ) {
		case ASSIGN:
		case ASSIGN2:
		case LT:
		case GT:
		case COLON:
		case QUESTION:
		case ARROW:
		case BANG:
		case TILDE:
		case EQ:
		case LE:
		case GE:
		case NE:
		case SC_OR:
		case SC_AND:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
		case STAR:
		case SLASH:
		case BIT_AND:
		case BIT_OR:
		case XOR:
		case REM:
		case LSHIFT:
		case PLUSASSIGN:
		case MINUSASSIGN:
		case STARASSIGN:
		case SLASHASSIGN:
		case ANDASSIGN:
		case ORASSIGN:
		case XORASSIGN:
		case REMASSIGN:
		case LSHIFTASSIGN:
		case RSIGNEDSHIFTASSIGN:
		case RUNSIGNEDSHIFTASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR:
			return notAToken(getToken(tk));
		case OPERATOR_ID:
			return true;
		}
		return false;
	}

	private static boolean castLA_Start() {
		int i = 1;
		Token t = getToken(i);
		if (t.kind == IDENTIFIER) {
			String qname = t.image;
			while( getToken(i+1).kind == DOT && getToken(i+2).kind == IDENTIFIER) {
				i += 2;
				qname = qname + "." + getToken(i).image;
			}
			switch (getToken(i+1).kind) {
			case RPAREN:
			case LT:
			case LBRACKET:
				break;
			default:
				return false;
			}
			try {
				if( PassInfo.checkClassName(KString.from(qname)) ) {
					return true;
				}
			} catch( Exception e ) {}
		}
		return false;
	}

	private static boolean castLA() {
		if( getToken(1).kind != LPAREN ) return false;
		if( getToken(2).kind == CAST ) return true;
		if( getToken(2).kind == REINTERP ) return true;
		return castLA(1,LPAREN,RPAREN);
	}

	private static boolean castLA(int offs, int exp_kind1, int exp_kind2) {
		if( getToken(offs).kind != exp_kind1 ) return false;
		switch( getToken(offs+1).kind ) {
		case BOOLEAN: case CHAR: case BYTE:
		case SHORT: case INT: case LONG: case FLOAT:
		case DOUBLE: case VOID:
			return true;
		case IDENTIFIER:
			break;
		case LPAREN:
			// Skip until matched ')' and check for "->"
			{
				int i = offs+2;
				int depth = 1;
				while( depth != 0 ) {
					switch(getToken(i++).kind) {
					case LPAREN: depth++; break;
					case RPAREN: depth--; break;
					}
				}
				if( getToken(i).kind==ARROW ) {
					return true;
				} else {
					return false;
				}
			}
		default:
			// TODO closure type
			return false;
		}
		// Qualified name resolving to be a class name
		String qname = getToken(offs+1).image;
	scan_qname:
		for(int i=offs+2; ; i+=2) {
			if( getToken(i).kind == DOT && getToken(i+1).kind == IDENTIFIER )
				qname = qname+"."+getToken(i+1).image;
			else {
				switch( getToken(i).kind ) {
				case RPAREN:
					if( exp_kind2 == RPAREN )  break scan_qname;
					else return false;
				case GT:
					if( exp_kind2 == GT ) break scan_qname;
					else return false;
				case LT:
					if( castLA(i,LT,GT) ) break scan_qname;
					else return false;
				case LBRACKET:
					if( getToken(i+1).kind == RBRACKET ) {
						return true;
					}
					else return false;
				case COMMA:
					if( exp_kind1 == LT ) break scan_qname;
					else return false;
				default:
					return false;
				}
			}
		}
		try {
			if( PassInfo.checkClassName(KString.from(qname)) ) {
				return true;
			}
		} catch( Exception e ) {}
		return false;
	}
	
	/*{
	private static Struct mkStruct(ASTIdentifier name, int flags, ASTModifiers modifiers, ASTNode parent) {
		ClazzName clname;
		if (parent instanceof FileUnit) {
			clname = ClazzName.fromOuterAndName(((FileUnit)parent).pkg.clazz,name.name,false,false);
		}
		else if (parent instanceof Struct) {
			clname = ClazzName.fromOuterAndName(PassInfo.clazz,name.name,false,true);
		}
		else if (name != null) {
			// Construct name of local class
			KString bytecode_name =
				KString.from(PassInfo.clazz.name.bytecode_name
					+"$"+PassInfo.clazz.countAnonymouseInnerStructs()
					+"$"+name.name);
			KString fixname = bytecode_name.replace('/','.');
			clname = new ClazzName(fixname,name.name,bytecode_name,false,false);
		}
		else {
			// Local anonymouse class
			KString bytecode_name =
				KString.from(PassInfo.clazz.name.bytecode_name
					+"$"+PassInfo.clazz.countAnonymouseInnerStructs());
			clname = ClazzName.fromBytecodeName(bytecode_name, false);
		}
		Struct clazz = Env.newStruct(clname,PassInfo.clazz,flags|modifiers.getFlags(),true);
		if (name != null)
			clazz.pos  = name.pos;
		else
			clazz.pos  = parent.pos;
		if (modifiers.acc != null)
			clazz.acc  = modifiers.acc;
		if      (parent instanceof FileUnit)
			clazz.setLocal(false);
		else if (parent instanceof Struct)
			clazz.setLocal(parent.isLocal());
		else
			clazz.setLocal(true);
		foreach (Meta m; modifiers.annotations)
			clazz.meta.set(m);
		return clazz;
	}

	private static BaseStruct mkStructArg(ASTIdentifier name, ASTModifiers modifiers, ASTNode parent) {
		BaseStruct arg;
		if (parent instanceof Struct) {
			Struct s = (Struct)parent;
			arg = Env.newArgument(name.name, s);
			s.args += arg;
		} else {
			ASTMethodDeclaration m = (ASTMethodDeclaration)parent;
			arg = Env.newMethodArgument(name.name, PassInfo.clazz);
			m.argtypes += arg;
		}
		arg.pos  = name.pos;
		foreach (Meta m; modifiers.annotations)
			arg.meta.set(m);
		return arg;
	}
	}*/

}

PARSER_END(kiev020)


TOKEN_MGR_DECLS :
{
  static int skip_depth = 0;
}

<DEFAULT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT>
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<DEFAULT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
//| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
// | < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" > { if(Kiev.javaMode||Kiev.disabled(Ext.With)) matchedToken.kind=IDENTIFIER; }
// | < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < UNDERSCORE: "_" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ARROW: "->" >
| < FUNCTION: "fun" >
| < VIRTUAL: "virtual" > { if(Kiev.javaMode || Kiev.disabled(Ext.VirtualFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < VARARGS: "..." >
| < FORWARD: "forward" > { if(Kiev.javaMode || Kiev.disabled(Ext.Forward) /*|| !kiev020.declMode*/) matchedToken.kind=IDENTIFIER; }
| < RULE: "rule" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < PCUT: "$cut" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < CAST: "$cast" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < REINTERP: "$reinterp" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ALIAS: "alias" > { if(Kiev.javaMode || Kiev.disabled(Ext.Alias)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < OPERATOR_ID: "operator" > { if(Kiev.javaMode || Kiev.disabled(Ext.Operator) ) matchedToken.kind=IDENTIFIER; }
| < TYPEDEF: "typedef" > { if(Kiev.javaMode || Kiev.disabled(Ext.Typedef)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENUM: "enum" > { if(Kiev.javaMode || Kiev.disabled(Ext.Enum) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < REQUIRE: "require" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENSURE: "ensure" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < INVARIANT: "invariant" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < GENERATE: "$generate" > { if(Kiev.javaMode || Kiev.disabled(Ext.Templates) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < PACKED: "packed" > { if(Kiev.javaMode || Kiev.disabled(Ext.PackedFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < WRAPPER: "$wrapper" > { if(Kiev.javaMode || Kiev.disabled(Ext.Wrappers) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< ACCESS: "access:" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY: "ro" | "r" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < WRITE_ONLY: "wo" | "w"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < READ_WRITE: "rw" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < NO_READ_WRITE: "n" | "no" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < COMMA1: "," >
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < REPARSE_EXPRESSION:
      "#" ["E","e"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
|
  < REPARSE_STATEMENT:
      "#" ["S","s"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "ID#" <ID_STRING_LITERAL> ) >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON: ":" >
| < QUESTION: "?" >
}

<DEFAULT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
}

<DEFAULT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >
//| < GT: ">" >
//| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
//| < HOOK: "?" >
//| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//| < RSIGNEDSHIFT: ">>" >
//| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP:	"#" >
| < OPERATOR:	    ["\u2200"-"\u22F1"] >

}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTFileUnit FileUnit(String filename) :
{ ASTPragma pr; }
{
	{
		ASTFileUnit n = jjtThis;
		Kiev.curFileUnit = jjtThis;
		jjtThis.filename = KString.from(filename);
		jjtThis.setPos(0);
		declMode = true;
		ASTModifiers modifiers;
	}
	[	n.pkg = Package()	]
	{ PassInfo.push(n.pkg.clazz); }
	try {
	(
		n.syntax += Import()
	|	n.syntax += Typedef()
	|	n.syntax += Opdef()
	|	pr        = Pragma() { n.setPragma(pr); n.syntax += pr; }
	)*
	(
		modifiers = Modifiers()
		try {
			n.members += TypeDeclaration(modifiers, n) [ ";" ]
	|		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			n.members += SyntaxDeclaration(modifiers, n) [ ";" ]
		}
		catch(ParseError e) { rpe("Bad class declaration",e); }
		catch(Throwable e) { rperr(e); }
	)*
	} finally { {PassInfo.pop(n.pkg.clazz); } }
	<EOF>
	{
		declMode = true;
		return jjtThis;
	}
}

ASTModifiers Modifiers() :
{}
{
	(	LOOKAHEAD(2)
		try {
			(
				jjtThis.annotations += Annotation()
			|	                       Modifier()
			|	jjtThis.annotations += Pack()
			|	jjtThis.acc          = Access()
			)
		}
		catch(ParseError e) { rpe("Bad modifiers",e); }
		catch(Throwable e) { rperr(e); }
	)*
	{ jjtree.popNode(); return jjtThis; }
}

StructRef Package() #void :
{}
{
	try {
		"package" QName() ";"
	}
	catch(ParseError e) { rpe("Bad package declaration",e); }
	catch(Throwable e) { rperr(e); }
	{
		ASTQName qn = (ASTQName)jjtree.popNode();
		Struct pkg = Env.newPackage(qn.toKString());
		StructRef r = new StructRef(pkg);
		r.pos = qn.pos;
		return r;
	}
}

ASTPragma Pragma() :
{}
{
	"pragma"
	(
		<PRAGMA_ENABLE>		{ jjtThis.enable = true; }
	|	<PRAGMA_DISABLE>	{ jjtThis.enable = false; }
	)
	( StringConstExpression() )+
	";"
	{ jjtree.popNode(); return jjtThis; }
}

ASTImport Import() :
{}
{
	try {
		"import"
		(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			<IDENTIFIER>{ jjtThis.mode = Import.ImportMode.IMPORT_SYNTAX; }
			[ QName() ]
		|	"package"	{ jjtThis.mode = Import.ImportMode.IMPORT_PACKAGE; }
			[ QName() ]
		|	"static"	{ jjtThis.mode = Import.ImportMode.IMPORT_STATIC; }
			QName()
			[	"." "*" { jjtThis.star = true; }
			|	"("		{ jjtThis.of_method = true; }
				jjtThis.args += Type() ( "," jjtThis.args += Type())*
				")"
			]
		|	QName()
			[	"." "*" { jjtThis.star = true; }
			|	"("		{ jjtThis.of_method = true; }
				jjtThis.args += Type() ("," jjtThis.args += Type())*
				")"
			]
		)
		";"
	}
	catch(ParseError e) { rpe("Bad import declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return jjtThis; }
}

ASTTypedef Typedef() :
{ ASTIdentifier id; ASTOperator op; ASTType tp; }
{
	{ ASTTypedef n = jjtThis; }
	try {
		"typedef"
		(
			LOOKAHEAD(3, <IDENTIFIER> TypeOperatorChar() <IDENTIFIER>, {checkNoSpace(getToken(1),getToken(2))})
			id = Name()
			     Operator() { op = (ASTOperator)jjtree.popNode(); }
			tp = Type()
			{ n.set(id, op, tp); }
		|
			tp = Type()
			id = Name()
			{ n.set(tp, id); }
		) ";"
	}
	catch(ParseError e) { rpe("Bad typedef declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return jjtThis; }
}

ASTOpdef Opdef() :
{}
{
	"operator"
	(
		Operator()
	|	Identifier()
	)
	","
	Identifier()	// FX,FY,XF,YF,XFX,YFX,XFY,YFY
	","
	DecimalConstExpression()
	";"
	{ jjtree.popNode(); return jjtThis; }
}

Struct SyntaxDeclaration(ASTModifiers modifiers, ASTNode parent) #void :
{ Struct clazz; ASTIdentifier name; }
{
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>	// "syntax"
	name = Name()
	{
		clazz = mkStruct(name, ACC_SYNTAX|ACC_PRIVATE|ACC_ABSTRACT, modifiers, parent);
	}
	{ PassInfo.push(clazz); }
	try {
		"{"
		(
			clazz.members += Typedef()
		|	clazz.members += Opdef()
		)*
		"}"
	} finally { PassInfo.pop(clazz); }
	{ return clazz; }
}

Struct TypeDeclaration(ASTModifiers modifiers, ASTNode parent) #void :
{ Struct clazz; ASTIdentifier name; }
{
	(
		"class"
		name = Name()
		{
			clazz = mkStruct(name, 0, modifiers, parent);
		}
		ClazzArguments(clazz)
		[
			"extends"
			(
				LOOKAHEAD("rule")
				clazz.super_bound = PrimitiveType()
			|	clazz.super_bound = NonArrayType()
			)
		]
		[
			"implements"
			clazz.interfaces += NonArrayType()
			( "," clazz.interfaces += NonArrayType()	)*
		]
		[	Generate(clazz.gens)	]
	|	"interface"
		name = Name()
		{
			clazz = mkStruct(name, ACC_INTERFACE, modifiers, parent);
		}
		ClazzArguments(clazz)
		[
			"extends"
			clazz.interfaces += NonArrayType()
			( "," clazz.interfaces += NonArrayType()	)*
		]
		[	Generate(clazz.gens)	]
	|	"@" "interface"
		(	name = Name()
		|	name = KeywordAsName()
		)
		{
			clazz = mkStruct(name, ACC_INTERFACE|ACC_ANNOTATION, modifiers, parent);
		}
	|	"enum"
		name = Name()
		{
			clazz = mkStruct(name, ACC_ENUM|ACC_STATIC, modifiers, parent);
		}
		[
			"extends"
			clazz.super_bound = PrimitiveType()	
		]
	)
	{ PassInfo.push(clazz); }
	try {
		TypeBodyDeclaration(clazz)
	} finally { PassInfo.pop(clazz); }
	{ return clazz; }
}

void TypeBodyDeclaration(Struct clazz) #void :
{ ASTModifiers modifiers; }
{
	{ jjtree.openNodeScope(clazz); }
	try {
		try {
			"{"
		}
		catch(ParseError e) { rpe("'{' expected",e); }
		catch(Throwable e) { rperr(e); }
		try {
			(
				LOOKAHEAD({ clazz.isEnum() })
				modifiers = Modifiers()
				EnumFieldDeclaration(modifiers)
				(	","
					modifiers = Modifiers()
					EnumFieldDeclaration(modifiers)
				)*
				[ ";" ]
			)?
		}
		catch(ParseError e) { rpe("Enumeration values are expected",e); }
		catch(Throwable e) { rperr(e); }
		try {
			(
				modifiers = Modifiers()
				(
					clazz.members += Initializer(modifiers)
				|	clazz.members += InvariantDeclaration(modifiers) [ ";" ]
				|	clazz.members += TypeDeclaration(modifiers, clazz) [ ";" ]
				|	clazz.members += CaseTypeDeclaration(modifiers, clazz) ";"
				|
					LOOKAHEAD( "rule" <IDENTIFIER> "(" )
					clazz.members += RuleDeclaration(modifiers)
				|
					LOOKAHEAD( <IDENTIFIER> "(" )
					clazz.members += ConstructorDeclaration(modifiers)
				|
					LOOKAHEAD( ClazzArguments() Type() <IDENTIFIER> "(" )
					clazz.members += MethodDeclaration(modifiers)
				|
					LOOKAHEAD( Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
					FieldDecls(modifiers, clazz)
				)
			)*
		}
		catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
		catch(Throwable e) { rperr(e); }
		try {
			"}"
		}
		catch(ParseError e) { rpe("'}' expected",e); }
		catch(Throwable e) { rperr(e); }
	} finally { {jjtree.closeNodeScope(clazz, true); ASTNode n = jjtree.popNode(); Debug.assert(clazz==n); } }
}

void EnumFieldDeclaration(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	try {
		Identifier() ["=" DecimalConstExpression()] [":"  StringConstExpression()]
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }
}

Struct CaseTypeDeclaration(ASTModifiers modifiers, Struct parent) #void :
{ ASTIdentifier name; Struct clazz; }
{
	"case"
	name = Name()
	{
		clazz = mkStruct(name, ACC_PIZZACASE|ACC_STATIC, modifiers, parent);
		clazz.super_type = parent.type;
	}
	ClazzArguments(clazz)
	{ jjtree.openNodeScope(clazz); }
	try {
		[
		"("
			try {
			[
				modifiers = Modifiers()
				FormalParameter(modifiers)
				(
					","
					modifiers = Modifiers()
					FormalParameter(modifiers)
				)*
			]
			}
			catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
			catch(Throwable e) { rperr(e); }
		")"
		]
	} finally { {jjtree.closeNodeScope(clazz, true); ASTNode n = jjtree.popNode(); Debug.assert(clazz==n); } }
	{ return clazz; }
}


void ClazzArguments(ASTNode parent) #void :
{}
{
	[
	"<"
		try {
			 ArgumentDeclaration(parent)
			(	","
				ArgumentDeclaration(parent)
			)*
		}
		catch(ParseError e) { rpe("Class's argument expected",e); }
		catch(Throwable e) { rperr(e); }
	">"
	]
}

void Generate(NArrTypeRefs types) #void :
{ Token t; ASTNonArrayType tp; }
{
	"$generate"
	try {
		{ tp = new ASTNonArrayType(new ASTQName()); }
		"<"
			( tp.children += PrimitiveType() | tp.children += Name())
			( "," (tp.children += PrimitiveType() | tp.children += Name()) )*
		">"
		{ types += tp; }
		(
			","
			{ tp = new ASTNonArrayType(new ASTQName()); }
			"<"
				( tp.children += PrimitiveType() | tp.children += Name())
				( "," (tp.children += PrimitiveType() | tp.children += Name()) )*
			">"
			{ types += tp; }
		)*
	}
	catch(ParseError e) { rpe("Bad $generate directive",e); }
	catch(Throwable e) { rperr(e); }
}

BaseStruct ArgumentDeclaration(ASTNode parent) #void :
{ ASTModifiers modifiers; ASTIdentifier name; BaseStruct arg; }
{
	modifiers = Modifiers()
	name      = Name()
	{ arg = mkStructArg(name, modifiers, parent); }
	[
		"extends"
		arg.super_bound = NonArrayType()
	]
	{ return arg; }
}

void Modifier() :
{ Token t=null; }
{
	(
	  t="public"
	| t="protected"
	| t="private"
	| t="static"
	| t="abstract"
	| t="final"
	| t="native"
	| t="synchronized"
	| t="transient"
	| t="volatile"
	| t="virtual"
	| t="forward"

	| t="$wrapper"

	)
	{ jjtThis.set(t); }
}

Meta Pack() #void :
{ Token t; int size=-1; int offset=-1; String packer=null; }
{
	"packed"
	[
		":"
		t=<INTEGER_LITERAL> { size = Integer.parseInt(t.image); t = null; }
		[
		","
		t=<IDENTIFIER> { packer = t.image; t = null; }
		","
		t=<INTEGER_LITERAL> { offset = Integer.parseInt(t.image); t = null; }
		]
	]
	{
		MetaPacked mp = new MetaPacked();
		mp.size       = size;
		mp.offset     = offset;
		mp.fld        = KString.from(packer);
		return mp;
	}
}

Access Access() #void :
{ int acc; 	int accflags = 0; int offset = 6; }
{
	LOOKAHEAD({Kiev.enabled(Ext.Access)})
	"access:"
	acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	]]]
	{ return new Access(accflags); }
}

int AccessSpec() #void :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

ASTIdentifier KeywordAsName() #void :
{ Token t; ASTIdentifier id; }
{
	(
		t="virtual"
	|	t="alias"
	|	t="packed"
	)
	{
		id = new ASTIdentifier();
		jjtree.openNodeScope(id);
		id.set(t);
		jjtree.closeNodeScope(id, true);
		t = null;
		jjtree.popNode();
		return id;
	}
}

ASTIdentifier KeywordAsIdentifier() #void :
{ Token t; ASTIdentifier id; }
{
	(
		t="virtual"
	|	t="alias"
	|	t="packed"
	)
	{
		id = new ASTIdentifier();
		jjtree.openNodeScope(id);
		id.set(t);
		jjtree.closeNodeScope(id, true);
		t = null;
		return id;
	}
}

ASTMeta Annotation() #Meta :
{ ASTIdentifier id; MetaValue v; }
{
	{ ASTMeta n = jjtThis; }
	"@"
	(
		id = Name()
	|	id = KeywordAsName()
	)
	{	n.pos = id.pos;	n.type = new ASTNonArrayType(id); }
	[
		"("
		[	LOOKAHEAD( <IDENTIFIER> "=" )
			AnnotationValues(n)
		|	v = AnnotationValueAny() { n.set(v); }
		]
		")"
	]
	{ jjtree.popNode(); return n; }
}

void AnnotationValues(ASTMeta m) #void :
{ ASTIdentifier id; MetaValue v; }
{
	id = Name()
	"="
	v = AnnotationValueAny()
	{ v.type = new MetaValueType(id.name); m.set(v); }
	(
		","
		id = Name()
		"="
		v = AnnotationValueAny()
		{ v.type = new MetaValueType(id.name); m.set(v); }
	)*
}

MetaValue AnnotationValueAny() #void :
{ ASTNode n; MetaValue v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	|	v = AnnotationValueValueArrayInitializer()
	|	ExpressionNT(null)
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = (ASTNode)jjtree.popNode(); }
	)
	{ return v; }
}

MetaValueScalar AnnotationValueScalar() #void :
{ ASTNode n; MetaValueScalar v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	|	ExpressionNT(null)
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = (ASTNode)jjtree.popNode(); }
	)
	{ return v; }
}

MetaValueArray AnnotationValueValueArrayInitializer() #void :
{ MetaValueScalar n; MetaValueArray v; }
{
	{ v = new MetaValueArray(); }
	"{"
	[
		n = AnnotationValueScalar() { v.values.add(n.value); }
		(	","
			n = AnnotationValueScalar() { v.values.add(n.value); }
		)*
	]
	"}"
	{ return v; }
}


void FieldDecls(ASTModifiers modifiers, Struct clazz) #void :
{ boolean old_declMode; ASTType type; }
{
	{ old_declMode = declMode; declMode = false; }
	try {
		type = Type()
		clazz.members += FieldDecl(modifiers, type, true)
		(	","
			clazz.members += FieldDecl(modifiers, type, false)
		)*
	}
	catch(ParseError e) { rpe("Field declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	finally { declMode = old_declMode; }
	";"
}

ASTFieldDecl FieldDecl(ASTModifiers modifiers, ASTType type, boolean first) :
{}
{
	{
		ASTFieldDecl n = jjtThis;
		if (first) {
			n.modifiers = modifiers;
			n.type = type;
		} else {
			n.modifiers = (ASTModifiers)modifiers.copy();
			n.type = (ASTType)type.copy();
		}
	}
	n.name = Name()
	( "[" "]" { n.dim += 1; } )*
	[ ("=" | ":=" { n.of_wrapper=true; }) VariableInitializer() ]
	{ jjtree.popNode(); return n; }
}

void VarDecls(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers,-1); }
	try {
		jjtThis.type = Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Variable declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	";"
}

void VarDecl() :
{}
{
	Identifier()
	( "[" "]" { jjtThis.dim += 1; } )*
	[ ("=" | ":=" { jjtThis.of_wrapper=true; }) VariableInitializer() ]
}

void VariableInitializer() #void :
{}
{
	(
		ArrayInitializer()
	|
		Expression()
	)
}

void ArrayInitializer() #NewInitializedArrayExpression :
{ Token t; }
{
	t="{"
	[	LOOKAHEAD(2)
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ jjtThis.setPos(t.getPos()); }
}

ASTFormalParameter FormalParameter(ASTModifiers modifiers) :
{ Token t; }
{
	{ jjtThis.modifiers = modifiers; }
	(
		jjtThis.type = Type()
		Identifier()
		( t="[" "]" { jjtThis.type.addOperation(t); } )*
	|
		t="_" { jjtThis.set(t); }
	)
	{ return jjtThis; }
}

ASTFormalParameter mmFormalParameter(ASTModifiers modifiers) #FormalParameter :
{ Token t; }
{
	{ jjtThis.modifiers = modifiers; }
	(
		jjtThis.type = Type()
		(
			LOOKAHEAD({ !Kiev.javaMode && (getToken(1).image.equals(":")) })
			(":") jjtThis.mm_type = Type()
		)?
		Identifier()
		( t="[" "]" { jjtThis.type.addOperation(t); if (jjtThis.mm_type != null) jjtThis.mm_type.addOperation(t); } )*
	|
		t="_" { jjtThis.set(t); }
	)
	{ return jjtThis; }
}

void Throws() :
{ Token t; }
{
	{ ASTThrows n = jjtThis; }
	t="throws" { n.setPos(t.getPos()); }
	try {
		n.children += NonArrayType()
		(	"," n.children += NonArrayType()	)*
	}
	catch(ParseError e) { rpe("Throwable class name expected",e); }
	catch(Throwable e) { rperr(e); }
}


void Alias() #void :
{ Token t; }
{
	"alias"
	try {
		(
			LOOKAHEAD(2)
			OperatorAlias()
		|	IdentifierAlias()
		)
	}
	catch(ParseError e) { rpe("Alias expected",e); }
	catch(Throwable e) { rperr(e); }
}

void IdentifierAlias() :
{}
{
	Identifier()
}

void OperatorAlias() :
{ Token t = null; }
{
	(	// temporary, for backward compatibility
		"operator"
		"("
		DecimalConstExpression()	","
		Identifier()		","
		(
			Operator()
		|	Identifier()
		|	"[" "]"	{ jjtThis.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"	{ jjtThis.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"	{ jjtThis.image = kiev.vlang.Constants.nameCastOp; }
		)
		")"
	|
		t=<IDENTIFIER> { jjtThis.set(t); }
		"operator"
		(
			Operator()
		|	Identifier()
		|	"[" "]"	{ jjtThis.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"	{ jjtThis.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"	{ jjtThis.image = kiev.vlang.Constants.nameCastOp; }
		)
	)
}

void MaybeSkipBlock() #void :
{ boolean old_declMode; }
{
	(
		LOOKAHEAD({ interface_only })
//		{ old_declMode = declMode; declMode = false; }
//		try {
			"{"
			{
			Token tk = getToken(0);
			PrescannedBody pbody = new PrescannedBody(tk.beginLine,tk.beginColumn);
			Kiev.curFileUnit.addPrescannedBody(pbody);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
			presc.pbody = pbody;
			if( presc instanceof ASTRuleDeclaration )
				pbody.mode = PrescannedBody.RuleBlockMode;
			else
				pbody.mode = PrescannedBody.BlockMode;
			}
//		} finally { declMode = old_declMode; }
	|	LOOKAHEAD({ presc instanceof ASTRuleDeclaration })
		RuleBlock()
	|	Block()
	)
}

ASTMethodDeclaration MethodDeclaration(ASTModifiers modifiers) :
{ Token t; }
{
	{
		ASTMethodDeclaration n = jjtThis;
		n.modifiers = modifiers;
	}
	ClazzArguments(n)
	n.rettype = Type()
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		try {
		[
			modifiers = Modifiers()
			mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ jjtThis.setVarArgs(true); }
			]
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(	t="[" "]" { n.rettype.addOperation(t); } )*
	(
		Alias()
	)*
	[	Throws()	]
	try {
		(
			n.conditions += RequareDeclaration()
		|	n.conditions += EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	[ "default" n.annotation_default = AnnotationValueAny() ] ";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}

ASTMethodDeclaration ConstructorDeclaration(ASTModifiers modifiers) #MethodDeclaration :
{ Token t; }
{
	{
		ASTMethodDeclaration n = jjtThis;
		n.modifiers = modifiers;
	}
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		try {
		[
			modifiers = Modifiers()
			mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ jjtThis.setVarArgs(true); }
			]
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		Alias()
	)*
	[	Throws()	]
	try {
		(
			n.conditions += RequareDeclaration()
		|	n.conditions += EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}

ASTRequareDeclaration RequareDeclaration() :
{}
{
	{
		ASTRequareDeclaration n = jjtThis;
		//n.modifiers = modifiers;
		n.cond = WBCType.CondRequire;
	}
	"require"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" n.name = Name() "]"
			n.body = CondBlock()
		|
			LOOKAHEAD(<IDENTIFIER> "{")
			n.name = Name()
			n.body = CondBlock()
		|
			n.body = CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'require' declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}


ASTEnsureDeclaration EnsureDeclaration() :
{}
{
	{
		ASTEnsureDeclaration n = jjtThis;
		//n.modifiers = modifiers;
		n.cond = WBCType.CondEnsure;
	}
	"ensure"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" n.name = Name() "]"
			n.body = CondBlock()
		|
			LOOKAHEAD(<IDENTIFIER> "{")
			n.name = Name()
			n.body = CondBlock()
		|
			n.body = CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'ensure' declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}

ASTInvariantDeclaration InvariantDeclaration(ASTModifiers modifiers) :
{}
{
	{
		ASTInvariantDeclaration n = jjtThis;
		//n.modifiers = modifiers;
		n.cond = WBCType.CondInvariant;
	}
	"invariant"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" n.name = Name() "]"
			n.body = CondBlock()
		|	LOOKAHEAD(<IDENTIFIER> "{")
			n.name = Name()
			n.body = CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'invariant' declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
	
}

ASTRuleDeclaration RuleDeclaration(ASTModifiers modifiers) :
{ ASTBlock bl; }
{
	{
		ASTRuleDeclaration n = jjtThis;
		n.modifiers = modifiers;
	}
	"rule"
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		try {
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		Alias()
	)*
	(
		modifiers = Modifiers()
		VarDecls(modifiers)
	)*
	try {
		(
			n.conditions += RequareDeclaration()
		|	n.conditions += EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}

ASTInitializer Initializer(ASTModifiers modifiers) :
{}
{
	{
		ASTInitializer n = jjtThis;
		n.setFlags(modifiers.getFlags());
		/*{
		foreach (Meta m; modifiers.annotations)
			n.meta.set(m);
		}*/
	}
	try {
		{ presc = jjtThis; }
		MaybeSkipBlock() [ ";" ]
	}
	catch(ParseError e) { rpe("Initializer's body expected",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}



/*
 * Type, name and expression syntax follows.
 */

ASTType Type() #void :
{ ASTType res; Token t; }
{
	(
		res = SimpleType()
		(
			LOOKAHEAD(2,"[" "]")
			t="[" "]"
			{ res.addOperation(t); }
		|	LOOKAHEAD(1,TypeOperatorChar(),{Kiev.enabled(Ext.Typedef)&&checkNoSpace(getToken(0),getToken(1))})
			t=TypeOperatorChar()
			{ res.addOperation(t); }
		)*
	|
		LOOKAHEAD({Kiev.enabled(Ext.With)})
		res = ClosureType()
	)
	{ return res; }
}

ASTType ClosureType() :
{ Token t; }
{
	{ ASTClosureType n = jjtThis; }
	t="(" { n.setPos(t.getPos()); }
	[
		n.types += Type()
		( "," n.types += Type() )*
	]
	")" "->" n.types += Type()
	{ jjtree.popNode(); return n; }
}


ASTType SimpleType() #void :
{ ASTType tp; }
{
		tp = PrimitiveType()
		{ return new ASTNonArrayType((ASTPrimitiveType)tp); }
	|	tp = NonArrayType()
		{ return tp; }
}

ASTType NonArrayType() :
{ Token t; }
{
	{ ASTNonArrayType n = jjtThis; }
	try {
		QName() { n.children += jjtree.popNode(); }
		[	LOOKAHEAD(1, "<", {Kiev.enabled(Ext.Generics)})
			"<"
				n.children += Type()
				( "," n.children += Type() )*
			">"
		]
		(
			LOOKAHEAD(1,TypeOperatorChar(),{Kiev.enabled(Ext.Typedef)&&checkNoSpace(getToken(0),getToken(1))})
			t=TypeOperatorChar()
			{ n.addOperation(t); }
		)*
	}
	catch(ParseError e) { rpe("Bad type specification",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtree.popNode(); return n; }
}

ASTType PrimitiveType() :
{ Token t; }
{
	 (
	  t="boolean"
	| t="char"
	| t="byte"
	| t="short"
	| t="int"
	| t="long"
	| t="float"
	| t="double"
	| t="void"
	| t="rule"
	  )
	{ jjtThis.set(t); jjtree.popNode(); return jjtThis; }
}

ASTIdentifier Identifier() :
{ Token t; }
{
	t=<IDENTIFIER>
	{ jjtThis.set(t); return jjtThis; }
}

ASTIdentifier Name() #void :
{ ASTIdentifier id; }
{
	id = Identifier()
	{ jjtree.popNode(); return id; }
}

void QName() :
{}
{
	try {
		Identifier()
		( LOOKAHEAD(2) "." Identifier() )*
	}
	catch(ParseError e) { rpe("Qualified name expected",e); }
	catch(Throwable e) { rperr(e); }
}

/*
 * Expression syntax follows.
 */

void CommaExpression() #CommaExpression(>1) :
{}
{
	Expression()
	( "," Expression() )*
}

void RuleOrExpression() #RuleOrExpression(>1) :
{}
{
	RuleAndExpression()
	( ";" RuleAndExpression() )*
}

void RuleAndExpression() #RuleAndExpression(>1) :
{}
{
	RuleExpression()
	( "," RuleExpression() )*
}

void RuleExpression() #void :
{ Token t = null; int n; }
{
	(
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_THE
	})
	RuleIstheExpression()
|
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_ONE_OF
	})
	RuleIsoneofExpression()
|
	LOOKAHEAD({getToken(1).kind == PCUT})
	RuleCutExpression()
|
	LOOKAHEAD({getToken(1).kind == LBRACE})
	"{" RuleOrExpression() "}"
|
	LOOKAHEAD({getToken(1).kind == WHILE})
	"while" Expression() { jjtThis.while_mode=true; t=null; }
	#RuleExpression(1)
|
	LOOKAHEAD(0)
	ExpressionNT(noColonTokenSet) { n = 1; }
	[ ":" ExpressionNT(noColonTokenSet) {n = 2;} ]
	#RuleExpression(n)
	)
}

void RuleIstheExpression() :
{}
{
	Identifier() "?=" AccessExpression()
}

void RuleIsoneofExpression() :
{}
{
	Identifier() "@=" AccessExpression()
	(
		LOOKAHEAD({
			getToken(1).image.equals("&")
		 && getToken(2).kind == IDENTIFIER
		 && getToken(3).kind == IS_ONE_OF
		})
		"&" Identifier() "@=" AccessExpression()
	)*
}

void RuleCutExpression() :
{ Token t; }
{
	t="$cut" { jjtThis.setPos(t.getPos()); t = null; }
}

Token TypeOperatorChar() #void :
{ Token t; }
{
	(
		t=<QUESTION>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar() #void :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<ASSIGN2>
	|	t=<LT>
	|	t=<GT>
	|	t=<COLON>
	|	t=<QUESTION>
	|	t=<ARROW>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<EQ>
	|	t=<LE>
	|	t=<GE>
	|	t=<NE>
	|	t=<SC_OR>
	|	t=<SC_AND>
	|	t=<INCR>
	|	t=<DECR>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<LSHIFT>
	|	t=<PLUSASSIGN>
	|	t=<MINUSASSIGN>
	|	t=<STARASSIGN>
	|	t=<SLASHASSIGN>
	|	t=<ANDASSIGN>
	|	t=<ORASSIGN>
	|	t=<XORASSIGN>
	|	t=<REMASSIGN>
	|	t=<LSHIFTASSIGN>
	|	t=<RSIGNEDSHIFTASSIGN>
	|	t=<RUNSIGNEDSHIFTASSIGN>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

void Operator() :
{ Token t; String image; }
{
	(
		t=OperatorChar()
		{ image = t.image; }
		(
			LOOKAHEAD({ !Kiev.javaMode && operatorLA(1) && checkNoSpace(getToken(0),getToken(1)) })
			t=OperatorChar()
			{ image = image+t.image; }
		|
			LOOKAHEAD({ Kiev.javaMode && getToken(1).kind==GT && checkNoSpace(getToken(0),getToken(1)) })
			t=<GT>
			{ image = image+t.image; }
		)*
	|	LOOKAHEAD({ !Kiev.javaMode })
		"operator" t=<IDENTIFIER>
		{ image = t.image; }
	)
	{
		jjtThis.setPos(t.getPos());
		jjtThis.image = KString.from(image);
	}
}

void CastOperatorLA() #void :
{}
{
	"("
	(
		<CAST>
	|	<REINTERP>
	|	PrimitiveType()
	|	LOOKAHEAD(0,{ castLA_Start() }) Type() ")"
		(
			<IDENTIFIER>
		|	"("
		|	ConstExpression()
		|	"new"
		|	Operator()
		|	ReparseExpression()
		|	"fun"
		)
	)
}

void CastOperator() :
{ Token t; }
{
	t="(" { jjtThis.setPos(t.getPos()); } [ <CAST> | <REINTERP> {jjtThis.reinterp=true;} ] jjtThis.type = Type() ")"
}

void ExpressionNT(int[] nt_new) #void :
{ int[] nt_old = no_tokens; no_tokens = nt_new; }
{
	try {
		Expression()
	} finally { no_tokens = nt_old; }
}

void Expression() :
{ ASTType tp; }
{
	try {
		(
			LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("instanceof") })
			Identifier() tp = Type() { jjtree.pushNode(tp); }
		|	LOOKAHEAD({ operatorLA(1) })
			Operator()
//		|	LOOKAHEAD({ castLA() })
		|	LOOKAHEAD( CastOperatorLA() )
			CastOperator()
		|	LOOKAHEAD(2)
			AccessExpression()
		)+
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseExpression() :
{ Token t; }
{
	try {
		t=<REPARSE_EXPRESSION> { jjtThis.set(t); }
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }
}

void CallExpression() :
{}
{
		Identifier() "("
		[	ExpressionNT(null)
			(	"," ExpressionNT(null)	)*
		]
		")"
}

void TypeClassExpression() :
{}
{
	jjtThis.type = Type() "." "class"
}

void AccessExpression() #void :
{ Token t; }
{
	(
		LOOKAHEAD( Type() "." "class" )
		TypeClassExpression()
	|
		LOOKAHEAD(2)
		ConstExpression()
	|
		LOOKAHEAD(2)
		CallExpression()
	|
		LOOKAHEAD(2)
		Identifier()
	|
		LOOKAHEAD("new" SimpleType() ("[" "]")+ "{" )
		NewInitializedArrayExpression()
	|
		LOOKAHEAD("new" SimpleType() "[" )
		NewArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() ( "(" ) )
		NewExpression()
	|
		ReparseExpression()
	|
		"(" ExpressionNT(null) ")"
	|   LOOKAHEAD("fun" "(")
		AnonymouseClosure()
	)
	(
		LOOKAHEAD(3)
		"." CallExpression()	#CallAccessExpression(2)
	|
		LOOKAHEAD(3)
		t="." Identifier()
        { jjtThis.setPos(t.getPos()); }	#AccessExpression(2)
	|	LOOKAHEAD(2)
		t="[" ExpressionNT(null) "]"
        { jjtThis.setPos(t.getPos()); }	#ArrayElementAccessExpression(2)
	|
		LOOKAHEAD("." "new" NonArrayType() ( "(" ) )
		"."
		NewExpression()			#NewAccessExpression(2)
	)*
}

void AnonymouseClosure() :
{ Token t; ASTModifiers modifiers; }
{
	t="fun" "("
	[
		modifiers = Modifiers()
		FormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			FormalParameter(modifiers)
		)*
	]
	")" "->"
    { jjtThis.setPos(t.getPos()); }
    (
		LOOKAHEAD( { getToken(1).kind == RULE } )
		jjtThis.rettype = Type() RuleBlock()
	|	jjtThis.rettype = Type() Block()
	)
}

void ConstExpression() #void :
{}
{
	(
		BooleanConstExpression()
	|	DecimalConstExpression()
	|	FloatConstExpression()
	|	CharConstExpression()
	|	NullConstExpression()
	|	StringConstExpression()
	)
}

void BooleanConstExpression() #ConstExpression :
{ Token t; }
{
	(
		t="true"
	|	t="false"
	)
	{ jjtThis.set(t); }
}

void DecimalConstExpression() #ConstExpression :
{ Token t; }
{
	(
	 	t=<INTEGER_LITERAL>
	|	t=<LONG_INTEGER_LITERAL>
	)
	{ jjtThis.set(t); }
}

void FloatConstExpression() #ConstExpression :
{ Token t; }
{
	(
		t=<FLOATING_POINT_LITERAL>
	|	t=<DOUBLE_POINT_LITERAL>
	)
	{ jjtThis.set(t); }
}

void CharConstExpression() #ConstExpression :
{ Token t; }
{
	t=<CHARACTER_LITERAL>
	{ jjtThis.set(t); }
}

void NullConstExpression() #ConstExpression :
{ Token t; }
{
	t="null"
	{ jjtThis.set(t); }
}

void StringConstExpression() #ConstExpression :
{ Token t, t1; }
{
	t=<STRING_LITERAL>
	(
		LOOKAHEAD({
			getToken(1).kind==PLUS
		 && getToken(2).kind==STRING_LITERAL
		})
		"+" t1=<STRING_LITERAL>
		{
			t.image = t.image.substring(0,t.image.length()-1)+t1.image.substring(1);
			t.endLine = t1.endLine;
			t.endColumn = t1.endColumn;
		}
	)*
	{ jjtThis.set(t); }
}

void NewExpression() :
{
	Token t;
	boolean old_mode;
	Struct clazz;
}
{
	t="new" { jjtThis.setPos(t.getPos()); }
    jjtThis.type = NonArrayType() "("
	[	ExpressionNT(null)
		(	"," ExpressionNT(null)	)*
	]
	")"
	[
		LOOKAHEAD("{")
		{
			old_mode = interface_only;
			interface_only = false;
			jjtThis.clazz = clazz = mkStruct(null, 0, new ASTModifiers(), jjtThis);
			PassInfo.push(clazz);
		}
		try {
			TypeBodyDeclaration(clazz)
		} finally {
			{ interface_only = old_mode; PassInfo.pop(clazz); }
		}
	]
}

void NewArrayExpression() :
{ Token t; int dim=0; }
{
	t="new" jjtThis.type = SimpleType()
	( LOOKAHEAD(2) "[" ExpressionNT(null) "]" { dim += 1; } )+
	( LOOKAHEAD(2) "[" "]" { dim += 1; } )*
        { jjtThis.dim = dim; jjtThis.setPos(t.getPos()); }
}

void NewInitializedArrayExpression() :
{ Token t; int dim=0; }
{
	t="new" jjtThis.type = SimpleType()
	( "[" "]" { dim += 1; } )+
	"{"
	[
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"
        { jjtThis.dim = dim; jjtThis.setPos(t.getPos()); }
}


/*
 * Statement syntax follows.
 */

void Statement() #void :
{}
{
	try {
	(
	  LOOKAHEAD({labledStatementLA()})
	  LabeledStatement()
	| Block()
	| EmptyStatement()
	| SwitchStatement()
	| IfStatement()
	| WhileStatement()
	| DoStatement()
	| ForStatement()
	| ForEachStatement()
	| BreakStatement()
	| ContinueStatement()
	| ReturnStatement()
	| ThrowStatement()
	| SynchronizedStatement()
	| WithStatement()
	| TryStatement()
	| GotoStatement()
	| ReparseStatement()
	| StatementExpression()
	)
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseStatement() :
{ Token t; }
{
	try {
		t=<REPARSE_STATEMENT> { jjtThis.set(t); }
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void LabeledStatement() :
{}
{
	LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(2).kind == COLON } )
	Identifier() ":" Statement()
}


ASTBlock PrescannedBlock(PrescannedBody b) #void :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=Block()
	{ return bl; }
}

ASTBlock Block() :
{ boolean old_declMode; }
{
	"{"
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	( BlockStatement(jjtThis) )*
	} finally { declMode = old_declMode; PassInfo.pop(jjtThis); }
    "}"
	{ return jjtThis; }
}

ASTBlock PrescannedRuleBlock(PrescannedBody b) #void :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=RuleBlock()
	{ return bl; }
}

ASTBlock RuleBlock() :
{ boolean old_declMode; }
{
	"{"
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		RuleOrExpression()
	}
	catch(ParseError e) { rpe("Bad rule",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		declMode = old_declMode;
		PassInfo.pop(jjtThis);
	}
	"}"
	{ return jjtThis; }
}

ASTBlock CondBlock() #Block :
{}
{
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
	}
	try {
	(
		"{" ( CondStatement() )+ "}"
	|	CondStatement()
	)
	} finally { {PassInfo.pop(jjtThis); } }
	{ jjtree.popNode(); return jjtThis; }
}

void BlockStatement(ASTNode parent) #void :
{ boolean old_declMode; ASTModifiers modifiers; Struct clazz; }
{
	(
		LOOKAHEAD( Modifiers() ("class" | "interface" | "@" "interface") )
		{ old_declMode = declMode; declMode = true; }
		try {
			modifiers = Modifiers()
			clazz = TypeDeclaration(modifiers, parent)
			[ ";" ]
			{ jjtree.pushNode(clazz); }
		} finally {
			declMode = old_declMode;
		}
	|	LOOKAHEAD( Modifiers() Type() Identifier() )
		modifiers = Modifiers()
		VarDecls(modifiers) //#DeclStatement
	|	LOOKAHEAD(0)
		Statement()
	)
}

void CondStatement() :
{ Token t = getToken(1); }
{
	ExpressionNT(noColonTokenSet)
	[
		":"
		{ t = null; }
		Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ASTConstExpression e = new ASTConstExpression();
			e.pos = pos;
			e.val = KString.from(sb.toString());
			jjtThis.jjtAddChild(e,1);
		}
	}
	";"
}

void EmptyStatement() :
{ Token t; }
{
	t=";" { jjtThis.setPos(t.getPos()); }
}

void StatementExpression() :
{}
{
	ExpressionNT(null) ";"
}

void SwitchStatement() :
{ Token t; }
{
	t="switch" { jjtThis.setPos(t.getPos()); }
	"(" ExpressionNT(null) ")"
	"{"
	(	CaseStatements()	)+
	"}"
}

void CaseStatements() #void :
{}
{
	(
		LOOKAHEAD("case" QName() "(" )
		PizzaCase()
	|
		NormalCase()
	)
}

void NormalCase() :
{ Token t; }
{
	(
		t="case" ExpressionNT(noColonTokenSet) ":"
	|	t="default" ":"
	)
    { jjtThis.setPos(t.getPos()); }
	(
		BlockStatement(jjtThis)
	)*
}

void PizzaCase() :
{ Token t; ASTModifiers modifiers; }
{
	t="case" { jjtThis.setPos(t.getPos()); }
    QName()
	"("
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
	")" ":"
	(
		BlockStatement(jjtThis)
	)*
}

void IfStatement() :
{ Token t; }
{
	t="if" { jjtThis.setPos(t.getPos()); }
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")"
	Statement()
	[	LOOKAHEAD(1)
		"else"
		Statement()
	]
}

void WhileStatement() :
{ Token t; }
{
	t="while" { jjtThis.setPos(t.getPos()); }
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")"
    Statement()
}

void DoStatement() :
{ Token t; }
{
	t="do" { jjtThis.setPos(t.getPos()); }
    Statement()
    "while"
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")" ";"
}

void ForStatement() :
{ Token t; }
{
	t="for" { jjtThis.setPos(t.getPos()); }
	"("
		ForInit() { jjtThis.init = jjtree.popNode(); }
	/*";"*/
	[
		ExpressionNT(null) { jjtThis.cond = (Expr)jjtree.popNode(); }
	]
	";"
	[
		CommaExpression() { jjtThis.iter = (Expr)jjtree.popNode(); }
	]
	")"
	Statement()
}

void ForEachStatement() :
{ Token t; ASTModifiers modifiers; }
{
	t="foreach" { jjtThis.setPos(t.getPos()); }
	"("
	[	LOOKAHEAD( Modifiers() FormalParameter() )
		modifiers = Modifiers()
		FormalParameter(modifiers)
		";"
	]
	ExpressionNT(null)
	[
	";"
	[ ExpressionNT(null) ]
	]
	")"
	Statement()
}

void ForInit() #void:
{ ASTModifiers modifiers; }
{
	(
	LOOKAHEAD( Modifiers() Type() QName() ("[" "]")* ("=" | ":=" | "," | ";") )
	modifiers = Modifiers()
	VarDecls(modifiers)
|	CommaExpression() ";"
|	EmptyStatement()
 	)
}

void GotoStatement() :
{ Token t; }
{
	t="goto" { jjtThis.setPos(t.getPos()); }
	(
		"case" ExpressionNT(null) { jjtThis.casemode = true; }
	|
		"default" { jjtThis.casemode = true; }
	|
    	Identifier()
    )
    ";"
}

void BreakStatement() :
{ Token t; }
{
	t="break" { jjtThis.setPos(t.getPos()); }
    [ Identifier() ] ";"
}

void ContinueStatement() :
{ Token t; }
{
	t="continue" { jjtThis.setPos(t.getPos()); }
    [ Identifier() ] ";"
}

void ReturnStatement() :
{ Token t; }
{
	t="return" { jjtThis.setPos(t.getPos()); }
    [ ExpressionNT(null) ] ";"
}

void ThrowStatement() :
{ Token t; }
{
	t="throw" { jjtThis.setPos(t.getPos()); }
    ExpressionNT(null) ";"
}

void SynchronizedStatement() :
{ Token t; }
{
	t="synchronized" { jjtThis.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()
}

void WithStatement() :
{ Token t; }
{
	t="with" { jjtThis.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()
}

void TryStatement() :
{ Token t; ASTModifiers modifiers; }
{
	t="try" { jjtThis.setPos(t.getPos()); }
    Block()
	(
		t="catch"
		"("
		modifiers = Modifiers()
		FormalParameter(modifiers)
		")"
		Block()
		{ jjtThis.setPos(t.getPos()); }
        #CatchInfo(2)
	)*
	[	t="finally" Block()
		{ jjtThis.setPos(t.getPos()); }
		#FinallyInfo(1)
	]
}

