/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = true;
  MULTI = true;
  NODE_PACKAGE = "kiev.parser";
  BUILD_NODE_FILES = false;
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev020)

package kiev.parser;

import kiev.Kiev;
import kiev.Kiev.Ext;
import kiev.vlang.*;

import /*{ syntax }*/ kiev.parser.TypeAliases;

public class kiev020 {

	public static boolean	interface_only = false;
	public static boolean	reparse_body = false;
	public static int		reparse_pos = 0;
	public static PreScanneable		presc = null;

	public static boolean	declMode = true;

	static JJTkiev020State getJJTree() { return jjtree; }

    /** Report Parser Error (Exception) */
	public static void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	public static void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	public void reset() {
		jjtree.reset();
	}

	private static boolean checkNoSpace(Token t1, Token t2) {
		return t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn;
	}

	public static final int[] noColonTokenSet = new int[]{COLON};

	public static int[] no_tokens;

	private static boolean notAToken(Token t) {
		if( no_tokens == null ) return true;
		for(int i=0; i < no_tokens.length; i++) {
			if( t.kind == no_tokens[i] ) return false;
		}
		return true;
	}

	private static boolean labledStatementLA() {
		for(int idx=1; ;idx+=2) {
			if (getToken(idx).kind != IDENTIFIER || getToken(idx+1).kind != COLON)
				return false;
			switch(getToken(idx+2).kind) {
			case LBRACE:
			case SEMICOLON:
			case SWITCH:
			case IF:
			case WHILE:
			case DO:
			case FOR:
			case FOREACH:
			case BREAK:
			case CONTINUE:
			case RETURN:
			case THROW:
			case SYNCHRONIZED:
			case WITH:
			case TRY:
			case GOTO:
			case REPARSE_STATEMENT:
				return true;
			}
		}
	}

	private static boolean operatorLA(int tk) {
		switch( getToken(tk).kind ) {
		case ASSIGN:
		case ASSIGN2:
		case LT:
		case GT:
		case COLON:
		case QUESTION:
		case ARROW:
		case BANG:
		case TILDE:
		case EQ:
		case LE:
		case GE:
		case NE:
		case SC_OR:
		case SC_AND:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
		case STAR:
		case SLASH:
		case BIT_AND:
		case BIT_OR:
		case XOR:
		case REM:
		case LSHIFT:
		case PLUSASSIGN:
		case MINUSASSIGN:
		case STARASSIGN:
		case SLASHASSIGN:
		case ANDASSIGN:
		case ORASSIGN:
		case XORASSIGN:
		case REMASSIGN:
		case LSHIFTASSIGN:
		case RSIGNEDSHIFTASSIGN:
		case RUNSIGNEDSHIFTASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR:
			return notAToken(getToken(tk));
		case OPERATOR_ID:
			return true;
		}
		return false;
	}

	private static boolean castLA_Start() {
		int i = 1;
		Token t = getToken(i);
		if (t.kind == IDENTIFIER) {
			String qname = t.image;
			while( getToken(i+1).kind == DOT && getToken(i+2).kind == IDENTIFIER) {
				i += 2;
				qname = qname + "." + getToken(i).image;
			}
			switch (getToken(i+1).kind) {
			case RPAREN:
			case LT:
			case LBRACKET:
				break;
			default:
				return false;
			}
			try {
				if( PassInfo.checkClassName(KString.from(qname)) ) {
					return true;
				}
			} catch( Exception e ) {}
		}
		return false;
	}

	private static boolean castLA() {
		if( getToken(1).kind != LPAREN ) return false;
		if( getToken(2).kind == CAST ) return true;
		if( getToken(2).kind == REINTERP ) return true;
		return castLA(1,LPAREN,RPAREN);
	}

	private static boolean castLA(int offs, int exp_kind1, int exp_kind2) {
		if( getToken(offs).kind != exp_kind1 ) return false;
		switch( getToken(offs+1).kind ) {
		case BOOLEAN: case CHAR: case BYTE:
		case SHORT: case INT: case LONG: case FLOAT:
		case DOUBLE: case VOID:
			return true;
		case IDENTIFIER:
			break;
		case LPAREN:
			// Skip until matched ')' and check for "->"
			{
				int i = offs+2;
				int depth = 1;
				while( depth != 0 ) {
					switch(getToken(i++).kind) {
					case LPAREN: depth++; break;
					case RPAREN: depth--; break;
					}
				}
				if( getToken(i).kind==ARROW ) {
					return true;
				} else {
					return false;
				}
			}
		default:
			// TODO closure type
			return false;
		}
		// Qualified name resolving to be a class name
		String qname = getToken(offs+1).image;
	scan_qname:
		for(int i=offs+2; ; i+=2) {
			if( getToken(i).kind == DOT && getToken(i+1).kind == IDENTIFIER )
				qname = qname+"."+getToken(i+1).image;
			else {
				switch( getToken(i).kind ) {
				case RPAREN:
					if( exp_kind2 == RPAREN )  break scan_qname;
					else return false;
				case GT:
					if( exp_kind2 == GT ) break scan_qname;
					else return false;
				case LT:
					if( castLA(i,LT,GT) ) break scan_qname;
					else return false;
				case LBRACKET:
					if( getToken(i+1).kind == RBRACKET ) {
						return true;
					}
					else return false;
				case COMMA:
					if( exp_kind1 == LT ) break scan_qname;
					else return false;
				default:
					return false;
				}
			}
		}
		try {
			if( PassInfo.checkClassName(KString.from(qname)) ) {
				return true;
			}
		} catch( Exception e ) {}
		return false;
	}

}

PARSER_END(kiev020)


TOKEN_MGR_DECLS :
{
  static int skip_depth = 0;
}

<DEFAULT,IN_CONSTRAINT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT,IN_CONSTRAINT>
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  <"/**" ([" ","\t","\n","\r"])* "require" [" ","\t","\n","\r"]> { input_stream.backup(8); } : IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "ensure" [" ","\t","\n","\r"]> { input_stream.backup(7); }: IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "invariant" [" ","\t","\n","\r"]> { input_stream.backup(10); } : IN_CONSTRAINT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<IN_CONSTRAINT>
TOKEN :
{
  < END_CONSTRAINT: "**/" > : DEFAULT
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
//| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
// | < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" > { if(Kiev.javaMode||Kiev.disabled(Ext.With)) matchedToken.kind=IDENTIFIER; }
// | < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < UNDERSCORE: "_" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ARROW: "->" >
| < FUNCTION: "fun" >
| < VIRTUAL: "virtual" > { if(Kiev.javaMode || Kiev.disabled(Ext.VirtualFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < VARARGS: "..." >
| < FORWARD: "forward" > { if(Kiev.javaMode || Kiev.disabled(Ext.Forward) /*|| !kiev020.declMode*/) matchedToken.kind=IDENTIFIER; }
| < RULE: "rule" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < PCUT: "$cut" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < CAST: "$cast" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < REINTERP: "$reinterp" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ALIAS: "alias" > { if(Kiev.javaMode || Kiev.disabled(Ext.Alias)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < OPERATOR_ID: "operator" > { if(Kiev.javaMode || Kiev.disabled(Ext.Operator) ) matchedToken.kind=IDENTIFIER; }
| < TYPEDEF: "typedef" > { if(Kiev.javaMode || Kiev.disabled(Ext.Typedef)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENUM: "enum" > { if(Kiev.javaMode || Kiev.disabled(Ext.Enum) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < REQUIRE: "require" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENSURE: "ensure" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < INVARIANT: "invariant" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < GENERATE: "$generate" > { if(Kiev.javaMode || Kiev.disabled(Ext.Templates) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < PACKED: "packed" > { if(Kiev.javaMode || Kiev.disabled(Ext.PackedFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < WRAPPER: "$wrapper" > { if(Kiev.javaMode || Kiev.disabled(Ext.Wrappers) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< ACCESS: "access:" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY: "ro" | "r" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < WRITE_ONLY: "wo" | "w"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < READ_WRITE: "rw" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < NO_READ_WRITE: "n" | "no" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < COMMA1: "," >
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < REPARSE_EXPRESSION:
      "#" ["E","e"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
|
  < REPARSE_STATEMENT:
      "#" ["S","s"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "ID#" <ID_STRING_LITERAL> ) >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON: ":" >
| < QUESTION: "?" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >
//| < GT: ">" >
//| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
//| < HOOK: "?" >
//| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//| < RSIGNEDSHIFT: ">>" >
//| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP:	"#" >
| < OPERATOR:	    ["\u2200"-"\u22F1"] >

}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTFileUnit FileUnit(String filename) :
{}
{
	{
		Kiev.curFileUnit = jjtThis;
		jjtThis.filename = KString.from(filename);
		jjtThis.setPos(0);
		declMode = true;
		ASTModifiers modifiers;
	}
	[	Package()	]
	(
		Import()
	|	Typedef()
	|	Opdef()
	|	Pragma()
	)*
	(
		modifiers = Modifiers()
		try {
			TypeDeclaration(modifiers) [ ";" ]
	|		EnumDeclaration(modifiers) [ ";" ]
	|		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			SyntaxDeclaration(modifiers) [ ";" ]
		}
		catch(ParseError e) { rpe("Bad class declaration",e); }
		catch(Throwable e) { rperr(e); }
	)*
	<EOF>
	{
		declMode = true;
		return jjtThis;
	}
}

ASTModifiers Modifiers() :
{}
{
	(	LOOKAHEAD(2)
		try {
			(
				Modifier()
			|	Pack()
			|	Access()
			|	Annotation()
			)
		}
		catch(ParseError e) { rpe("Bad modifiers",e); }
		catch(Throwable e) { rperr(e); }
	)*
	{ jjtree.popNode(); return jjtThis; }
}

void Package() :
{}
{
	try {
		"package" QName() ";"
	}
	catch(ParseError e) { rpe("Bad package declaration",e); }
	catch(Throwable e) { rperr(e); }
}

void Pragma() :
{}
{
	"pragma"
	(
		<PRAGMA_ENABLE>		{ jjtThis.enable = true; }
	|	<PRAGMA_DISABLE>	{ jjtThis.enable = false; }
	)
	( StringConstExpression() )+
	";"
}

void Import() :
{}
{
	try {
		"import"
		(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			<IDENTIFIER>{ jjtThis.mode = Import.ImportMode.IMPORT_SYNTAX; }
			[ QName() ]
		|	"package"	{ jjtThis.mode = Import.ImportMode.IMPORT_PACKAGE; }
			[ QName() ]
		|	"static"	{ jjtThis.mode = Import.ImportMode.IMPORT_STATIC; }
			QName()
			[	"." "*" { jjtThis.star = true; }
			|	"("		{ jjtThis.of_method = true; }
				Type() ("," Type())*
				")"
			]
		|	QName()
			[	"." "*" { jjtThis.star = true; }
			|	"("		{ jjtThis.of_method = true; }
				Type() ("," Type())*
				")"
			]
		)
		";"
	}
	catch(ParseError e) { rpe("Bad import declaration",e); }
	catch(Throwable e) { rperr(e); }
}

void Typedef() :
{}
{
	try {
		"typedef"
		(
			LOOKAHEAD(3, <IDENTIFIER> TypeOperatorChar() <IDENTIFIER>, {checkNoSpace(getToken(1),getToken(2))})
			Identifier() Operator() Type()
		|	Type() Identifier()
		) ";"
	}
	catch(ParseError e) { rpe("Bad typedef declaration",e); }
	catch(Throwable e) { rperr(e); }
}

void Opdef() :
{}
{
	"operator"
	(
		Operator()
	|	Identifier()
	)
	","
	Identifier()	// FX,FY,XF,YF,XFX,YFX,XFY,YFY
	","
	DecimalConstExpression()
	";"
}

void SyntaxDeclaration(ASTModifiers modifiers) :
{ Token t=null; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>	// "syntax"
	Identifier()
	"{"
	(
		Typedef()
	|	Opdef()
	)*
	"}"
}

void TypeDeclaration(ASTModifiers modifiers) :
{ Token t=null; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	try {
		(
			t="class"
			Identifier()
		|	t="interface"
			Identifier()
		|	t="@" "interface"
			(Identifier() | KeywordAsIdentifier())
		)
		{ jjtThis.set(t); t = null; }
	}
	catch(ParseError e) { rpe("Class's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[	Extends()			]
	[	Implements()		]
	[	Generate()			]
	TypeBodyDeclaration()
}

void TypeBodyDeclaration() #void :
{ ASTModifiers modifiers; }
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		(
			modifiers = Modifiers()
			(
				Initializer(modifiers)
			|	InvariantDeclaration(modifiers) [ ";" ]
			|	TypeDeclaration(modifiers) [ ";" ]
			|	EnumDeclaration(modifiers) [ ";" ]
			|	CaseTypeDeclaration(modifiers)
			|
				LOOKAHEAD( "rule" <IDENTIFIER> "(" )
				RuleDeclaration(modifiers)
			|
				LOOKAHEAD( [ClazzArguments()] [ Type() ] [ <IDENTIFIER> ] "(" )
				MethodDeclaration(modifiers)
			|
				LOOKAHEAD( Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
				FieldDecl(modifiers)
			)
		)*
	}
	catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void EnumDeclaration(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	"enum"
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("enum's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	Extends()			]
	EnumBodyDeclaration()
}

void EnumBodyDeclaration() #void :
{ ASTModifiers modifiers; }
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		modifiers = Modifiers()
		EnumFieldDeclaration(modifiers)
		(	","
			modifiers = Modifiers()
			EnumFieldDeclaration(modifiers)
		)*
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }
	[
		";"
		try {
			(
				modifiers = Modifiers()
				(
					Initializer(modifiers)
				|	InvariantDeclaration(modifiers) [ ";" ]
				|	TypeDeclaration(modifiers) [ ";" ]
				|	EnumDeclaration(modifiers) [ ";" ]
				|
					LOOKAHEAD( "rule" <IDENTIFIER> "(" )
					RuleDeclaration(modifiers)
				|
					LOOKAHEAD( [ClazzArguments()] [ Type() ] [ <IDENTIFIER> ] "(" )
					MethodDeclaration(modifiers)
				|
					LOOKAHEAD( Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
					FieldDecl(modifiers)
				)
			)*
		}
		catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
		catch(Throwable e) { rperr(e); }
	]
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void EnumFieldDeclaration(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	try {
		Identifier() ["=" DecimalConstExpression()] [":"  StringConstExpression()]
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }
}

void CaseTypeDeclaration(ASTModifiers modifiers) :
{ Token t=null; ASTBlock bl; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	t="case"
	{ jjtThis.set(t); }
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("Class's case name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[
		"("
			try {
			[
				modifiers = Modifiers()
				FormalParameter(modifiers)
				(
					","
					modifiers = Modifiers()
					FormalParameter(modifiers)
				)*
			]
			}
			catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
			catch(Throwable e) { rperr(e); }
		")"
	]
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Class's case constructor body expected",e); }
	catch(Throwable e) { rperr(e); }
}


void ClazzArguments() #void :
{}
{
	"<"
		try {
			ArgumentDeclaration()
			(	","
				ArgumentDeclaration()
			)*
		}
		catch(ParseError e) { rpe("Class's argument expected",e); }
		catch(Throwable e) { rperr(e); }
	">"
}

void Extends() :
{ Token t; }
{
	t="extends" { jjtThis.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Super class name expected",e); }
	catch(Throwable e) { rperr(e); }
}

void Implements() :
{ Token t; }
{
	t="implements" { jjtThis.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Interface name expected",e); }
	catch(Throwable e) { rperr(e); }
}

void Generate() :
{ Token t; int i=0; }
{
	"$generate"
	try {
		"<"
			(PrimitiveType() | Identifier()) { i++; }
			( "," (PrimitiveType() | Identifier()) { i++; } )*
		">"
//		{
//		if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//			throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//		}
		(
			"," { i = 0; }
			"<"
				(PrimitiveType() | Identifier()) { i++; }
				( "," (PrimitiveType() | Identifier()) { i++; } )*
			">"
//			{
//			if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//				throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//			}
		)*
	}
	catch(ParseError e) { rpe("Bad $generate directive",e); }
	catch(Throwable e) { rperr(e); }
}

void ArgumentDeclaration() :
{}
{
	Identifier()
	[
		"extends" NonArrayType()
	|	"implements" NonArrayType()
	]
}

void Modifier() :
{ Token t=null; }
{
	(
	  t="public"
	| t="protected"
	| t="private"
	| t="static"
	| t="abstract"
	| t="final"
	| t="native"
	| t="synchronized"
	| t="transient"
	| t="volatile"
	| t="virtual"
	| t="forward"

	| t="$wrapper"

	)
	{ jjtThis.set(t); }
}

void Pack() :
{ Token t; int size=-1; int offset=-1; String packer=null; }
{
	"packed"
	[
		":"
		t=<INTEGER_LITERAL> { size = Integer.parseInt(t.image); t = null; }
		[
		","
		t=<IDENTIFIER> { packer = t.image; t = null; }
		","
		t=<INTEGER_LITERAL> { offset = Integer.parseInt(t.image); t = null; }
		]
	]
	{ jjtThis.set(size,packer,offset); }
}

void Access() :
{ int acc; }
{
	LOOKAHEAD({Kiev.enabled(Ext.Access)})
	"access:"
	acc = AccessSpec() { jjtThis.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtThis.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtThis.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtThis.set(acc); }
	]]]
}

int AccessSpec() #void :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

void KeywordAsIdentifier() #void :
{ Token t; ASTIdentifier id; }
{
	(
		t="virtual"
	|	t="alias"
	)
	{
		id = new ASTIdentifier(0);
		jjtree.openNodeScope(id);
		id.set(t);
		jjtree.closeNodeScope(id, true);
		t = null;
	}
}

void Annotation() :
{}
{
	"@"
	(
		Identifier()
	|	KeywordAsIdentifier()
	)
	[
		"("
		[	LOOKAHEAD( <IDENTIFIER> "=" )
			AnnotationValues()
		|	AnnotationValueAny() #AnnotationValue(1)
		]
		")"
	]
}

void AnnotationValues() #void :
{}
{
	Identifier()
	"="
	AnnotationValueAny() #AnnotationValue(2)
	(
		","
		Identifier()
		"="
		AnnotationValueAny() #AnnotationValue(2)
	)*
}

void AnnotationValueAny() #void :
{}
{
		LOOKAHEAD( "@" <IDENTIFIER> )
		Annotation()
	|	AnnotationValueValueArrayInitializer()
	|	ExpressionNT(null)
}

void AnnotationValueScalar() #void :
{}
{
		LOOKAHEAD( "@" <IDENTIFIER> )
		Annotation()
	|	ExpressionNT(null)
}

void AnnotationValueValueArrayInitializer() :
{}
{
	"{"
	[
		AnnotationValueScalar()
		(	","
			AnnotationValueScalar()
		)*
	]
	"}"
}


void FieldDecl(ASTModifiers modifiers) :
{ boolean old_declMode; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	try {
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	{ old_declMode = declMode; declMode = false; }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Field declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	finally { declMode = old_declMode; }
	";"
}

void VarDecls(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers,-1); }
	try {
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Variable declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	";"
}

void VarDecl() :
{}
{
	Identifier()
	( "[" "]" { jjtThis.dim += 1; } )*
	[ ("=" | ":=" { jjtThis.of_wrapper=true; }) VariableInitializer() ]
}

void VariableInitializer() #void :
{}
{
	(
		ArrayInitializer()
	|
		Expression()
	)
}

void ArrayInitializer() #NewInitializedArrayExpression :
{ Token t; }
{
	t="{"
	[	LOOKAHEAD(2)
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ jjtThis.setPos(t.getPos()); }
}

ASTFormalParameter FormalParameter(ASTModifiers modifiers) :
{ Token t; ASTType tp; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	(
		tp = Type()
		Identifier()
		( t="[" "]" { tp.addOperation(t); } )*
	|
		t="_" { jjtThis.set(t); }
	)
	{ return jjtThis; }
}

ASTFormalParameter mmFormalParameter(ASTModifiers modifiers) #FormalParameter :
{ Token t; ASTType tp; ASTType mmtp = null; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	(
		tp = Type()
		(
			LOOKAHEAD({ !Kiev.javaMode && (getToken(1).image.equals(":")) })
			(":") mmtp = Type()
		)?
		Identifier()
		( t="[" "]" { tp.addOperation(t); if (mmtp != null) mmtp.addOperation(t); } )*
	|
		t="_" { jjtThis.set(t); }
	)
	{ return jjtThis; }
}

void Throws() :
{ Token t; }
{
	t="throws" { jjtThis.setPos(t.getPos()); }
	try {
		NonArrayType()
		(	"," NonArrayType()	)*
	}
	catch(ParseError e) { rpe("Throwable class name expected",e); }
	catch(Throwable e) { rperr(e); }
}


void Alias() #void :
{ Token t; }
{
	"alias"
	try {
		(
			LOOKAHEAD(2)
			OperatorAlias()
		|	IdentifierAlias()
		)
	}
	catch(ParseError e) { rpe("Alias expected",e); }
	catch(Throwable e) { rperr(e); }
}

void IdentifierAlias() :
{}
{
	Identifier()
}

void OperatorAlias() :
{ Token t = null; }
{
	(	// temporary, for backward compatibility
		"operator"
		"("
		DecimalConstExpression()	","
		Identifier()		","
		(
			Operator()
		|	Identifier()
		|	"[" "]"	{ jjtThis.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"	{ jjtThis.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"	{ jjtThis.image = kiev.vlang.Constants.nameCastOp; }
		)
		")"
	|
		t=<IDENTIFIER> { jjtThis.set(t); }
		"operator"
		(
			Operator()
		|	Identifier()
		|	"[" "]"	{ jjtThis.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"	{ jjtThis.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"	{ jjtThis.image = kiev.vlang.Constants.nameCastOp; }
		)
	)
}

void MaybeSkipBlock() #void :
{ boolean old_declMode; }
{
	(
		LOOKAHEAD({ interface_only })
//		{ old_declMode = declMode; declMode = false; }
//		try {
			"{"
			{
			Token tk = getToken(0);
			PrescannedBody pbody = new PrescannedBody(tk.beginLine,tk.beginColumn);
			Kiev.curFileUnit.addPrescannedBody(pbody);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
			presc.pbody = pbody;
			if( presc instanceof ASTCondDeclaration )
				pbody.mode = PrescannedBody.CondBlockMode;
			else if( presc instanceof ASTRuleDeclaration )
				pbody.mode = PrescannedBody.RuleBlockMode;
			else
				pbody.mode = PrescannedBody.BlockMode;
			}
//		} finally { declMode = old_declMode; }
	|	LOOKAHEAD({ presc instanceof ASTCondDeclaration })
		CondBlock()
	|	LOOKAHEAD({ presc instanceof ASTRuleDeclaration })
		RuleBlock()
	|	Block()
	)
}

void MethodDeclaration(ASTModifiers modifiers) :
{ Token t; ASTType tp=null; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	[	ClazzArguments()	]
	[
		LOOKAHEAD( Type() <IDENTIFIER> )
		tp = Type()
	]
	Identifier()
	"("
		try {
		[
			modifiers = Modifiers()
			mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ jjtThis.setVarArgs(true); }
			]
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		t="[" "]"
		{
			if (tp != null)
				tp.addOperation(t);
			else
				Kiev.reportParserError(t.getPos(), "Array return in constructor?");
		}
	)*
	(
		Alias()
	)*
	[	Throws()	]
	try {
		(
			RequareDeclaration()
		|	EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	[ "default" AnnotationValueAny() #AnnotationValue(1) ] ";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }
}

void RequareDeclaration() :
{}
{
	"require"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		)
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'require' declaration",e); }
	catch(Throwable e) { rperr(e); }
}


void EnsureDeclaration() :
{}
{
	"ensure"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		)
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'ensure' declaration",e); }
	catch(Throwable e) { rperr(e); }
}

void InvariantDeclaration(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	"invariant"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		)
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'invariant' declaration",e); }
	catch(Throwable e) { rperr(e); }
}

void RuleDeclaration(ASTModifiers modifiers) :
{ ASTBlock bl; }
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	"rule"
	Identifier()
	"("
		try {
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		Alias()
	)*
	(
		modifiers = Modifiers()
		VarDecls(modifiers)
	)*
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtThis; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }
}

void Initializer(ASTModifiers modifiers) :
{}
{
	{ jjtThis.jjtAddChild(modifiers, -1); }
	try {
		{ presc = jjtThis; }
		MaybeSkipBlock() [ ";" ]
	}
	catch(ParseError e) { rpe("Initializer's body expected",e); }
	catch(Throwable e) { rperr(e); }
}



/*
 * Type, name and expression syntax follows.
 */

ASTType Type() #void :
{ ASTType res; Token t; }
{
	(
		res = NonArrayType()
		(
			LOOKAHEAD(2,"[" "]")
			t="[" "]"
			{ res.addOperation(t); }
		|	LOOKAHEAD(1,TypeOperatorChar(),{Kiev.enabled(Ext.Typedef)&&checkNoSpace(getToken(0),getToken(1))})
			t=TypeOperatorChar()
			{ res.addOperation(t); }
		)*
	|
		LOOKAHEAD({Kiev.enabled(Ext.With)})
		res = ClosureType()
	)
	{ return res; }
}

ASTType ClosureType() :
{ Token t; }
{
	t="(" { jjtThis.setPos(t.getPos()); }
	[
		Type()
		( "," Type() )*
	]
	")" "->" Type()
	{ return jjtThis; }
}


ASTType NonArrayType() :
{ Token t; }
{
	try {
	(
		PrimitiveType()
	|	QName()
		[	LOOKAHEAD(1, "<", {Kiev.enabled(Ext.Generics)})
			"<"
				Type()
				( "," Type() )*
			">"
		]
	)
	(
		LOOKAHEAD(1,TypeOperatorChar(),{Kiev.enabled(Ext.Typedef)&&checkNoSpace(getToken(0),getToken(1))})
		t=TypeOperatorChar()
		{ jjtThis.addOperation(t); }
	)*
	}
	catch(ParseError e) { rpe("Bad type specification",e); }
	catch(Throwable e) { rperr(e); }
	{ return jjtThis; }
}

void PrimitiveType() :
{ Token t; }
{
	 (
	  t="boolean"
	| t="char"
	| t="byte"
	| t="short"
	| t="int"
	| t="long"
	| t="float"
	| t="double"
	| t="void"
	| t="rule"
	  )
	{ jjtThis.set(t); }
}

void Identifier() :
{ Token t; }
{
	t=<IDENTIFIER>
	{ jjtThis.set(t); }
}

void QName() :
{}
{
	try {
		Identifier()
		( LOOKAHEAD(2) "." Identifier() )*
	}
	catch(ParseError e) { rpe("Qualified name expected",e); }
	catch(Throwable e) { rperr(e); }
}

/*
 * Expression syntax follows.
 */

void CommaExpression() #CommaExpression(>1) :
{}
{
	Expression()
	( "," Expression() )*
}

void RuleOrExpression() #RuleOrExpression(>1) :
{}
{
	RuleAndExpression()
	( ";" RuleAndExpression() )*
}

void RuleAndExpression() #RuleAndExpression(>1) :
{}
{
	RuleExpression()
	( "," RuleExpression() )*
}

void RuleExpression() #void :
{ Token t = null; int n; }
{
	(
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_THE
	})
	RuleIstheExpression()
|
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_ONE_OF
	})
	RuleIsoneofExpression()
|
	LOOKAHEAD({getToken(1).kind == PCUT})
	RuleCutExpression()
|
	LOOKAHEAD({getToken(1).kind == LBRACE})
	"{" RuleOrExpression() "}"
|
	LOOKAHEAD({getToken(1).kind == WHILE})
	"while" Expression() { jjtThis.while_mode=true; t=null; }
	#RuleExpression(1)
|
	LOOKAHEAD(0)
	ExpressionNT(noColonTokenSet) { n = 1; }
	[ ":" ExpressionNT(noColonTokenSet) {n = 2;} ]
	#RuleExpression(n)
	)
}

void RuleIstheExpression() :
{}
{
	Identifier() "?=" AccessExpression()
}

void RuleIsoneofExpression() :
{}
{
	Identifier() "@=" AccessExpression()
	(
		LOOKAHEAD({
			getToken(1).image.equals("&")
		 && getToken(2).kind == IDENTIFIER
		 && getToken(3).kind == IS_ONE_OF
		})
		"&" Identifier() "@=" AccessExpression()
	)*
}

void RuleCutExpression() :
{ Token t; }
{
	t="$cut" { jjtThis.setPos(t.getPos()); t = null; }
}

Token TypeOperatorChar() #void :
{ Token t; }
{
	(
		t=<QUESTION>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar() #void :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<ASSIGN2>
	|	t=<LT>
	|	t=<GT>
	|	t=<COLON>
	|	t=<QUESTION>
	|	t=<ARROW>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<EQ>
	|	t=<LE>
	|	t=<GE>
	|	t=<NE>
	|	t=<SC_OR>
	|	t=<SC_AND>
	|	t=<INCR>
	|	t=<DECR>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<LSHIFT>
	|	t=<PLUSASSIGN>
	|	t=<MINUSASSIGN>
	|	t=<STARASSIGN>
	|	t=<SLASHASSIGN>
	|	t=<ANDASSIGN>
	|	t=<ORASSIGN>
	|	t=<XORASSIGN>
	|	t=<REMASSIGN>
	|	t=<LSHIFTASSIGN>
	|	t=<RSIGNEDSHIFTASSIGN>
	|	t=<RUNSIGNEDSHIFTASSIGN>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

void Operator() :
{ Token t; String image; }
{
	(
		t=OperatorChar()
		{ image = t.image; }
		(
			LOOKAHEAD({ !Kiev.javaMode && operatorLA(1) && checkNoSpace(getToken(0),getToken(1)) })
			t=OperatorChar()
			{ image = image+t.image; }
		|
			LOOKAHEAD({ Kiev.javaMode && getToken(1).kind==GT && checkNoSpace(getToken(0),getToken(1)) })
			t=<GT>
			{ image = image+t.image; }
		)*
	|	LOOKAHEAD({ !Kiev.javaMode })
		"operator" t=<IDENTIFIER>
		{ image = t.image; }
	)
	{
		jjtThis.setPos(t.getPos());
		jjtThis.image = KString.from(image);
	}
}

void CastOperatorLA() #void :
{}
{
	"("
	(
		<CAST>
	|	<REINTERP>
	|	PrimitiveType()
	|	LOOKAHEAD(0,{ castLA_Start() }) Type() ")"
		(
			<IDENTIFIER>
		|	"("
		|	ConstExpression()
		|	"new"
		|	Operator()
		|	ReparseExpression()
		|	"fun"
		)
	)
}

void CastOperator() :
{ Token t; }
{
	t="(" { jjtThis.setPos(t.getPos()); } [ <CAST> | <REINTERP> {jjtThis.reinterp=true;} ] Type() ")"
}

void ExpressionNT(int[] nt_new) #void :
{ int[] nt_old = no_tokens; no_tokens = nt_new; }
{
	try {
		Expression()
	} finally { no_tokens = nt_old; }
}

void Expression() :
{}
{
	try {
		(
			LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("instanceof") })
			Identifier() Type()
		|	LOOKAHEAD({ operatorLA(1) })
			Operator()
//		|	LOOKAHEAD({ castLA() })
		|	LOOKAHEAD( CastOperatorLA() )
			CastOperator()
		|	LOOKAHEAD(2)
			AccessExpression()
		)+
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseExpression() :
{ Token t; }
{
	try {
		t=<REPARSE_EXPRESSION> { jjtThis.set(t); }
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }
}

void CallExpression() :
{}
{
		Identifier() "("
		[	ExpressionNT(null)
			(	"," ExpressionNT(null)	)*
		]
		")"
}

void AccessExpression() #void :
{ Token t; }
{
	(
		LOOKAHEAD( Type() "." "class" )
		Type() "." "class"			#TypeClassExpression(1)
	|
		LOOKAHEAD(2)
		ConstExpression()
	|
		LOOKAHEAD(2)
		CallExpression()
	|
		LOOKAHEAD(2)
		Identifier()
	|
		LOOKAHEAD("new" NonArrayType() ("[" "]")+ "{" )
		NewInitializedArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() "[" )
		NewArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() ( "(" ) )
		NewExpression()
	|
		ReparseExpression()
	|
		"(" ExpressionNT(null) ")"
	|   LOOKAHEAD("fun" "(")
		AnonymouseClosure()
	)
	(
		LOOKAHEAD(3)
		"." CallExpression()	#CallAccessExpression(2)
	|
		LOOKAHEAD(3)
		t="." Identifier()
        { jjtThis.setPos(t.getPos()); }	#AccessExpression(2)
	|	LOOKAHEAD(2)
		t="[" ExpressionNT(null) "]"
        { jjtThis.setPos(t.getPos()); }	#ArrayElementAccessExpression(2)
	|
		LOOKAHEAD("." "new" NonArrayType() ( "(" ) )
		"."
		NewExpression()			#NewAccessExpression(2)
	)*
}

void AnonymouseClosure() :
{ Token t; ASTModifiers modifiers; }
{
	t="fun" "("
	[
		modifiers = Modifiers()
		FormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			FormalParameter(modifiers)
		)*
	]
	")" "->"
    { jjtThis.setPos(t.getPos()); }
    (
		LOOKAHEAD( { getToken(1).kind == RULE } )
		Type() RuleBlock()
	|	Type() Block()
	)
}

void ConstExpression() #void :
{}
{
	(
		BooleanConstExpression()
	|	DecimalConstExpression()
	|	FloatConstExpression()
	|	CharConstExpression()
	|	NullConstExpression()
	|	StringConstExpression()
	)
}

void BooleanConstExpression() #ConstExpression :
{ Token t; }
{
	(
		t="true"
	|	t="false"
	)
	{ jjtThis.set(t); }
}

void DecimalConstExpression() #ConstExpression :
{ Token t; }
{
	(
	 	t=<INTEGER_LITERAL>
	|	t=<LONG_INTEGER_LITERAL>
	)
	{ jjtThis.set(t); }
}

void FloatConstExpression() #ConstExpression :
{ Token t; }
{
	(
		t=<FLOATING_POINT_LITERAL>
	|	t=<DOUBLE_POINT_LITERAL>
	)
	{ jjtThis.set(t); }
}

void CharConstExpression() #ConstExpression :
{ Token t; }
{
	t=<CHARACTER_LITERAL>
	{ jjtThis.set(t); }
}

void NullConstExpression() #ConstExpression :
{ Token t; }
{
	t="null"
	{ jjtThis.set(t); }
}

void StringConstExpression() #ConstExpression :
{ Token t, t1; }
{
	t=<STRING_LITERAL>
	(
		LOOKAHEAD({
			getToken(1).kind==PLUS
		 && getToken(2).kind==STRING_LITERAL
		})
		"+" t1=<STRING_LITERAL>
		{
			t.image = t.image.substring(0,t.image.length()-1)+t1.image.substring(1);
			t.endLine = t1.endLine;
			t.endColumn = t1.endColumn;
		}
	)*
	{ jjtThis.set(t); }
}

void NewExpression() :
{
	Token t;
	boolean old_mode;
}
{
	t="new" { jjtThis.setPos(t.getPos()); }
    NonArrayType() "("
	[	ExpressionNT(null)
		(	"," ExpressionNT(null)	)*
	]
	")"
	[
		LOOKAHEAD("{")
		{ old_mode = interface_only; interface_only = false; jjtThis.anonymouse = true; }
		try {
			TypeBodyDeclaration()
		} finally {
		{ interface_only = old_mode; }
		}
	]
}

void NewArrayExpression() :
{ Token t; int dim=0; }
{
	t="new" NonArrayType()
	( LOOKAHEAD(2) "[" ExpressionNT(null) "]" { dim += 1; } )+
	( LOOKAHEAD(2) "[" "]" { dim += 1; } )*
        { jjtThis.dim = dim; jjtThis.setPos(t.getPos()); }
}

void NewInitializedArrayExpression() :
{ Token t; int dim=0; }
{
	t="new" NonArrayType()
	( "[" "]" { dim += 1; } )+
	"{"
	[
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"
        { jjtThis.dim = dim; jjtThis.setPos(t.getPos()); }
}


/*
 * Statement syntax follows.
 */

void Statement() #void :
{}
{
	try {
	(
	  LOOKAHEAD({labledStatementLA()})
	  LabeledStatement()
	| Block()
	| EmptyStatement()
	| SwitchStatement()
	| IfStatement()
	| WhileStatement()
	| DoStatement()
	| ForStatement()
	| ForEachStatement()
	| BreakStatement()
	| ContinueStatement()
	| ReturnStatement()
	| ThrowStatement()
	| SynchronizedStatement()
	| WithStatement()
	| TryStatement()
	| GotoStatement()
	| ReparseStatement()
	| StatementExpression()
	)
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseStatement() :
{ Token t; }
{
	try {
		t=<REPARSE_STATEMENT> { jjtThis.set(t); }
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void LabeledStatement() :
{}
{
	LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(2).kind == COLON } )
	Identifier() ":" Statement()
}


ASTBlock PrescannedBlock(PrescannedBody b) #void :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=Block()
	{ return bl; }
}

ASTBlock Block() :
{ boolean old_declMode; }
{
	"{"
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	( BlockStatement() )*
	} finally { declMode = old_declMode; PassInfo.pop(jjtThis); }
    "}"
	{ return jjtThis; }
}

ASTBlock PrescannedRuleBlock(PrescannedBody b) #void :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=RuleBlock()
	{ return bl; }
}

ASTBlock RuleBlock() :
{ boolean old_declMode; }
{
	"{"
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		RuleOrExpression()
	}
	catch(ParseError e) { rpe("Bad rule",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		declMode = old_declMode;
		PassInfo.pop(jjtThis);
	}
	"}"
	{ return jjtThis; }
}

ASTBlock PrescannedCondBlock(PrescannedBody b) #void :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=CondBlock()
	{ return bl; }
}

ASTBlock CondBlock() :
{ boolean old_declMode;}
{
	{
		jjtThis.setPos(getToken(1).getPos());
		PassInfo.push(jjtThis);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		"{"
				( CondStatement() )+
		"}" [ <END_CONSTRAINT> ]
	|
		( CondStatement() )+
		<END_CONSTRAINT>
	} finally {
		declMode = old_declMode;
		PassInfo.pop(jjtThis);
	}
	{ return jjtThis; }
}

void BlockStatement() #void :
{ boolean old_declMode; ASTModifiers modifiers; }
{
	(
		LOOKAHEAD( Modifiers() ("class" | "interface" | "@" "interface") )
		{ old_declMode = declMode; declMode = true; }
		try {
			modifiers = Modifiers()
			TypeDeclaration(modifiers)
			[ ";" ]
		} finally {
			declMode = old_declMode;
		}
	|	LOOKAHEAD( Modifiers() Type() Identifier() )
		modifiers = Modifiers()
		VarDecls(modifiers) //#DeclStatement
	|	LOOKAHEAD(0)
		Statement()
	)
}

void CondStatement() :
{ Token t = getToken(1); }
{
	ExpressionNT(noColonTokenSet)
	[
		":"
		{ t = null; }
		Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ASTConstExpression e = new ASTConstExpression(0);
			e.pos = pos;
			e.val = KString.from(sb.toString());
			jjtThis.jjtAddChild(e,1);
		}
	}
	";"
}

void EmptyStatement() :
{ Token t; }
{
	t=";" { jjtThis.setPos(t.getPos()); }
}

void StatementExpression() :
{}
{
	ExpressionNT(null) ";"
}

void SwitchStatement() :
{ Token t; }
{
	t="switch" { jjtThis.setPos(t.getPos()); }
	"(" ExpressionNT(null) ")"
	"{"
	(	CaseStatements()	)+
	"}"
}

void CaseStatements() #void :
{}
{
	(
		LOOKAHEAD("case" QName() "(" )
		PizzaCase()
	|
		NormalCase()
	)
}

void NormalCase() :
{ Token t; }
{
	(
		t="case" ExpressionNT(noColonTokenSet) ":"
	|	t="default" ":"
	)
    { jjtThis.setPos(t.getPos()); }
	(
		BlockStatement()
	)*
}

void PizzaCase() :
{ Token t; ASTModifiers modifiers; }
{
	t="case" { jjtThis.setPos(t.getPos()); }
    QName()
	"("
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
	")" ":"
	(
		BlockStatement()
	)*
}

void IfStatement() :
{ Token t; }
{
	t="if" { jjtThis.setPos(t.getPos()); }
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")"
	Statement()
	[	LOOKAHEAD(1)
		"else"
		Statement()
	]
}

void WhileStatement() :
{ Token t; }
{
	t="while" { jjtThis.setPos(t.getPos()); }
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")"
    Statement()
}

void DoStatement() :
{ Token t; }
{
	t="do" { jjtThis.setPos(t.getPos()); }
    Statement()
    "while"
	[ "!" { jjtThis.not = true; } ]
    "(" ExpressionNT(null) ")" ";"
}

void ForStatement() :
{ Token t; }
{
	t="for" { jjtThis.setPos(t.getPos()); }
	"("
		ForInit() { jjtThis.init = jjtree.popNode(); }
	/*";"*/
	[
		ExpressionNT(null) { jjtThis.cond = (Expr)jjtree.popNode(); }
	]
	";"
	[
		CommaExpression() { jjtThis.iter = (Expr)jjtree.popNode(); }
	]
	")"
	Statement()
}

void ForEachStatement() :
{ Token t; ASTModifiers modifiers; }
{
	t="foreach" { jjtThis.setPos(t.getPos()); }
	"("
	[	LOOKAHEAD( Modifiers() FormalParameter() )
		modifiers = Modifiers()
		FormalParameter(modifiers)
		";"
	]
	ExpressionNT(null)
	[
	";"
	[ ExpressionNT(null) ]
	]
	")"
	Statement()
}

void ForInit() #void:
{ ASTModifiers modifiers; }
{
	(
	LOOKAHEAD( Modifiers() Type() QName() ("[" "]")* ("=" | ":=" | "," | ";") )
	modifiers = Modifiers()
	VarDecls(modifiers)
|	CommaExpression() ";"
|	EmptyStatement()
 	)
}

void GotoStatement() :
{ Token t; }
{
	t="goto" { jjtThis.setPos(t.getPos()); }
	(
		"case" ExpressionNT(null) { jjtThis.casemode = true; }
	|
		"default" { jjtThis.casemode = true; }
	|
    	Identifier()
    )
    ";"
}

void BreakStatement() :
{ Token t; }
{
	t="break" { jjtThis.setPos(t.getPos()); }
    [ Identifier() ] ";"
}

void ContinueStatement() :
{ Token t; }
{
	t="continue" { jjtThis.setPos(t.getPos()); }
    [ Identifier() ] ";"
}

void ReturnStatement() :
{ Token t; }
{
	t="return" { jjtThis.setPos(t.getPos()); }
    [ ExpressionNT(null) ] ";"
}

void ThrowStatement() :
{ Token t; }
{
	t="throw" { jjtThis.setPos(t.getPos()); }
    ExpressionNT(null) ";"
}

void SynchronizedStatement() :
{ Token t; }
{
	t="synchronized" { jjtThis.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()
}

void WithStatement() :
{ Token t; }
{
	t="with" { jjtThis.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()
}

void TryStatement() :
{ Token t; ASTModifiers modifiers; }
{
	t="try" { jjtThis.setPos(t.getPos()); }
    Block()
	(
		t="catch"
		"("
		modifiers = Modifiers()
		FormalParameter(modifiers)
		")"
		Block()
		{ jjtThis.setPos(t.getPos()); }
        #CatchInfo(2)
	)*
	[	t="finally" Block()
		{ jjtThis.setPos(t.getPos()); }
		#FinallyInfo(1)
	]
}

