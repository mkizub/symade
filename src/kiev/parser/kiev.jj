/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. kiev.jj */
/*@egen*//*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = true;                                                
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev020)

package kiev.parser;

import kiev.Kiev;
import kiev.Kiev.Ext;
import kiev.vlang.*;

public class kiev020/*@bgen(jjtree)*/implements kiev020TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTkiev020State jjtree = new JJTkiev020State();

/*@egen*/

	public static boolean	interface_only = false;
	public static boolean	reparse_body = false;
	public static int		reparse_pos = 0;
	public static PreScanneable		presc = null;

	public static boolean	declMode = true;

	static JJTkiev020State getJJTree() { return jjtree; }

    /** Report Parser Error (Exception) */
	public static void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	public static void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	public void reset() {
		jjtree.reset();
	}

	private static boolean checkNoSpace(Token t1, Token t2) {
		return t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn;
	}

	public static final int[] noColonTokenSet = new int[]{COLON};

	public static int[] no_tokens;

	private static boolean notAToken(Token t) {
		if( no_tokens == null ) return true;
		for(int i=0; i < no_tokens.length; i++) {
			if( t.kind == no_tokens[i] ) return false;
		}
		return true;
	}

	private static boolean labledStatementLA() {
		for(int idx=1; ;idx+=2) {
			if (getToken(idx).kind != IDENTIFIER || getToken(idx+1).kind != COLON)
				return false;
			switch(getToken(idx+2).kind) {
			case LBRACE:
			case SEMICOLON:
			case SWITCH:
			case IF:
			case WHILE:
			case DO:
			case FOR:
			case FOREACH:
			case BREAK:
			case CONTINUE:
			case RETURN:
			case THROW:
			case SYNCHRONIZED:
			case WITH:
			case TRY:
			case GOTO:
			case REPARSE_STATEMENT:
				return true;
			}
		}
	}

	private static boolean operatorLA(int tk) {
		switch( getToken(tk).kind ) {
		case ASSIGN:
		case ASSIGN2:
		case LT:
		case GT:
		case COLON:
		case QUESTION:
		case ARROW:
		case BANG:
		case TILDE:
		case EQ:
		case LE:
		case GE:
		case NE:
		case SC_OR:
		case SC_AND:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
		case STAR:
		case SLASH:
		case BIT_AND:
		case BIT_OR:
		case XOR:
		case REM:
		case LSHIFT:
		case PLUSASSIGN:
		case MINUSASSIGN:
		case STARASSIGN:
		case SLASHASSIGN:
		case ANDASSIGN:
		case ORASSIGN:
		case XORASSIGN:
		case REMASSIGN:
		case LSHIFTASSIGN:
		case RSIGNEDSHIFTASSIGN:
		case RUNSIGNEDSHIFTASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR:
			return notAToken(getToken(tk));
		case OPERATOR_ID:
			return true;
		}
		return false;
	}

	private static boolean castLA_Start() {
		int i = 1;
		Token t = getToken(i);
		if (t.kind == IDENTIFIER) {
			String qname = t.image;
			while( getToken(i+1).kind == DOT && getToken(i+2).kind == IDENTIFIER) {
				i += 2;
				qname = qname + "." + getToken(i).image;
			}
			switch (getToken(i+1).kind) {
			case RPAREN:
			case LT:
			case LBRACKET:
				break;
			default:
				return false;
			}
			try {
				if( PassInfo.checkClassName(KString.from(qname)) ) {
					return true;
				}
			} catch( Exception e ) {}
		}
		return false;
	}

	private static boolean castLA() {
		if( getToken(1).kind != LPAREN ) return false;
		if( getToken(2).kind == CAST ) return true;
		if( getToken(2).kind == REINTERP ) return true;
		return castLA(1,LPAREN,RPAREN);
	}

	private static boolean castLA(int offs, int exp_kind1, int exp_kind2) {
		if( getToken(offs).kind != exp_kind1 ) return false;
		switch( getToken(offs+1).kind ) {
		case BOOLEAN: case CHAR: case BYTE:
		case SHORT: case INT: case LONG: case FLOAT:
		case DOUBLE: case VOID:
			return true;
		case IDENTIFIER:
			break;
		case LPAREN:
			// Skip until matched ')' and check for "->"
			{
				int i = offs+2;
				int depth = 1;
				while( depth != 0 ) {
					switch(getToken(i++).kind) {
					case LPAREN: depth++; break;
					case RPAREN: depth--; break;
					}
				}
				if( getToken(i).kind==ARROW ) {
					return true;
				} else {
					return false;
				}
			}
		default:
			// TODO closure type
			return false;
		}
		// Qualified name resolving to be a class name
		String qname = getToken(offs+1).image;
	scan_qname:
		for(int i=offs+2; ; i+=2) {
			if( getToken(i).kind == DOT && getToken(i+1).kind == IDENTIFIER )
				qname = qname+"."+getToken(i+1).image;
			else {
				switch( getToken(i).kind ) {
				case RPAREN:
					if( exp_kind2 == RPAREN )  break scan_qname;
					else return false;
				case GT:
					if( exp_kind2 == GT ) break scan_qname;
					else return false;
				case LT:
					if( castLA(i,LT,GT) ) break scan_qname;
					else return false;
				case LBRACKET:
					if( getToken(i+1).kind == RBRACKET ) {
						return true;
					}
					else return false;
				case COMMA:
					if( exp_kind1 == LT ) break scan_qname;
					else return false;
				default:
					return false;
				}
			}
		}
		try {
			if( PassInfo.checkClassName(KString.from(qname)) ) {
				return true;
			}
		} catch( Exception e ) {}
		return false;
	}

}

PARSER_END(kiev020)


TOKEN_MGR_DECLS :
{
  static int skip_depth = 0;
}

<DEFAULT,IN_CONSTRAINT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT,IN_CONSTRAINT>
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  <"/**" ([" ","\t","\n","\r"])* "require" [" ","\t","\n","\r"]> { input_stream.backup(8); } : IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "ensure" [" ","\t","\n","\r"]> { input_stream.backup(7); }: IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "invariant" [" ","\t","\n","\r"]> { input_stream.backup(10); } : IN_CONSTRAINT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<IN_CONSTRAINT>
TOKEN :
{
  < END_CONSTRAINT: "**/" > : DEFAULT
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
//| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
// | < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" > { if(Kiev.javaMode||Kiev.disabled(Ext.With)) matchedToken.kind=IDENTIFIER; }
// | < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < UNDERSCORE: "_" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ARROW: "->" >
| < FUNCTION: "fun" >
| < VIRTUAL: "virtual" > { if(Kiev.javaMode || Kiev.disabled(Ext.VirtualFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < VARARGS: "..." >
| < FORWARD: "forward" > { if(Kiev.javaMode || Kiev.disabled(Ext.Forward) /*|| !kiev020.declMode*/) matchedToken.kind=IDENTIFIER; }
| < RULE: "rule" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < PCUT: "$cut" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < CAST: "$cast" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < REINTERP: "$reinterp" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ALIAS: "alias" > { if(Kiev.javaMode || Kiev.disabled(Ext.Alias)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < OPERATOR_ID: "operator" > { if(Kiev.javaMode || Kiev.disabled(Ext.Operator) ) matchedToken.kind=IDENTIFIER; }
| < TYPEDEF: "typedef" > { if(Kiev.javaMode || Kiev.disabled(Ext.Typedef)  || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENUM: "enum" > { if(Kiev.javaMode || Kiev.disabled(Ext.Enum) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < REQUIRE: "require" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENSURE: "ensure" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < INVARIANT: "invariant" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < GENERATE: "$generate" > { if(Kiev.javaMode || Kiev.disabled(Ext.Templates) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < PACKED: "packed" > { if(Kiev.javaMode || Kiev.disabled(Ext.PackedFields) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < WRAPPER: "$wrapper" > { if(Kiev.javaMode || Kiev.disabled(Ext.Wrappers) || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< ACCESS: "access:" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY: "ro" | "r" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < WRITE_ONLY: "wo" | "w"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < READ_WRITE: "rw" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < NO_READ_WRITE: "n" | "no" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < COMMA1: "," >
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < REPARSE_EXPRESSION:
      "#" ["E","e"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
|
  < REPARSE_STATEMENT:
      "#" ["S","s"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "ID#" <ID_STRING_LITERAL> ) >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON: ":" >
| < QUESTION: "?" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >
//| < GT: ">" >
//| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
//| < HOOK: "?" >
//| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//| < RSIGNEDSHIFT: ">>" >
//| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP:	"#" >
| < OPERATOR:	    ["\u2200"-"\u22f1"] >

}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTFileUnit FileUnit(String filename) :
{/*@bgen(jjtree) FileUnit */
  ASTFileUnit jjtn000 = new ASTFileUnit(JJTFILEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FileUnit */
        try {
/*@egen*/
	{
		Kiev.curASTFileUnit = jjtn000;
		jjtn000.setFileName(filename);
		jjtn000.setPos(0);
		declMode = true;
		ASTModifiers modifiers;
	}
	[
		LOOKAHEAD("package" QName() ";")
		Package()
	]
	(
		Import()
	|	Typedef()
	|	Opdef()
	|	Pragma()
	)*
	(
		modifiers = Modifiers()
		try {
			TypeDeclaration(modifiers) [ ";" ]
	|		EnumDeclaration(modifiers) [ ";" ]
	|		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			SyntaxDeclaration(modifiers) [ ";" ]
		}
		catch(ParseError e) { rpe("Bad class declaration",e); }
		catch(Throwable e) { rperr(e); }
	)*
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		declMode = true;
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTModifiers Modifiers() :
{/*@bgen(jjtree) Modifiers */
  ASTModifiers jjtn000 = new ASTModifiers(JJTMODIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifiers */
        try {
/*@egen*/
	(	LOOKAHEAD(2)
		try {
			(
				Modifier()
			|	Pack()
			|	Access()
			|	Annotation()
			)
		}
		catch(ParseError e) { rpe("Bad modifiers",e); }
		catch(Throwable e) { rperr(e); }
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtree.popNode(); return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Package() :
{/*@bgen(jjtree) Package */
  ASTPackage jjtn000 = new ASTPackage(JJTPACKAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Package */
        try {
/*@egen*/
	try {
		"package" QName() ";"
	}
	catch(ParseError e) { rpe("Bad package declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Pragma() :
{/*@bgen(jjtree) Pragma */
  ASTPragma jjtn000 = new ASTPragma(JJTPRAGMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pragma */
        try {
/*@egen*/
	"pragma"
	(
		<PRAGMA_ENABLE>		{ jjtn000.enable = true; }
	|	<PRAGMA_DISABLE>	{ jjtn000.enable = false; }
	)
	( StringConstExpression() )+
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Import() :
{/*@bgen(jjtree) Import */
  ASTImport jjtn000 = new ASTImport(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Import */
        try {
/*@egen*/
	try {
		"import"
		(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			<IDENTIFIER>{ jjtn000.mode = ASTImport.IMPORT_SYNTAX; }
			[ QName() ]
		|	"package"	{ jjtn000.mode = ASTImport.IMPORT_PACKAGE; }
			[ QName() ]
		|	"static"	{ jjtn000.mode = ASTImport.IMPORT_STATIC; }
			QName()
			[	"." "*" { jjtn000.star = true; }
			|	"("		{ jjtn000.args = ASTType.emptyArray; }
				Type() ("," Type())*
				")"
			]
		|	QName()
			[	"." "*" { jjtn000.star = true; }
			|	"("		{ jjtn000.args = ASTType.emptyArray; }
				Type() ("," Type())*
				")"
			]
		)
		";"
	}
	catch(ParseError e) { rpe("Bad import declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Typedef() :
{/*@bgen(jjtree) Typedef */
  ASTTypedef jjtn000 = new ASTTypedef(JJTTYPEDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id1, id2; }
{/*@bgen(jjtree) Typedef */
        try {
/*@egen*/
	try {
		"typedef"
		(
			LOOKAHEAD(3, <IDENTIFIER> TypeOperatorChar() <IDENTIFIER>, {checkNoSpace(getToken(1),getToken(2))})
			{ jjtn000.opdef = true; }
			id1=<IDENTIFIER> Operator() QName() "<" id2=<IDENTIFIER> ">"
			{
				if (!id1.image.equals(id2.image))
					throw new ParseError("Typedef args "+id1+" and "+id2+" do not match");
			}
		|	Type() Identifier()
		) ";"
	}
	catch(ParseError e) { rpe("Bad typedef declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Opdef() :
{/*@bgen(jjtree) Opdef */
  ASTOpdef jjtn000 = new ASTOpdef(JJTOPDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Opdef */
        try {
/*@egen*/
	"operator"
	(
		Operator()
	|	Identifier()
	)
	","
	Identifier()	// FX,FY,XF,YF,XFX,YFX,XFY,YFY
	","
	DecimalConstExpression()
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SyntaxDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) SyntaxDeclaration */
  ASTSyntaxDeclaration jjtn000 = new ASTSyntaxDeclaration(JJTSYNTAXDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) SyntaxDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>	// "syntax"
	Identifier()
	"{"
	(
		Typedef()
	|	Opdef()
	)*
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) TypeDeclaration */
  ASTTypeDeclaration jjtn000 = new ASTTypeDeclaration(JJTTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) TypeDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	try {
		(
			t="class"
			Identifier()
		|	t="interface"
			Identifier()
		|	t="@" "interface"
			(Identifier() | KeywordAsIdentifier())
		)
		{ jjtn000.set(t); t = null; }
	}
	catch(ParseError e) { rpe("Class's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[	Extends()			]
	[	Implements()		]
	[	Generate()			]
	TypeBodyDeclaration()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeBodyDeclaration()       :
{ ASTModifiers modifiers; }
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		(
			modifiers = Modifiers()
			(
				Initializer(modifiers)
			|	InvariantDeclaration(modifiers) [ ";" ]
			|	TypeDeclaration(modifiers) [ ";" ]
			|	EnumDeclaration(modifiers) [ ";" ]
			|	CaseTypeDeclaration(modifiers)
			|
				LOOKAHEAD( "rule" <IDENTIFIER> "(" )
				RuleDeclaration(modifiers)
			|
				LOOKAHEAD( [ClazzArguments()] [ Type() ] [ <IDENTIFIER> ] "(" )
				MethodDeclaration(modifiers)
			|
				LOOKAHEAD( Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
				FieldDecl(modifiers)
			)
		)*
	}
	catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void EnumDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) EnumDeclaration */
  ASTEnumDeclaration jjtn000 = new ASTEnumDeclaration(JJTENUMDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	"enum"
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("enum's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	Extends()			]
	EnumBodyDeclaration()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EnumBodyDeclaration()       :
{ ASTModifiers modifiers; }
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		modifiers = Modifiers()
		EnumFieldDeclaration(modifiers)
		(	","
			modifiers = Modifiers()
			EnumFieldDeclaration(modifiers)
		)*
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }
	[
		";"
		try {
			(
				modifiers = Modifiers()
				(
					Initializer(modifiers)
				|	InvariantDeclaration(modifiers) [ ";" ]
				|	TypeDeclaration(modifiers) [ ";" ]
				|	EnumDeclaration(modifiers) [ ";" ]
				|
					LOOKAHEAD( "rule" <IDENTIFIER> "(" )
					RuleDeclaration(modifiers)
				|
					LOOKAHEAD( [ClazzArguments()] [ Type() ] [ <IDENTIFIER> ] "(" )
					MethodDeclaration(modifiers)
				|
					LOOKAHEAD( Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
					FieldDecl(modifiers)
				)
			)*
		}
		catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
		catch(Throwable e) { rperr(e); }
	]
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void EnumFieldDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) EnumFieldDeclaration */
  ASTEnumFieldDeclaration jjtn000 = new ASTEnumFieldDeclaration(JJTENUMFIELDDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumFieldDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	try {
		Identifier() ["=" DecimalConstExpression()] [":"  StringConstExpression()]
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseTypeDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) CaseTypeDeclaration */
  ASTCaseTypeDeclaration jjtn000 = new ASTCaseTypeDeclaration(JJTCASETYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; ASTBlock bl; }
{/*@bgen(jjtree) CaseTypeDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	t="case"
	{ jjtn000.set(t); }
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("Class's case name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[
		"("
			try {
			[
				modifiers = Modifiers()
				FormalParameter(modifiers)
				(
					","
					modifiers = Modifiers()
					FormalParameter(modifiers)
				)*
			]
			}
			catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
			catch(Throwable e) { rperr(e); }
		")"
	]
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Class's case constructor body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void ClazzArguments()       :
{}
{
	"<"
		try {
			ArgumentDeclaration()
			(	","
				ArgumentDeclaration()
			)*
		}
		catch(ParseError e) { rpe("Class's argument expected",e); }
		catch(Throwable e) { rperr(e); }
	">"
}

void Extends() :
{/*@bgen(jjtree) Extends */
  ASTExtends jjtn000 = new ASTExtends(JJTEXTENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Extends */
        try {
/*@egen*/
	t="extends" { jjtn000.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Super class name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Implements() :
{/*@bgen(jjtree) Implements */
  ASTImplements jjtn000 = new ASTImplements(JJTIMPLEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Implements */
        try {
/*@egen*/
	t="implements" { jjtn000.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Interface name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Generate() :
{/*@bgen(jjtree) Generate */
  ASTGenerate jjtn000 = new ASTGenerate(JJTGENERATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int i=0; }
{/*@bgen(jjtree) Generate */
        try {
/*@egen*/
	"$generate"
	try {
		"<"
			(PrimitiveType() | Identifier()) { i++; }
			( "," (PrimitiveType() | Identifier()) { i++; } )*
		">"
//		{
//		if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//			throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//		}
		(
			"," { i = 0; }
			"<"
				(PrimitiveType() | Identifier()) { i++; }
				( "," (PrimitiveType() | Identifier()) { i++; } )*
			">"
//			{
//			if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//				throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//			}
		)*
	}
	catch(ParseError e) { rpe("Bad $generate directive",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArgumentDeclaration() :
{/*@bgen(jjtree) ArgumentDeclaration */
  ASTArgumentDeclaration jjtn000 = new ASTArgumentDeclaration(JJTARGUMENTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentDeclaration */
        try {
/*@egen*/
	Identifier()
	[
		"extends" NonArrayType()
	|	"implements" NonArrayType()
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Modifier() :
{/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) Modifier */
        try {
/*@egen*/
	(
	  t="public"
	| t="protected"
	| t="private"
	| t="static"
	| t="abstract"
	| t="final"
	| t="native"
	| t="synchronized"
	| t="transient"
	| t="volatile"
	| t="virtual"
	| t="forward"

	| t="$wrapper"

	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Pack() :
{/*@bgen(jjtree) Pack */
  ASTPack jjtn000 = new ASTPack(JJTPACK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int size=-1; int offset=-1; String packer=null; }
{/*@bgen(jjtree) Pack */
        try {
/*@egen*/
	"packed"
	[
		":"
		t=<INTEGER_LITERAL> { size = Integer.parseInt(t.image); t = null; }
		[
		","
		t=<IDENTIFIER> { packer = t.image; t = null; }
		","
		t=<INTEGER_LITERAL> { offset = Integer.parseInt(t.image); t = null; }
		]
	]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(size,packer,offset); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Access() :
{/*@bgen(jjtree) Access */
  ASTAccess jjtn000 = new ASTAccess(JJTACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ int acc; }
{/*@bgen(jjtree) Access */
        try {
/*@egen*/
	LOOKAHEAD({Kiev.enabled(Ext.Access)})
	"access:"
	acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	]]]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

int AccessSpec()       :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

void KeywordAsIdentifier()       :
{ Token t; ASTIdentifier id; }
{
	(
		t="virtual"
	|	t="alias"
	|	t="packed"
	|	t="throws"
	)
	{
		id = new ASTIdentifier(0);
		jjtree.openNodeScope(id);
		id.set(t);
		jjtree.closeNodeScope(id, true);
		t = null;
	}
}

void Annotation() :
{/*@bgen(jjtree) Annotation */
  ASTAnnotation jjtn000 = new ASTAnnotation(JJTANNOTATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Annotation */
        try {
/*@egen*/
	"@"
	(
		Identifier()
	|	KeywordAsIdentifier()
	)
	[
		"("
		[	LOOKAHEAD( <IDENTIFIER> "=" )
			AnnotationValues()
		|/*@bgen(jjtree) #AnnotationValue( 1) */
                        {
                          ASTAnnotationValue jjtn001 = new ASTAnnotationValue(JJTANNOTATIONVALUE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/	AnnotationValueAny()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  1);
                          }
                        }
/*@egen*/
		]
		")"
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AnnotationValues()       :
{}
{
	Identifier()
	"="/*@bgen(jjtree) #AnnotationValue( 2) */
        {
          ASTAnnotationValue jjtn001 = new ASTAnnotationValue(JJTANNOTATIONVALUE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	AnnotationValueAny()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
	(
		","
		Identifier()
		"="/*@bgen(jjtree) #AnnotationValue( 2) */
                {
                  ASTAnnotationValue jjtn002 = new ASTAnnotationValue(JJTANNOTATIONVALUE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/
		AnnotationValueAny()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  2);
                  }
                }
/*@egen*/
	)*
}

void AnnotationValueAny()       :
{}
{
		LOOKAHEAD( "@" <IDENTIFIER> )
		Annotation()
	|	AnnotationValueValueArrayInitializer()
	|	ExpressionNT(null)
}

void AnnotationValueScalar()       :
{}
{
		LOOKAHEAD( "@" <IDENTIFIER> )
		Annotation()
	|	ExpressionNT(null)
}

void AnnotationValueValueArrayInitializer() :
{/*@bgen(jjtree) AnnotationValueValueArrayInitializer */
  ASTAnnotationValueValueArrayInitializer jjtn000 = new ASTAnnotationValueValueArrayInitializer(JJTANNOTATIONVALUEVALUEARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnnotationValueValueArrayInitializer */
        try {
/*@egen*/
	"{"
	[
		AnnotationValueScalar()
		(	","
			AnnotationValueScalar()
		)*
	]
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void FieldDecl(ASTModifiers modifiers) :
{/*@bgen(jjtree) FieldDecl */
  ASTFieldDecl jjtn000 = new ASTFieldDecl(JJTFIELDDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) FieldDecl */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	try {
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	{ old_declMode = declMode; declMode = false; }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Field declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	finally { declMode = old_declMode; }
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VarDecls(ASTModifiers modifiers) :
{/*@bgen(jjtree) VarDecls */
  ASTVarDecls jjtn000 = new ASTVarDecls(JJTVARDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecls */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers,-1); }
	try {
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Variable declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VarDecl() :
{/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
        try {
/*@egen*/
	Identifier()
	( "[" "]" { jjtn000.dim += 1; } )*
	[ ("=" | ":=" { jjtn000.of_wrapper=true; }) VariableInitializer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableInitializer()       :
{}
{
	(
		ArrayInitializer()
	|
		Expression()
	)
}

void ArrayInitializer()                                :
{/*@bgen(jjtree) NewInitializedArrayExpression */
  ASTNewInitializedArrayExpression jjtn000 = new ASTNewInitializedArrayExpression(JJTNEWINITIALIZEDARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NewInitializedArrayExpression */
        try {
/*@egen*/
	t="{"
	[	LOOKAHEAD(2)
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTFormalParameter FormalParameter(ASTModifiers modifiers) :
{/*@bgen(jjtree) FormalParameter */
  ASTFormalParameter jjtn000 = new ASTFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTType tp; }
{/*@bgen(jjtree) FormalParameter */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	(
		tp = Type()
		Identifier()
		( "[" "]" { tp.dim += 1; } )*
	|
		t="_" { jjtn000.set(t); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTFormalParameter mmFormalParameter(ASTModifiers modifiers)                  :
{/*@bgen(jjtree) FormalParameter */
  ASTFormalParameter jjtn000 = new ASTFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTType tp; ASTType mmtp = null; }
{/*@bgen(jjtree) FormalParameter */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	(
		tp = Type()
		(
			LOOKAHEAD({ !Kiev.javaMode && (getToken(1).image.equals(":")) })
			(":") mmtp = Type()
		)?
		Identifier()
		( "[" "]" { tp.dim += 1; if (mmtp != null) mmtp.dim += 1; } )*
	|
		t="_" { jjtn000.set(t); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Throws() :
{/*@bgen(jjtree) Throws */
  ASTThrows jjtn000 = new ASTThrows(JJTTHROWS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Throws */
        try {
/*@egen*/
	t="throws" { jjtn000.setPos(t.getPos()); }
	try {
		NonArrayType()
		(	"," NonArrayType()	)*
	}
	catch(ParseError e) { rpe("Throwable class name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Alias()       :
{ Token t; }
{
	"alias"
	try {
		(
			LOOKAHEAD(2)
			OperatorAlias()
		|	IdentifierAlias()
		)
	}
	catch(ParseError e) { rpe("Alias expected",e); }
	catch(Throwable e) { rperr(e); }
}

void IdentifierAlias() :
{/*@bgen(jjtree) IdentifierAlias */
  ASTIdentifierAlias jjtn000 = new ASTIdentifierAlias(JJTIDENTIFIERALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IdentifierAlias */
        try {
/*@egen*/
	Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void OperatorAlias() :
{/*@bgen(jjtree) OperatorAlias */
  ASTOperatorAlias jjtn000 = new ASTOperatorAlias(JJTOPERATORALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) OperatorAlias */
        try {
/*@egen*/
	(	// temporary, for backward compatibility
		"operator"
		"("
		DecimalConstExpression()	","
		Identifier()		","
		(
			Operator()
		|	Identifier()
		|	"[" "]"	{ jjtn000.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"	{ jjtn000.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"	{ jjtn000.image = kiev.vlang.Constants.nameCastOp; }
		)
		")"
	|
		t=<IDENTIFIER> { jjtn000.set(t); }
		"operator"
		(
			Operator()
		|	Identifier()
		|	"[" "]"/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{ jjtn000.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{ jjtn000.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{ jjtn000.image = kiev.vlang.Constants.nameCastOp; }
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MaybeSkipBlock()       :
{ boolean old_declMode; }
{
	(
		LOOKAHEAD({ interface_only })
//		{ old_declMode = declMode; declMode = false; }
//		try {
			"{"
			{
			Token tk = getToken(0);
			PrescannedBody pbody = new PrescannedBody(tk.beginLine,tk.beginColumn);
			Kiev.curASTFileUnit.addPrescannedBody(pbody);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
			presc.pbody = pbody;
			if( presc instanceof ASTCondDeclaration )
				pbody.mode = PrescannedBody.CondBlockMode;
			else if( presc instanceof ASTRuleDeclaration )
				pbody.mode = PrescannedBody.RuleBlockMode;
			else
				pbody.mode = PrescannedBody.BlockMode;
			}
//		} finally { declMode = old_declMode; }
	|	LOOKAHEAD({ presc instanceof ASTCondDeclaration })
		CondBlock()
	|	LOOKAHEAD({ presc instanceof ASTRuleDeclaration })
		RuleBlock()
	|	Block()
	)
}

void MethodDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) MethodDeclaration */
  ASTMethodDeclaration jjtn000 = new ASTMethodDeclaration(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTType tp=null; }
{/*@bgen(jjtree) MethodDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	[	ClazzArguments()	]
	[
		LOOKAHEAD( Type() <IDENTIFIER> )
		tp = Type()
	]
	Identifier()
	"("
		try {
		[
			modifiers = Modifiers()
			mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ jjtn000.setVarArgs(true); }
			]
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		t="[" "]"
		{
			if (tp != null)
				tp.dim += 1;
			else
				Kiev.reportParserError(t.getPos(), "Array return in constructor?");
		}
	)*
	(
		Alias()
	)*
	[	Throws()	]
	try {
		(
			RequareDeclaration()
		|	EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	[ "default"/*@bgen(jjtree) #AnnotationValue( 1) */
                                    {
                                      ASTAnnotationValue jjtn001 = new ASTAnnotationValue(JJTANNOTATIONVALUE);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*/ AnnotationValueAny()/*@bgen(jjtree)*/
                                    } catch (Throwable jjte001) {
                                      if (jjtc001) {
                                        jjtree.clearNodeScope(jjtn001);
                                        jjtc001 = false;
                                      } else {
                                        jjtree.popNode();
                                      }
                                      if (jjte001 instanceof RuntimeException) {
                                        throw (RuntimeException)jjte001;
                                      }
                                      if (jjte001 instanceof ParseException) {
                                        throw (ParseException)jjte001;
                                      }
                                      throw (Error)jjte001;
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  1);
                                      }
                                    }
/*@egen*/ ] ";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RequareDeclaration() :
{/*@bgen(jjtree) RequareDeclaration */
  ASTRequareDeclaration jjtn000 = new ASTRequareDeclaration(JJTREQUAREDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RequareDeclaration */
        try {
/*@egen*/
	"require"
	try {
		[
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		]
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'require' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void EnsureDeclaration() :
{/*@bgen(jjtree) EnsureDeclaration */
  ASTEnsureDeclaration jjtn000 = new ASTEnsureDeclaration(JJTENSUREDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnsureDeclaration */
        try {
/*@egen*/
	"ensure"
	try {
		[
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		]
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'ensure' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InvariantDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) InvariantDeclaration */
  ASTInvariantDeclaration jjtn000 = new ASTInvariantDeclaration(JJTINVARIANTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InvariantDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	"invariant"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
		)
		CondBlock()
	}
	catch(ParseError e) { rpe("Bad 'invariant' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleDeclaration(ASTModifiers modifiers) :
{/*@bgen(jjtree) RuleDeclaration */
  ASTRuleDeclaration jjtn000 = new ASTRuleDeclaration(JJTRULEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ ASTBlock bl; }
{/*@bgen(jjtree) RuleDeclaration */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	"rule"
	Identifier()
	"("
		try {
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		Alias()
	)*
	(
		modifiers = Modifiers()
		VarDecls(modifiers)
	)*
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Initializer(ASTModifiers modifiers) :
{/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initializer */
        try {
/*@egen*/
	{ jjtn000.jjtAddChild(modifiers, -1); }
	try {
		{ presc = jjtn000; }
		MaybeSkipBlock() [ ";" ]
	}
	catch(ParseError e) { rpe("Initializer's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/*
 * Type, name and expression syntax follows.
 */

ASTType Type() :
{/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	(	NonArrayType()
		(	LOOKAHEAD(2)
			"[" "]" { jjtn000.dim += 1; }
		)*
	|	LOOKAHEAD({Kiev.enabled(Ext.With)})
		ClosureType()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClosureType() :
{/*@bgen(jjtree) ClosureType */
  ASTClosureType jjtn000 = new ASTClosureType(JJTCLOSURETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ClosureType */
        try {
/*@egen*/
	t="(" { jjtn000.setPos(t.getPos()); }
	[
		Type()
		( "," Type() )*
	]
	")" "->" Type()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void NonArrayType() :
{/*@bgen(jjtree) NonArrayType */
  ASTNonArrayType jjtn000 = new ASTNonArrayType(JJTNONARRAYTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NonArrayType */
        try {
/*@egen*/
	try {
	(
		PrimitiveType()
	|	QName()
		[	LOOKAHEAD(1, "<", {Kiev.enabled(Ext.Generics)})
			"<"
				Type()
				( "," Type() )*
			">"
		]
	)
	(	LOOKAHEAD(1,TypeOperatorChar(),{Kiev.enabled(Ext.Typedef)&&checkNoSpace(getToken(0),getToken(1))})
		t=TypeOperatorChar() { jjtn000.addOperation(t); }
	)*
	}
	catch(ParseError e) { rpe("Bad type specification",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PrimitiveType() :
{/*@bgen(jjtree) PrimitiveType */
  ASTPrimitiveType jjtn000 = new ASTPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PrimitiveType */
         try {
/*@egen*/
	 (
	  t="boolean"
	| t="char"
	| t="byte"
	| t="short"
	| t="int"
	| t="long"
	| t="float"
	| t="double"
	| t="void"
	| t="rule"
	  )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void QName() :
{/*@bgen(jjtree) QName */
  ASTQName jjtn000 = new ASTQName(JJTQNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QName */
        try {
/*@egen*/
	try {
		Identifier()
		( LOOKAHEAD(2) "." Identifier() )*
	}
	catch(ParseError e) { rpe("Qualified name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Expression syntax follows.
 */

void CommaExpression()                      :
{/*@bgen(jjtree) #CommaExpression(> 1) */
  ASTCommaExpression jjtn000 = new ASTCommaExpression(JJTCOMMAEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CommaExpression(> 1) */
        try {
/*@egen*/
	Expression()
	( "," Expression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleOrExpression()                       :
{/*@bgen(jjtree) #RuleOrExpression(> 1) */
  ASTRuleOrExpression jjtn000 = new ASTRuleOrExpression(JJTRULEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RuleOrExpression(> 1) */
        try {
/*@egen*/
	RuleAndExpression()
	( ";" RuleAndExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleAndExpression()                        :
{/*@bgen(jjtree) #RuleAndExpression(> 1) */
  ASTRuleAndExpression jjtn000 = new ASTRuleAndExpression(JJTRULEANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RuleAndExpression(> 1) */
        try {
/*@egen*/
	RuleExpression()
	( "," RuleExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleExpression()       :
{ Token t = null; int n; }
{
	(
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_THE
	})
	RuleIstheExpression()
|
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_ONE_OF
	})
	RuleIsoneofExpression()
|
	LOOKAHEAD({getToken(1).kind == PCUT})
	RuleCutExpression()
|
	LOOKAHEAD({getToken(1).kind == LBRACE})
	"{" RuleOrExpression() "}"
|
	LOOKAHEAD({getToken(1).kind == WHILE})
	"while" Expression()/*@bgen(jjtree) #RuleExpression( 1) */
                             {
                               ASTRuleExpression jjtn001 = new ASTRuleExpression(JJTRULEEXPRESSION);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                             }
                             try {
/*@egen*//*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn001,  1);
                               jjtc001 = false;
                             }
/*@egen*/ { jjtn001.while_mode=true; t=null; }/*@bgen(jjtree)*/
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001,  1);
                               }
                             }
/*@egen*/
|
	LOOKAHEAD(0)
	ExpressionNT(noColonTokenSet) { n = 1; }/*@bgen(jjtree) #RuleExpression( n) */
        {
          ASTRuleExpression jjtn002 = new ASTRuleExpression(JJTRULEEXPRESSION);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	[ ":" ExpressionNT(noColonTokenSet) {n = 2;} ]/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  n);
          }
        }
/*@egen*/
	)
}

void RuleIstheExpression() :
{/*@bgen(jjtree) RuleIstheExpression */
  ASTRuleIstheExpression jjtn000 = new ASTRuleIstheExpression(JJTRULEISTHEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleIstheExpression */
        try {
/*@egen*/
	Identifier() "?=" AccessExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleIsoneofExpression() :
{/*@bgen(jjtree) RuleIsoneofExpression */
  ASTRuleIsoneofExpression jjtn000 = new ASTRuleIsoneofExpression(JJTRULEISONEOFEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleIsoneofExpression */
        try {
/*@egen*/
	Identifier() "@=" AccessExpression()
	(
		LOOKAHEAD({
			getToken(1).image.equals("&")
		 && getToken(2).kind == IDENTIFIER
		 && getToken(3).kind == IS_ONE_OF
		})
		"&" Identifier() "@=" AccessExpression()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleCutExpression() :
{/*@bgen(jjtree) RuleCutExpression */
  ASTRuleCutExpression jjtn000 = new ASTRuleCutExpression(JJTRULECUTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RuleCutExpression */
        try {
/*@egen*/
	t="$cut"/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.setPos(t.getPos()); t = null; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Token TypeOperatorChar()       :
{ Token t; }
{
	(
		t=<QUESTION>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar()       :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<ASSIGN2>
	|	t=<LT>
	|	t=<GT>
	|	t=<COLON>
	|	t=<QUESTION>
	|	t=<ARROW>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<EQ>
	|	t=<LE>
	|	t=<GE>
	|	t=<NE>
	|	t=<SC_OR>
	|	t=<SC_AND>
	|	t=<INCR>
	|	t=<DECR>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<LSHIFT>
	|	t=<PLUSASSIGN>
	|	t=<MINUSASSIGN>
	|	t=<STARASSIGN>
	|	t=<SLASHASSIGN>
	|	t=<ANDASSIGN>
	|	t=<ORASSIGN>
	|	t=<XORASSIGN>
	|	t=<REMASSIGN>
	|	t=<LSHIFTASSIGN>
	|	t=<RSIGNEDSHIFTASSIGN>
	|	t=<RUNSIGNEDSHIFTASSIGN>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

void Operator() :
{/*@bgen(jjtree) Operator */
  ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String image; }
{/*@bgen(jjtree) Operator */
        try {
/*@egen*/
	(
		t=OperatorChar()
		{ image = t.image; }
		(
			LOOKAHEAD({ !Kiev.javaMode && operatorLA(1) && checkNoSpace(getToken(0),getToken(1)) })
			t=OperatorChar()
			{ image = image+t.image; }
		|
			LOOKAHEAD({ Kiev.javaMode && getToken(1).kind==GT && checkNoSpace(getToken(0),getToken(1)) })
			t=<GT>
			{ image = image+t.image; }
		)*
	|	LOOKAHEAD({ !Kiev.javaMode })
		"operator" t=<IDENTIFIER>
		{ image = t.image; }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setPos(t.getPos());
		jjtn000.image = KString.from(image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CastOperatorLA()       :
{}
{
	"("
	(
		<CAST>
	|	<REINTERP>
	|	PrimitiveType()
	|	LOOKAHEAD(0,{ castLA_Start() }) Type() ")"
		(
			<IDENTIFIER>
		|	"("
		|	ConstExpression()
		|	"new"
		|	Operator()
		|	ReparseExpression()
		|	"fun"
		)
	)
}

void CastOperator() :
{/*@bgen(jjtree) CastOperator */
  ASTCastOperator jjtn000 = new ASTCastOperator(JJTCASTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) CastOperator */
        try {
/*@egen*/
	t="(" { jjtn000.setPos(t.getPos()); } [ <CAST> | <REINTERP> {jjtn000.reinterp=true;} ] Type() ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionNT(int[] nt_new)       :
{ int[] nt_old = no_tokens; no_tokens = nt_new; }
{
	try {
		Expression()
	} finally { no_tokens = nt_old; }
}

void Expression() :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	try {
		(
			LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("instanceof") })
			Identifier() Type()
		|	LOOKAHEAD({ operatorLA(1) })
			Operator()
//		|	LOOKAHEAD({ castLA() })
		|	LOOKAHEAD( CastOperatorLA() )
			CastOperator()
		|	LOOKAHEAD(2)
			AccessExpression()
		)+
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReparseExpression() :
{/*@bgen(jjtree) ReparseExpression */
  ASTReparseExpression jjtn000 = new ASTReparseExpression(JJTREPARSEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReparseExpression */
        try {
/*@egen*/
	try {
		t=<REPARSE_EXPRESSION> { jjtn000.set(t); }
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CallExpression() :
{/*@bgen(jjtree) CallExpression */
  ASTCallExpression jjtn000 = new ASTCallExpression(JJTCALLEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CallExpression */
                try {
/*@egen*/
		Identifier() "("
		[	ExpressionNT(null)
			(	"," ExpressionNT(null)	)*
		]
		")"/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void AccessExpression()       :
{ Token t; }
{
	(
		LOOKAHEAD( Type() "." "class" )
		Type() "."/*@bgen(jjtree) #TypeClassExpression( 1) */
                           {
                             ASTTypeClassExpression jjtn001 = new ASTTypeClassExpression(JJTTYPECLASSEXPRESSION);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ "class"/*@bgen(jjtree)*/
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  1);
                             }
                           }
/*@egen*/
	|
		LOOKAHEAD(2)
		ConstExpression()
	|
		LOOKAHEAD(2)
		CallExpression()
	|
		LOOKAHEAD(2)
		Identifier()
	|
		LOOKAHEAD("new" NonArrayType() ("[" "]")+ "{" )
		NewInitializedArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() "[" )
		NewArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() ( "(" ) )
		NewExpression()
	|
		ReparseExpression()
	|
		"(" ExpressionNT(null) ")"
	|   LOOKAHEAD("fun" "(")
		AnonymouseClosure()
	)
	(
		LOOKAHEAD(3)
		"."/*@bgen(jjtree) #CallAccessExpression( 2) */
                    {
                      ASTCallAccessExpression jjtn002 = new ASTCallAccessExpression(JJTCALLACCESSEXPRESSION);
                      boolean jjtc002 = true;
                      jjtree.openNodeScope(jjtn002);
                    }
                    try {
/*@egen*/ CallExpression()/*@bgen(jjtree)*/
                    } catch (Throwable jjte002) {
                      if (jjtc002) {
                        jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte002 instanceof RuntimeException) {
                        throw (RuntimeException)jjte002;
                      }
                      if (jjte002 instanceof ParseException) {
                        throw (ParseException)jjte002;
                      }
                      throw (Error)jjte002;
                    } finally {
                      if (jjtc002) {
                        jjtree.closeNodeScope(jjtn002,  2);
                      }
                    }
/*@egen*/
	|
		LOOKAHEAD(3)
		t="." Identifier()/*@bgen(jjtree) #AccessExpression( 2) */
        {
          ASTAccessExpression jjtn003 = new ASTAccessExpression(JJTACCESSEXPRESSION);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003,  2);
          jjtc003 = false;
        }
/*@egen*/
        { jjtn003.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/
	|	LOOKAHEAD(2)
		t="[" ExpressionNT(null) "]"/*@bgen(jjtree) #ArrayElementAccessExpression( 2) */
        {
          ASTArrayElementAccessExpression jjtn004 = new ASTArrayElementAccessExpression(JJTARRAYELEMENTACCESSEXPRESSION);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004,  2);
          jjtc004 = false;
        }
/*@egen*/
        { jjtn004.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  2);
          }
        }
/*@egen*/
	|
		LOOKAHEAD("." "new" NonArrayType() ( "(" ) )
		"."/*@bgen(jjtree) #NewAccessExpression( 2) */
                {
                  ASTNewAccessExpression jjtn005 = new ASTNewAccessExpression(JJTNEWACCESSEXPRESSION);
                  boolean jjtc005 = true;
                  jjtree.openNodeScope(jjtn005);
                }
                try {
/*@egen*/
		NewExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte005) {
                  if (jjtc005) {
                    jjtree.clearNodeScope(jjtn005);
                    jjtc005 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte005 instanceof RuntimeException) {
                    throw (RuntimeException)jjte005;
                  }
                  if (jjte005 instanceof ParseException) {
                    throw (ParseException)jjte005;
                  }
                  throw (Error)jjte005;
                } finally {
                  if (jjtc005) {
                    jjtree.closeNodeScope(jjtn005,  2);
                  }
                }
/*@egen*/
	)*
}

void AnonymouseClosure() :
{/*@bgen(jjtree) AnonymouseClosure */
  ASTAnonymouseClosure jjtn000 = new ASTAnonymouseClosure(JJTANONYMOUSECLOSURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTModifiers modifiers; }
{/*@bgen(jjtree) AnonymouseClosure */
        try {
/*@egen*/
	t="fun" "("
	[
		modifiers = Modifiers()
		FormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			FormalParameter(modifiers)
		)*
	]
	")" "->"
    { jjtn000.setPos(t.getPos()); }
    (
		LOOKAHEAD( { getToken(1).kind == RULE } )
		Type() RuleBlock()
	|	Type() Block()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstExpression()       :
{}
{
	(
		BooleanConstExpression()
	|	DecimalConstExpression()
	|	FloatConstExpression()
	|	CharConstExpression()
	|	NullConstExpression()
	|	StringConstExpression()
	)
}

void BooleanConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
		t="true"
	|	t="false"
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DecimalConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
	 	t=<INTEGER_LITERAL>
	|	t=<LONG_INTEGER_LITERAL>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FloatConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
		t=<FLOATING_POINT_LITERAL>
	|	t=<DOUBLE_POINT_LITERAL>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CharConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t=<CHARACTER_LITERAL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NullConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t="null"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StringConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t, t1; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t=<STRING_LITERAL>
	(
		LOOKAHEAD({
			getToken(1).kind==PLUS
		 && getToken(2).kind==STRING_LITERAL
		})
		"+" t1=<STRING_LITERAL>
		{
			t.image = t.image.substring(0,t.image.length()-1)+t1.image.substring(1);
			t.endLine = t1.endLine;
			t.endColumn = t1.endColumn;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewExpression() :
{/*@bgen(jjtree) NewExpression */
        ASTNewExpression jjtn000 = new ASTNewExpression(JJTNEWEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	boolean old_mode;
}
{/*@bgen(jjtree) NewExpression */
        try {
/*@egen*/
	t="new" { jjtn000.setPos(t.getPos()); }
    NonArrayType() "("
	[	ExpressionNT(null)
		(	"," ExpressionNT(null)	)*
	]
	")"
	[
		LOOKAHEAD("{")
		{ old_mode = interface_only; interface_only = false; jjtn000.anonymouse = true; }
		try {
			TypeBodyDeclaration()
		} finally {
		{ interface_only = old_mode; }
		}
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewArrayExpression() :
{/*@bgen(jjtree) NewArrayExpression */
  ASTNewArrayExpression jjtn000 = new ASTNewArrayExpression(JJTNEWARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int dim=0; }
{/*@bgen(jjtree) NewArrayExpression */
        try {
/*@egen*/
	t="new" NonArrayType()
	( LOOKAHEAD(2) "[" ExpressionNT(null) "]" { dim += 1; } )+
	( LOOKAHEAD(2) "[" "]" { dim += 1; } )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { jjtn000.dim = dim; jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewInitializedArrayExpression() :
{/*@bgen(jjtree) NewInitializedArrayExpression */
  ASTNewInitializedArrayExpression jjtn000 = new ASTNewInitializedArrayExpression(JJTNEWINITIALIZEDARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int dim=0; }
{/*@bgen(jjtree) NewInitializedArrayExpression */
        try {
/*@egen*/
	t="new" NonArrayType()
	( "[" "]" { dim += 1; } )+
	"{"
	[
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { jjtn000.dim = dim; jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/*
 * Statement syntax follows.
 */

void Statement()       :
{}
{
	try {
	(
	  LOOKAHEAD({labledStatementLA()})
	  LabeledStatement()
	| Block()
	| EmptyStatement()
	| SwitchStatement()
	| IfStatement()
	| WhileStatement()
	| DoStatement()
	| ForStatement()
	| ForEachStatement()
	| BreakStatement()
	| ContinueStatement()
	| ReturnStatement()
	| ThrowStatement()
	| SynchronizedStatement()
	| WithStatement()
	| TryStatement()
	| GotoStatement()
	| ReparseStatement()
	| StatementExpression()
	)
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseStatement() :
{/*@bgen(jjtree) ReparseStatement */
  ASTReparseStatement jjtn000 = new ASTReparseStatement(JJTREPARSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReparseStatement */
        try {
/*@egen*/
	try {
		t=<REPARSE_STATEMENT> { jjtn000.set(t); }
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LabeledStatement() :
{/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
	LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(2).kind == COLON } )
	Identifier() ":" Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


ASTBlock PrescannedBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=Block()
	{ return bl; }
}

ASTBlock Block() :
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
	"{"
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	( BlockStatement() )*
	} finally { declMode = old_declMode; PassInfo.pop(jjtn000); }
    "}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTBlock PrescannedRuleBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=RuleBlock()
	{ return bl; }
}

ASTBlock RuleBlock() :
{/*@bgen(jjtree) RuleBlock */
  ASTRuleBlock jjtn000 = new ASTRuleBlock(JJTRULEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) RuleBlock */
        try {
/*@egen*/
	"{"
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		RuleOrExpression()
	}
	catch(ParseError e) { rpe("Bad rule",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		declMode = old_declMode;
		PassInfo.pop(jjtn000);
	}
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTBlock PrescannedCondBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=CondBlock()
	{ return bl; }
}

ASTBlock CondBlock() :
{/*@bgen(jjtree) CondBlock */
  ASTCondBlock jjtn000 = new ASTCondBlock(JJTCONDBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CondBlock */
        try {
/*@egen*/
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
	}
	try {
		"{"
				( CondStatement() )+
		"}" [ <END_CONSTRAINT> ]
	|
		( CondStatement() )+
		<END_CONSTRAINT>
	} finally {
		PassInfo.pop(jjtn000);
	}/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BlockStatement()       :
{ boolean old_declMode; ASTModifiers modifiers; }
{
	(
		LOOKAHEAD( Modifier() ("class" | "interface" | "@" "interface") )
		{ old_declMode = declMode; declMode = false; }
		try {
			modifiers = Modifiers()
			TypeDeclaration(modifiers)
		} finally {
			declMode = old_declMode;
		}
	|	LOOKAHEAD( Modifiers() Type() Identifier() )
		modifiers = Modifiers()
		VarDecls(modifiers) //#DeclStatement
	|	LOOKAHEAD(0)
		Statement()
	)
}

void CondStatement() :
{/*@bgen(jjtree) CondStatement */
  ASTCondStatement jjtn000 = new ASTCondStatement(JJTCONDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = getToken(1); }
{/*@bgen(jjtree) CondStatement */
        try {
/*@egen*/
	ExpressionNT(noColonTokenSet)
	[
		":"
		{ t = null; }
		Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ASTConstExpression e = new ASTConstExpression(0);
			e.pos = pos;
			e.val = KString.from(sb.toString());
			jjtn000.jjtAddChild(e,1);
		}
	}
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EmptyStatement() :
{/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) EmptyStatement */
        try {
/*@egen*/
	t=";"/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementExpression() :
{/*@bgen(jjtree) StatementExpression */
  ASTStatementExpression jjtn000 = new ASTStatementExpression(JJTSTATEMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementExpression */
        try {
/*@egen*/
	ExpressionNT(null) ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SwitchStatement() :
{/*@bgen(jjtree) SwitchStatement */
  ASTSwitchStatement jjtn000 = new ASTSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SwitchStatement */
        try {
/*@egen*/
	t="switch" { jjtn000.setPos(t.getPos()); }
	"(" ExpressionNT(null) ")"
	"{"
	(	CaseStatements()	)+
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseStatements()       :
{}
{
	(
		LOOKAHEAD("case" QName() "(" )
		PizzaCase()
	|
		NormalCase()
	)
}

void NormalCase() :
{/*@bgen(jjtree) NormalCase */
  ASTNormalCase jjtn000 = new ASTNormalCase(JJTNORMALCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NormalCase */
        try {
/*@egen*/
	(
		t="case" ExpressionNT(noColonTokenSet) ":"
	|	t="default" ":"
	)
    { jjtn000.setPos(t.getPos()); }
	(
		BlockStatement()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PizzaCase() :
{/*@bgen(jjtree) PizzaCase */
  ASTPizzaCase jjtn000 = new ASTPizzaCase(JJTPIZZACASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTModifiers modifiers; }
{/*@bgen(jjtree) PizzaCase */
        try {
/*@egen*/
	t="case" { jjtn000.setPos(t.getPos()); }
    QName()
	"("
		[
			modifiers = Modifiers()
			FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				FormalParameter(modifiers)
			)*
		]
	")" ":"
	(
		BlockStatement()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IfStatement() :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/
	t="if" { jjtn000.setPos(t.getPos()); }
	[ "!" { jjtn000.not = true; } ]
    "(" ExpressionNT(null) ")"
	Statement()
	[	LOOKAHEAD(1)
		"else"
		Statement()
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/
	t="while" { jjtn000.setPos(t.getPos()); }
	[ "!" { jjtn000.not = true; } ]
    "(" ExpressionNT(null) ")"
    Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DoStatement() :
{/*@bgen(jjtree) DoStatement */
  ASTDoStatement jjtn000 = new ASTDoStatement(JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DoStatement */
        try {
/*@egen*/
	t="do" { jjtn000.setPos(t.getPos()); }
    Statement()
    "while"
	[ "!" { jjtn000.not = true; } ]
    "(" ExpressionNT(null) ")" ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForStatement() :
{/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ForStatement */
        try {
/*@egen*/
	t="for" { jjtn000.setPos(t.getPos()); }
	"("
		ForInit() { jjtn000.init = jjtree.popNode(); }
	/*";"*/
	[
		ExpressionNT(null) { jjtn000.cond = (Expr)jjtree.popNode(); }
	]
	";"
	[
		CommaExpression() { jjtn000.iter = (Expr)jjtree.popNode(); }
	]
	")"
	Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForEachStatement() :
{/*@bgen(jjtree) ForEachStatement */
  ASTForEachStatement jjtn000 = new ASTForEachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTModifiers modifiers; }
{/*@bgen(jjtree) ForEachStatement */
        try {
/*@egen*/
	t="foreach" { jjtn000.setPos(t.getPos()); }
	"("
	[	LOOKAHEAD( Modifiers() FormalParameter() )
		modifiers = Modifiers()
		FormalParameter(modifiers)
		";"
	]
	ExpressionNT(null)
	[
	";"
	[ ExpressionNT(null) ]
	]
	")"
	Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForInit()      :
{ ASTModifiers modifiers; }
{
	(
	LOOKAHEAD( Modifiers() Type() QName() ("[" "]")* ("=" | ":=" | "," | ";") )
	modifiers = Modifiers()
	VarDecls(modifiers)
|	CommaExpression() ";"
|	EmptyStatement()
 	)
}

void GotoStatement() :
{/*@bgen(jjtree) GotoStatement */
  ASTGotoStatement jjtn000 = new ASTGotoStatement(JJTGOTOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) GotoStatement */
        try {
/*@egen*/
	t="goto" { jjtn000.setPos(t.getPos()); }
	(
		"case" ExpressionNT(null) { jjtn000.casemode = true; }
	|
		"default" { jjtn000.casemode = true; }
	|
    	Identifier()
    )
    ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BreakStatement() :
{/*@bgen(jjtree) BreakStatement */
  ASTBreakStatement jjtn000 = new ASTBreakStatement(JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BreakStatement */
        try {
/*@egen*/
	t="break" { jjtn000.setPos(t.getPos()); }
    [ Identifier() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ContinueStatement() :
{/*@bgen(jjtree) ContinueStatement */
  ASTContinueStatement jjtn000 = new ASTContinueStatement(JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ContinueStatement */
        try {
/*@egen*/
	t="continue" { jjtn000.setPos(t.getPos()); }
    [ Identifier() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReturnStatement() :
{/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReturnStatement */
        try {
/*@egen*/
	t="return" { jjtn000.setPos(t.getPos()); }
    [ ExpressionNT(null) ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ThrowStatement() :
{/*@bgen(jjtree) ThrowStatement */
  ASTThrowStatement jjtn000 = new ASTThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ThrowStatement */
        try {
/*@egen*/
	t="throw" { jjtn000.setPos(t.getPos()); }
    ExpressionNT(null) ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SynchronizedStatement() :
{/*@bgen(jjtree) SynchronizedStatement */
  ASTSynchronizedStatement jjtn000 = new ASTSynchronizedStatement(JJTSYNCHRONIZEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SynchronizedStatement */
        try {
/*@egen*/
	t="synchronized" { jjtn000.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WithStatement() :
{/*@bgen(jjtree) WithStatement */
  ASTWithStatement jjtn000 = new ASTWithStatement(JJTWITHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) WithStatement */
        try {
/*@egen*/
	t="with" { jjtn000.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TryStatement() :
{/*@bgen(jjtree) TryStatement */
  ASTTryStatement jjtn000 = new ASTTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; ASTModifiers modifiers; }
{/*@bgen(jjtree) TryStatement */
        try {
/*@egen*/
	t="try" { jjtn000.setPos(t.getPos()); }
    Block()
	(
		t="catch"
		"("
		modifiers = Modifiers()
		FormalParameter(modifiers)
		")"
		Block()/*@bgen(jjtree) #CatchInfo( 2) */
                {
                  ASTCatchInfo jjtn001 = new ASTCatchInfo(JJTCATCHINFO);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
                }
/*@egen*/
		{ jjtn001.setPos(t.getPos()); }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/
	)*
	[	t="finally" Block()/*@bgen(jjtree) #FinallyInfo( 1) */
                {
                  ASTFinallyInfo jjtn002 = new ASTFinallyInfo(JJTFINALLYINFO);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002,  1);
                  jjtc002 = false;
                }
/*@egen*/
		{ jjtn002.setPos(t.getPos()); }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  1);
                  }
                }
/*@egen*/
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

