/* Generated By:JJTree: Do not edit this line. ASTEnumDeclaration.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.stdlib.*;
import kiev.vlang.*;

import static kiev.stdlib.Debug.*;

/**
 * $Header: /home/CVSROOT/forestro/kiev/kiev/parser/ASTEnumDeclaration.java,v 1.3.4.1 1999/05/29 21:03:06 max Exp $
 * @author Maxim Kizub
 * @version $Revision: 1.3.4.1 $
 *
 */

public class ASTEnumDeclaration extends ASTTypeDeclaration {
	
	
	ASTEnumFieldDeclaration[] enum_fields = new ASTEnumFieldDeclaration[0];
	
	public ASTEnumDeclaration(int id) {
		super(0);
	}

	public void jjtAddChild(ASTNode n, int i) {
		if( n instanceof ASTModifiers) {
			modifiers = (ASTModifiers)n;
		}
        else if( n instanceof ASTIdentifier ) {
			name = ((ASTIdentifier)n).name;
			pos = n.getPos();
		}
        else if( n instanceof ASTExtends ) {
			ext = n;
		}
        else if( n instanceof ASTEnumFieldDeclaration ) {
			enum_fields = (ASTEnumFieldDeclaration[])Arrays.append(enum_fields,n);
		}
        else {
			members = (ASTNode[])Arrays.append(members,n);
        }
    }

	public ASTNode pass1() {
		trace(Kiev.debugResolve,"Pass 1 for enum "+name);
		Struct sup = null;
		Struct[] impls = Struct.emptyArray;
		// TODO: check flags for structures
		int flags = modifiers.getFlags();
		KString short_name = this.name;
		ClazzName clname = null;
		if( this.name != null ) {
			boolean isTop = (parent != null && parent instanceof ASTFileUnit);
			clname = ClazzName.fromOuterAndName(PassInfo.clazz,short_name,false,!isTop);
		}

        flags |= ACC_ENUM;

		me = Env.newStruct(clname,PassInfo.clazz/*,sup*/,flags,true);
		me.setResolved(true);
		if( !(parent instanceof ASTFileUnit) ) me.setStatic(true);
		if( parent instanceof ASTFileUnit || parent instanceof ASTTypeDeclaration ) {
			Env.setProjectInfo(me.name,((ASTFileUnit)Kiev.k.getJJTree().rootNode()).filename);
		}
		SourceFileAttr sfa = new SourceFileAttr(Kiev.curFile);
		me.addAttr(sfa);
		me.setEnum(true);

        PassInfo.push(me);
        try {
			/* Then may be class arguments - they are proceed here, but their
			   inheritance - at pass2()
			*/
			// TODO: decide if inner classes's argumets have to be arguments of outer classes
			/* Generate type for this structure */
			me.type = Type.newJavaRefType(me);

        	// No inner classes and cases for enum
		} finally { PassInfo.pop(me); }

		return me;
	}

	public ASTNode pass2() {
		trace(Kiev.debugResolve,"Pass 2 for enum "+me);
        PassInfo.push(me);
        try {
		} finally { PassInfo.pop(me); }

		return me;
	}

	public ASTNode pass2_2() {
		trace(Kiev.debugResolve,"Pass 2_2 for enum "+me);
        PassInfo.push(me);
        try {
			/* Now, process 'extends' and 'implements' clauses */
			ASTNonArrayType at;
			if( ext != null ) {
				ASTExtends exts = (ASTExtends)ext;
				at = (ASTNonArrayType)exts.children[0];
				me.super_clazz = at.getType();
			}
			if( me.super_clazz == null ) {
				me.super_clazz = Type.tpEnum;
			}

			if( !me.super_clazz.isReference() ) {
				me.setPrimitiveEnum(true);
				me.type.setMeAsPrimitiveEnum();
			}

			if( modifiers.acc != null ) me.acc = new Access(modifiers.acc.accflags);

		} finally { PassInfo.pop(me); }

		return me;
	}

	public static Struct createMembers(Struct me, ASTEnumFieldDeclaration[] enum_fields, ASTNode[] members) {
		trace(Kiev.debugResolve,"Pass 3 for enum "+me);
        PassInfo.push(me);
        try {
			// Process members
			int next_val = 0;
			for(int i=0; i < enum_fields.length; i++, next_val++) {
				ASTEnumFieldDeclaration efd = (ASTEnumFieldDeclaration)enum_fields[i];
				efd.parent = me;
				Type me_type = me.type;
				Field f = new Field(me,efd.name.name,me_type,ACC_PUBLIC | ACC_STATIC | ACC_FINAL );
				f.pos = efd.pos;
				f.setEnumField(true);
				f = me.addField(f);
				f.parent = me;
				if (me.isPrimitiveEnum()) {
					if (efd.val != null) {
						if (efd.val.val instanceof Character)
							next_val = ((Character)efd.val.val).charValue();
						else
							next_val = ((Number)efd.val.val).intValue();
					}
					f.init = new ConstExpr(efd.pos,new Integer(next_val));
				} else {
					if (efd.val != null)
						Kiev.reportError(me.pos,"Enum "+me+" is not a primitive enum");
					if (efd.text == null)
						f.init = new NewExpr(f.pos,me.type,new Expr[]{
									new ConstExpr(efd.name.pos,efd.name.name),
									new ConstExpr(efd.pos, new Integer(next_val)),
									new ConstExpr(efd.name.pos,efd.name.name)
						});
					else
						f.init = new NewExpr(f.pos,me.type,new Expr[]{
									new ConstExpr(efd.name.pos,efd.name.name),
									new ConstExpr(efd.pos, new Integer(next_val)),
									new ConstExpr(efd.text.pos, efd.text.val)
						});
				}
				if (efd.text != null)
					f.name.addAlias(KString.from("\""+efd.text.val+"\""));
				f.init.parent = f;
			}
		} finally { PassInfo.pop(me); }

		ASTTypeDeclaration.createMembers(me, members);
		
		return me;
	}

	public void resolveFinalFields(boolean cleanup) {
   	    // Process inner classes and cases
		for(int i=0; i < members.length; i++) {
			if( !(members[i] instanceof ASTImport) ) continue;
			ASTNode imp = ((ASTImport)members[i]).pass2();
			if( imp == null )
				Kiev.reportError(members[i].getPos(),"Imported member "+imp+" not found");
			else if( imp instanceof Field ) {
				if( !imp.isStatic() ) {
					Kiev.reportError(members[i].getPos(),"Imported field "+imp+" must be static");
				} else {
					me.imported = (ASTNode[])Arrays.append(me.imported,imp);
				}
			}
			else if( imp instanceof Method ) {
				if( !imp.isStatic() ) {
					Kiev.reportError(members[i].getPos(),"Imported method "+imp+" must be static");
				} else {
					me.imported = (ASTNode[])Arrays.append(me.imported,imp);
				}
			}
			else if( imp instanceof Struct ) {
				Struct is = (Struct)imp;
				for(int j=0; j < is.fields.length; j++) {
					if( is.fields[j].isStatic() && !is.fields[j].name.equals(KString.Empty) )
						me.imported = (ASTNode[])Arrays.append(me.imported,is.fields[j]);
				}
				for(int j=0; j < is.methods.length; j++) {
					if( is.methods[j].isStatic() )
						me.imported = (ASTNode[])Arrays.append(me.imported,is.methods[j]);
				}
			}
			else
				throw new CompilerException(members[i].getPos(),"Unknown type if imported member: "+imp);
		}
		// Resolve final values of class's fields
		me.resolveFinalFields(cleanup);
	}

}
