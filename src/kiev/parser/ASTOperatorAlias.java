/* Generated By:JJTree: Do not edit this line. ASTOperatorAlias.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.stdlib.*;
import kiev.vlang.*;

import static kiev.stdlib.Debug.*;
import static kiev.vlang.OpTypes.*;
import static kiev.vlang.Operator.*;

/**
 * @author Maxim Kizub
 * @version $Revision$
 *
 */

@node
public final class ASTOperatorAlias extends ASTAlias {
	public static final int	XFIX_UNKNOWN = 0;
	public static final int	XFIX_PREFIX  = 1;
	public static final int	XFIX_POSTFIX = 2;
	public static final int	XFIX_INFIX   = 3;

	public int					prior;
	public int					opmode;
	public KString				image;
	public int					xfix;

	public ASTOperatorAlias() { super(new NodeImpl()); }
	
	public void setImage(ASTNode n) {
		this.pos = n.pos;
		if( n instanceof ASTOperator ) {
			image = ((ASTOperator)n).image;
			return;
		}
		else if( n instanceof ASTIdentifier ) {
			image = ((ASTIdentifier)n).name;
			return;
		}
		throw new CompilerException(n,"Bad operator definition");
	}
	
	public void setMode(NameRef n) {
		opmode = -1;
		KString optype = n.name;
		for(int i=0; i < Operator.orderAndArityNames.length; i++) {
			if( Operator.orderAndArityNames[i].equals(optype) ) {
				opmode = i;
				break;
			}
		}
		if( opmode < 0 )
			throw new CompilerException(n,"Operator mode must be one of "+Arrays.toString(Operator.orderAndArityNames));
		return;
	}
	
	public void setPriority(ConstIntExpr n) {
		prior = n.value;
		if( prior < 0 || prior > 255 )
			throw new CompilerException(n,"Operator priority must have value from 0 to 255");
		pos = n.getPos();
		return;
	}

  	public void set(Token t) {
  		if (t.image.equals("prefix"))		xfix = XFIX_PREFIX;
  		else if (t.image.equals("suffix"))	xfix = XFIX_POSTFIX;
  		else if (t.image.equals("postfix"))	xfix = XFIX_POSTFIX;
  		else if (t.image.equals("infix"))	xfix = XFIX_INFIX;
  		else if (t.image.equals("binary"))	xfix = XFIX_INFIX;
    	else
    		throw new RuntimeException("Bad xfix mode of operator declaration "+t);
	}

    private void checkPublicAccess(Method m) {
    	if( !m.isStatic() ) return;
    	if( m.isPrivate() || m.isProtected() ) return;
    	Struct pkg = (Struct)m.parent;
    	while( pkg != null && !pkg.isPackage() ) pkg = pkg.package_clazz;
    	if( pkg == null || pkg == Env.root ) return;
    	foreach(ASTNode n; pkg.imported; n == m ) return;
    }

	public void attach(ASTNode n) {
		if( !(n instanceof Method) )
			throw new CompilerException(this,"Node of type "+n.getClass()+" cannot be aliased with operator");
		Method m = (Method)n;
		iopt = null;

		if (xfix != XFIX_UNKNOWN) {
			Operator op = null;
			switch (xfix) {
			case XFIX_INFIX:
				op = BinaryOperator.getOperator(image);
				if (op == null)
					throw new CompilerException(this,"Infix operator "+image+" not known");
				opmode = op.mode;
				prior = op.priority;
				break;
			case XFIX_PREFIX:
				op = PrefixOperator.getOperator(image);
				if (op == null)
					throw new CompilerException(this,"Prefix operator "+image+" not known");
				opmode = op.mode;
				prior = op.priority;
				break;
			case XFIX_POSTFIX:
				op = PostfixOperator.getOperator(image);
				if (op == null)
					throw new CompilerException(this,"Postfix operator "+image+" not known");
				opmode = op.mode;
				prior = op.priority;
				break;
			default:
				throw new CompilerException(this,"Internal error: xfix "+xfix+" unknown");
			}
		}

		switch(opmode) {
		case Operator.LFY:
			{
				// Special case fo "[]" and "new" operators
				if( image.equals(nameArrayOp) ) {
					if( m.isStatic() )
						throw new CompilerException(this,"'[]' operator can't be static");
					if( m.type.args.length != 2 )
						throw new CompilerException(this,"Method "+m+" must be virtual and have 2 arguments");
					if( m.type.ret != m.type.args[1] )
						throw new CompilerException(this,"Method "+m+" must return "+m.type.args[1]);
					m.name.addAlias(nameArrayOp);
					if( Kiev.verbose ) System.out.println("Attached operator [] to method "+m);
					return;
				}
				if( image.equals(nameNewOp) ) {
					if( !m.isStatic() )
						throw new CompilerException(this,"'new' operator must be static");
					if( m.type.ret != ((Struct)m.parent).type )
						throw new CompilerException(this,"Method "+m+" must return "+((Struct)m.parent).type);
					m.name.addAlias(nameNewOp);
					if( Kiev.verbose ) System.out.println("Attached operator new to method "+m);
					return;
				}

				Type opret = m.type.ret;
				Type oparg1, oparg2;
				if( prior != Constants.opAssignPriority )
					throw new CompilerException(this,"Assign operator must have priority "+Constants.opAssignPriority);
				if( m.isStatic() )
					throw new CompilerException(this,"Assign operator can't be static");
				else if( !m.isStatic() && m.type.args.length == 1 )
					{ oparg1 = ((Struct)m.parent).type; oparg2 = m.type.args[0]; }
				else
					throw new CompilerException(this,"Method "+m+" must be virtual and have 1 argument");
				AssignOperator op = AssignOperator.newAssignOperator(
					image,m.name.name,null,false
					);
				iopt=new OpTypes();
				op.addTypes(otTheType(opret),otTheType(oparg1),otType(oparg2));
//				m.addAttr(new OperatorAttr(op));
				if( Kiev.verbose ) System.out.println("Attached assign "+op+" to method "+m);
			}
			break;
		case Operator.XFX:
		case Operator.YFX:
		case Operator.XFY:
		case Operator.YFY:
			{
				// Special case fo "[]" and "new" operators
				if( image.equals(nameArrayOp) ) {
					if( m.isStatic() )
						throw new CompilerException(this,"'[]' operator can't be static");
					if( m.type.args.length != 1 )
						throw new CompilerException(this,"Method "+m+" must be virtual and have 1 argument");
					if( m.type.ret == Type.tpVoid )
						throw new CompilerException(this,"Method "+m+" must not return void");
					m.name.addAlias(nameArrayOp);
					if( Kiev.verbose ) System.out.println("Attached operator [] to method "+m);
					return;
				}

				Type opret = m.type.ret;
				Type oparg1, oparg2;
				if( m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 2 )
					{ oparg1 = m.type.args[0]; oparg2 = m.type.args[1]; }
				else if( m.isStatic() && m instanceof RuleMethod && m.type.args.length == 3 )
					{ oparg1 = m.type.args[1]; oparg2 = m.type.args[2]; }
				else if( !m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 1 )
					{ oparg1 = ((Struct)m.parent).type; oparg2 = m.type.args[0]; }
				else if( !m.isStatic() && m instanceof RuleMethod && m.type.args.length == 2 )
					{ oparg1 = ((Struct)m.parent).type; oparg2 = m.type.args[1]; }
				else
					throw new CompilerException(this,"Method "+m+" must have 2 arguments");
				BinaryOperator op = BinaryOperator.newBinaryOperator(
					prior,image,m.name.name,null,Operator.orderAndArityNames[opmode],false
					);
				iopt=new OpTypes();
				op.addTypes(otType(opret),otType(oparg1),otType(oparg2));
//				m.addAttr(new OperatorAttr(op));
				if( Kiev.verbose ) System.out.println("Attached binary "+op+" to method "+m);
			}
			break;
		case Operator.FX:
		case Operator.FY:
			{
				// Special case fo "$cast" operator
				if( image.equals(nameCastOp) ) {
					if( m.isStatic() && m.type.args.length != 1 )
						throw new CompilerException(this,"Static cast method "+m+" must have 1 argument");
					else if( !m.isStatic() && m.type.args.length != 0 )
						throw new CompilerException(this,"Virtual scast method "+m+" must have no arguments");
					if( m.type.ret == Type.tpVoid )
						throw new CompilerException(this,"Method "+m+" must not return void");
					m.name.addAlias(nameCastOp);
					return;
				}

				Type opret = m.type.ret;
				Type oparg;
				if( m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 1 )
					oparg = m.type.args[0];
				else if( m.isStatic() && m instanceof RuleMethod && m.type.args.length == 2 )
					oparg = m.type.args[1];
				else if( !m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 0 )
					oparg = ((Struct)m.parent).type;
				else if( !m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 1 )
					oparg = m.type.args[0];
				else if( !m.isStatic() && m instanceof RuleMethod && m.type.args.length == 1 )
					oparg = ((Struct)m.parent).type;
				else {
					if (m.isStatic())
						throw new CompilerException(this,"Static method "+m+" must have 1 argument");
					else
						throw new CompilerException(this,"Non-static method "+m+" must have 0 or 1 argument");
				}
				PrefixOperator op = PrefixOperator.newPrefixOperator(
					prior,image,m.name.name,null,Operator.orderAndArityNames[opmode],false
					);
				iopt=new OpTypes();
				op.addTypes(otType(opret),otType(oparg));
//				m.addAttr(new OperatorAttr(op));
				if( Kiev.verbose ) System.out.println("Attached prefix "+op+" to method "+m);
			}
			break;
		case Operator.XF:
		case Operator.YF:
			{
				Type opret = m.type.ret;
				Type oparg;
				if( m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 1 )
					oparg = m.type.args[0];
				else if( m.isStatic() && m instanceof RuleMethod && m.type.args.length == 2 )
					oparg = m.type.args[1];
				else if( !m.isStatic() && !(m instanceof RuleMethod) && m.type.args.length == 0 )
					oparg = ((Struct)m.parent).type;
				else if( !m.isStatic() && m instanceof RuleMethod && m.type.args.length == 1 )
					oparg = ((Struct)m.parent).type;
				else
					throw new CompilerException(this,"Method "+m+" must have 1 argument");
				PostfixOperator op = PostfixOperator.newPostfixOperator(
					prior,image,m.name.name,null,Operator.orderAndArityNames[opmode],false
					);
				iopt=new OpTypes();
				op.addTypes(otType(opret),otType(oparg));
//				m.addAttr(new OperatorAttr(op));
				if( Kiev.verbose ) System.out.println("Attached postfix "+op+" to method "+m);
			}
			break;
		case Operator.XFXFY:
			throw new CompilerException(this,"Multioperators are not supported yet");
		default:
			throw new CompilerException(this,"Unknown operator mode "+opmode);
		}
		checkPublicAccess(m);
		iopt.method = m;
		m.setOperatorMethod(true);
	}

	public String toString() {
		return image.toString();
	}

	public Dumper toJava(Dumper dmp) {
		return dmp.space().append("/* alias operator(")
			.append(Integer.toString(prior)).append(",")
			.append(Operator.orderAndArityNames[opmode]).append(",")
			.append(image).append(") */").space();
	}

}
