/* Generated By:JJTree: Do not edit this line. ASTCallAccessExpression.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.vlang.*;
import kiev.stdlib.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 *
 */

@node
@cfnode
public class ASTCallAccessExpression extends Expr {
	@att public ENode					obj;
	@att public ASTIdentifier			func;
    @att public final NArr<ENode>		args;

	public void preResolve() {
		PassInfo.push(this);
		try {
			// pre-resolve 'obj', but check it's not 'super.'
			if (obj != null) {
				if !( obj instanceof ASTIdentifier && ((ASTIdentifier)obj).name.equals(Constants.nameSuper) )
					obj.preResolve();
			}
			// don't pre-resolve 'func'
			;
			// pre-resolve arguments
			foreach (Expr e; args) e.preResolve();
		} finally { PassInfo.pop(this); }
	}
	
	public void resolve(Type reqType) {
		for(int i=0; i < args.length; i++) {
			args[i].resolve(null);
		}
		ASTNode o;
		Type tp = null;
		Type ret = reqType;
	retry_with_null_ret:;
		ASTNode@ m;
		if( obj instanceof ASTIdentifier
		&& ((ASTIdentifier)obj).name.equals(Constants.nameSuper)
		&& !PassInfo.method.isStatic() ) {
			ResInfo info = new ResInfo();
			ThisExpr sup = new ThisExpr();
			info.enterForward(sup);
			info.enterSuper();
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,ret);
			if( !PassInfo.resolveBestMethodR(PassInfo.clazz.super_type,m,info,func.name,mt) ) {
				if( ret != null ) { ret = null; goto retry_with_null_ret; }
				throw new CompilerException(obj.getPos(),"Unresolved method "+Method.toString(func.name,args,ret));
			}
			info.leaveSuper();
			info.leaveForward(sup);
			if( info.isEmpty() ) {
				Method meth = (Method)m;
				CallAccessExpr cae = new CallAccessExpr(pos,sup,meth,args);
				cae.super_flag = true;
				replaceWith(cae);
				meth.makeArgs(cae.args, tp);
				cae.resolve(ret);
				return;
			}
			throw new CompilerException(obj.getPos(),"Super-call via forwarding is not allowed");
		} else {
			obj.resolve(null);
		try_static:
			if( o instanceof Struct ) {
				((Struct)o).checkResolved();
				o = new TypeRef(((Struct)o).type);
			}
			if( o instanceof TypeRef ) {
				tp = ((TypeRef)o).getType();
				Type[] ta = new Type[args.length];
				for (int i=0; i < ta.length; i++)
					ta[i] = args[i].getType();
				MethodType mt = MethodType.newMethodType(null,ta,ret);
				ResInfo info = new ResInfo(ResInfo.noForwards|ResInfo.noImports);
				if( !PassInfo.resolveBestMethodR(tp,m,info,func.name,mt) ) {
					// May be a closure
					ASTNode@ closure;
					info = new ResInfo();
					if( !tp.resolveStaticNameR(closure,info,func.name) ) {
						if( ret != null ) { ret = null; goto retry_with_null_ret; }
						throw new CompilerException(pos,"Unresolved method "+Method.toString(func.name,args,ret));
					}
					try {
						if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
						||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
						) {
							ENode call = info.buildCall(pos, null, closure, args.toArray());
							replaceWithResolve(call, ret);
							return;
						}
					} catch(Exception eee) {
						Kiev.reportError(pos,eee);
					}
					if( ret != null ) { ret = null; goto retry_with_null_ret; }
					throw new CompilerException(pos,"Method "+Method.toString(func.name,mt)+" unresolved in "+tp);
				}
				if( !m.isStatic() )
					throw new CompilerException(pos,"Static call to non-static method");
				Method meth = (Method)m;
				CallExpr ce = new CallExpr(pos,meth,args);
				replaceWith(ce);
				meth.makeArgs(ce.args,tp);
				ce.resolve(ret);
				return;
			}
			else if( o instanceof Expr) {
				Type[] snitps = null;
				int snitps_index = 0;
				snitps = ((Expr)o).getAccessTypes();
				tp = snitps[snitps_index++];
				if (tp.isWrapper() && func.name.byteAt(0) != '$') {
					obj = tp.makeWrappedAccess(o);
					obj.resolve(null);
					tp = obj.getType();
				}
				if( reqType instanceof CallableType ) ret = null;
				if( tp.isReference() ) {
			retry_resolving:;
					Type[] ta = new Type[args.length];
					for (int i=0; i < ta.length; i++)
						ta[i] = args[i].getType();
					MethodType mt = MethodType.newMethodType(null,ta,ret);
					ResInfo info = new ResInfo(ResInfo.noStatic|ResInfo.noImports);
					if( !PassInfo.resolveBestMethodR(tp,m,info,func.name,mt) ) {
						// May be a closure
						ASTNode@ closure;
						info = new ResInfo();
						if( !tp.resolveNameAccessR(closure,info,func.name) ) {
							if( o instanceof Expr && snitps != null ) {
								if( snitps_index < snitps.length ) {
									tp = snitps[snitps_index++];
//									cl = (Struct)tp.clazz;
									goto retry_resolving;
								}
							}
							if( ret != null ) { ret = null; goto retry_with_null_ret; }
							o = new TypeRef(o.getType());
							goto try_static;
							//throw new CompilerException(pos,"Unresolved method "+Method.toString(func.name,args,ret)+" in "
							//	+(snitps==null?tp.toString():Arrays.toString(snitps)) );
						}
						try {
							if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
							||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
							) {
								ENode call = info.buildCall(pos, obj, closure, args.toArray());
								replaceWithResolve(call, ret);
								return;
							}
						} catch(Exception eee) {
							Kiev.reportError(pos,eee);
						}
						if( ret != null ) { ret = null; goto retry_with_null_ret; }
						o = new TypeRef(o.getType());
						goto try_static;
//						throw new CompilerException(pos,"Method "+Method.toString(func.name,args,reqType)+" unresolved in "+tp);
					}
					if( reqType instanceof CallableType ) {
						ASTAnonymouseClosure ac = new ASTAnonymouseClosure();
						ac.pos = pos;
						ac.parent = parent;
						ac.rettype = new TypeRef(pos, ((CallableType)reqType).ret);
						Method meth = (Method)m;
						for(int i=0; i < meth.type.args.length; i++) {
							ac.params.add(new FormPar(pos,KString.from("arg"+(i+1)),((Method)m).type.args[i],0));
						}
						BlockStat bs = new BlockStat(pos,ac,ENode.emptyArray);
						ENode[] oldargs = args.toArray();
						ENode[] cargs = new ENode[ac.params.length];
						for(int i=0; i < cargs.length; i++)
							cargs[i] = new VarAccessExpr(pos,this,(Var)ac.params[i]);
						args.delAll();
						foreach (Expr e; cargs)
							args.add(e);
						if( ac.rettype.getType() == Type.tpVoid ) {
							bs.addStatement(new ExprStat(pos,bs,this));
							bs.addStatement(new ReturnStat(pos,bs,null));
						} else {
							bs.addStatement(new ReturnStat(pos,bs,this));
						}
						ac.body = bs;
						if( oldargs.length > 0 ) {
							ac.resolve(reqType);
							replaceWithResolve(new ClosureCallExpr(pos,ac,oldargs), reqType);
						} else {
							replaceWithResolve(ac, reqType);
						}
						return;
					} else {
						Method meth = (Method)m;
						ENode call = info.buildCall(pos, obj, meth, args.toArray());
						replaceWithResolve(call, ret);
						return;
					}
				} else {
					throw new CompilerException(obj.getPos(),"Resolved object "+obj+" of type "+tp+" is not a scope");
				}
			} else {
				throw new CompilerException(obj.getPos(),"Resolved object "+obj+" is not an object");
			}
		}
	}

	public int		getPriority() { return Constants.opCallPriority; }

	public String toString() {
		StringBuffer sb = new StringBuffer();
    	sb.append(obj).append('.').append(func).append('(');
		for(int i=0; i < args.length; i++) {
			sb.append(args[i]);
			if( i < args.length-1 )
				sb.append(',');
		}
		return sb.append(')').toString();
	}

	public Dumper toJava(Dumper dmp) {
    	dmp.append(obj).append('.').append(func).append('(');
		for(int i=0; i < args.length; i++) {
			args[i].toJava(dmp);
			if( i < args.length-1 )
				dmp.append(',');
		}
		return dmp.append(')');
	}
}
