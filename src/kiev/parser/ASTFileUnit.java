/* Generated By:JJTree: Do not edit this line. ASTFileUnit.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.Kiev.Ext;
import kiev.stdlib.*;
import kiev.vlang.*;

import static kiev.stdlib.Debug.*;

/**
 * @author Maxim Kizub
 *
 */

public class ASTFileUnit extends ASTNode implements TopLevelDecl {
	public KString	filename;
	public FileUnit	file_unit;
	public static PrescannedBody[] emptyArray = new PrescannedBody[0];

    public ASTNode			pkg;
    public ASTNode[]		syntax = ASTNode.emptyArray;
    public ASTNode[]		decls  = new ASTNode[0];
	public PrescannedBody[]	bodies = PrescannedBody.emptyArray;
	
	public boolean[]		disabled_extensions;

	ASTFileUnit(int id) {
		super(0);
		disabled_extensions = Kiev.getCmdLineExtSet();
	}

	public void setFileName(String fn) {
		filename = KString.from(fn);
	}

	public void addPrescannedBody(PrescannedBody b) {
		bodies = (PrescannedBody[])Arrays.append(bodies,b);
	}

	public void jjtAddChild(ASTNode n, int i) {
		n.parent = this;
		if( n instanceof ASTPackage) {
			pkg = n;
		}
		else if( n instanceof ASTImport || n instanceof ASTTypedef || n instanceof ASTOpdef || n instanceof ASTPragma) {
			syntax = (ASTNode[])Arrays.append(syntax,n);
			// Check disabled extensions very early
			if (n instanceof ASTPragma) {
				foreach (ASTConstExpression e; ((ASTPragma)n).options)
					setExtension(e.pos,((ASTPragma)n).enable,((KString)e.val).toString());
			}
		}
		else {
			decls = (ASTNode[])Arrays.append(decls,n);
		}
    }

	private void setExtension(int pos, boolean enabled, String s) {
		Ext ext;
		try {
			ext = Ext.fromString(s);
		} catch(RuntimeException e) {
			Kiev.reportWarning(pos,"Unknown pragma '"+s+"'");
			return;
		}
		int i = ((int)ext)-1;
		if (enabled && Kiev.getCmdLineExtSet()[i])
			Kiev.reportError(pos,"Extension '"+s+"' was disabled from command line");
		disabled_extensions[i] = !enabled;
	}

//	public ASTNode pass1(ASTNode pn) {
//		KString oldfn = Kiev.curFile;
//		Kiev.curFile = filename;
//		boolean[] exts = Kiev.getExtSet();
//		try {
//			Kiev.setExtSet(disabled_extensions);
//			if( pkg != null ) {
//				pkg = (Struct)((ASTPackage)pkg).pass1(null);
//			} else {
//				pkg = Env.root;
//			}
//			file_unit = new FileUnit(filename,(Struct)pkg);
//			file_unit.disabled_extensions = disabled_extensions;
//			file_unit.bodies = bodies;
//			PassInfo.push(pkg);
//			try {
//				for(int i=0; i < decls.length; i++) {
//					try {
//						file_unit.members.add((Struct)decls[i].pass1(file_unit));
//					} catch(Exception e ) {
//						Kiev.reportError/*Warning*/(((ASTNode)decls[i]).getPos(),e);
//					}
//				}
//			} finally { PassInfo.pop(pkg); }
//			return file_unit;
//		} finally { Kiev.curFile = oldfn; Kiev.setExtSet(exts); }
//	}

//	public ASTNode pass1_1(ASTNode pn) {
//		KString oldfn = Kiev.curFile;
//		Kiev.curFile = filename;
//		PassInfo.push(file_unit);
//		boolean[] exts = Kiev.getExtSet();
//		try {
//        	Kiev.setExtSet(disabled_extensions);
//        	if (syntax.length > 0) file_unit.syntax = new ASTNode[syntax.length];
//
//			// Process file imports...
//			boolean java_lang_found = false;
//			KString java_lang_name = KString.from("java.lang");
//			boolean kiev_stdlib_found = false;
//			KString kiev_stdlib_name = KString.from("kiev.stdlib");
//
//			for(int i=0; i < syntax.length; i++) {
//				try {
//					ASTNode n = (ASTNode)syntax[i];
//					if (n instanceof ASTImport && ((ASTImport)n).mode == ASTImport.IMPORT_STATIC && !((ASTImport)n).star) {
//						continue; // process later
//					}
//					n = ((TopLevelDecl)syntax[i]).pass1_1(file_unit);
//					file_unit.syntax[i] = n;
//					if (n instanceof Import) {
//						if( n.mode == Import.IMPORT_CLASS && ((Struct)n.node).name.name.equals(java_lang_name))
//							java_lang_found = true;
//						else if( n.mode == Import.IMPORT_CLASS && ((Struct)n.node).name.name.equals(kiev_stdlib_name))
//							kiev_stdlib_found = true;
//					}
//					trace(Kiev.debugResolve,"Add "+n);
//				} catch(Exception e ) {
//					Kiev.reportError/*Warning*/(syntax[i].getPos(),e);
//				}
//			}
//			// Add standard imports, if they were not defined
//			if( !Kiev.javaMode && !kiev_stdlib_found )
//				file_unit.syntax = (ASTNode[])Arrays.append(file_unit.syntax,new Import(0,file_unit,Env.newPackage(kiev_stdlib_name),Import.IMPORT_CLASS,true));
//			if( !java_lang_found )
//				file_unit.syntax = (ASTNode[])Arrays.append(file_unit.syntax,new Import(0,file_unit,Env.newPackage(java_lang_name),Import.IMPORT_CLASS,true));
//
//			// Process members - pass1_1()
//			for(int j=0; j < decls.length; j++) {
//				decls[j].pass1_1(file_unit);
//			}
//		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
//		return file_unit;
//	}

	public ASTNode pass2(ASTNode pn) {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - pass2()
			for(int j=0; j < decls.length; j++) {
				file_unit.members[j] = (Struct)decls[j].pass2(file_unit);
				file_unit.members[j].parent = file_unit;
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}

	public ASTNode pass2_2(ASTNode pn) {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - pass2_2()
			for(int j=0; j < decls.length; j++) {
				file_unit.members[j] = (Struct)decls[j].pass2_2(file_unit);
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}


	public ASTNode pass3() {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - pass3()
			for(int i=0; i < decls.length; i++) {
				switch(decls[i]) {
				case ASTTypeDeclaration:
					file_unit.members[i] = (Struct)((ASTTypeDeclaration)decls[i])
						.pass3(((ASTTypeDeclaration)decls[i]).me,((ASTTypeDeclaration)decls[i]).members);
					break;
				case ASTEnumDeclaration:
					file_unit.members[i] = (Struct)((ASTEnumDeclaration)decls[i])
						.pass3(((ASTEnumDeclaration)decls[i]).me,((ASTEnumDeclaration)decls[i]).members);
					break;
				//case ASTPackageDeclaration:
				//	file_unit.members[i] = (Struct)((ASTPackageDeclaration)decls[i])
				//		.pass3(((ASTPackageDeclaration)decls[i]).me,((ASTPackageDeclaration)decls[i]).members);
				//	break;
				case ASTSyntaxDeclaration:
					file_unit.members[i] = (Struct)((ASTSyntaxDeclaration)decls[i])
						.pass3(((ASTSyntaxDeclaration)decls[i]).me,((ASTSyntaxDeclaration)decls[i]).members);
					break;
				default:
					throw new CompilerException(((ASTNode)decls[i]).pos,"Unknown type of file declaration "+decls[i].getClass());
				}
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}

	public ASTNode autoProxyMethods() {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - pass3()
			for(int i=0; i < decls.length; i++) {
				decls[i].autoProxyMethods();
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}

	public ASTNode resolveImports() {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - pass3()
			for(int i=0; i < syntax.length; i++) {
				if (syntax[i] != null)
					continue; // processed at pass2
				try {
					ASTImport n = (ASTImport)syntax[i];
					Debug.assert(n.mode == ASTImport.IMPORT_STATIC && !n.star);
					file_unit.syntax[i] = n.pass2(file_unit);
					trace(Kiev.debugResolve,"Add "+file_unit.syntax[i]);
				} catch(Exception e ) {
					Kiev.reportError/*Warning*/(syntax[i].getPos(),e);
				}
			}
			for(int i=0; i < decls.length; i++) {
				try {
					decls[i].resolveImports();
				} catch(Exception e ) {
					Kiev.reportError/*Warning*/(((ASTNode)decls[i]).getPos(),e);
				}
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}

	public ASTNode resolveFinalFields(boolean cleanup) {
		KString oldfn = Kiev.curFile;
		Kiev.curFile = filename;
		PassInfo.push(file_unit);
		boolean[] exts = Kiev.getExtSet();
        try {
        	Kiev.setExtSet(disabled_extensions);
			// Process members - resolveFinalFields()
			for(int i=0; i < decls.length; i++) {
				decls[i].resolveFinalFields(cleanup);
			}
		} finally { Kiev.setExtSet(exts); PassInfo.pop(file_unit); Kiev.curFile = oldfn; }
		return file_unit;
	}

	public Dumper toJava(Dumper dmp) {
    	return file_unit.toJava(dmp);
	}
}
