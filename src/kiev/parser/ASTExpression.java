/* Generated By:JJTree: Do not edit this line. ASTExpression.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.vlang.*;
import kiev.stdlib.*;

import static kiev.stdlib.Debug.*;

typedef kiev.stdlib.List<kiev.vlang.ASTNode>		ListAN;
typedef kiev.stdlib.List.Cons<kiev.vlang.ASTNode>	ConsAN;

/**
 * $Header: /home/CVSROOT/forestro/kiev/kiev/parser/ASTExpression.java,v 1.3.4.2 1999/05/29 21:03:06 max Exp $
 * @author Maxim Kizub
 * @version $Revision: 1.3.4.2 $
 *
 */

public class ASTExpression extends Expr {
	public List<ASTNode>		nodes = List.Nil;


	public ASTExpression(int id) {
		super(0);
		setPos(0);
	}

	public ASTExpression(int pos, List<ASTNode> nodes) {
		super(pos);
		this.nodes = nodes;
		pos = nodes.at(0).pos;
	}

	public void jjtAddChild(ASTNode n, int i) {
		nodes = nodes.concat(n);
		if( i == 0 || pos == 0 ) setPos(n.getPos());
    }

	public ASTNode resolve(Type reqType) {
		PassInfo.push(this);
		try {
	//		nodes = preresolve(nodes);
			List<ASTNode> results = List.Nil;
			PVar<ASTNode> result = new PVar<ASTNode>();
			PVar<List<ASTNode>> rest = new PVar<List<ASTNode>>();
			boolean may_be_resolved = false;
			trace( Kiev.debugOperators, "Expression: "+nodes);
			NodeInfoPass.pushState();
			try {
				foreach( resolveExpr(result,nodes,rest,0,may_be_resolved) ) {
					trace( Kiev.debugOperators, (may_be_resolved?"WARNING: ":"")+"May be resolved as: "+result+" and rest is "+rest);
					Expr res = null;
					if( (res = ((Expr)result.$var).tryResolve(reqType)) == null ) {
						trace( Kiev.debugOperators, "WARNING: full resolve of "+result+" to type "+reqType+" fails");
						continue;
					}
					may_be_resolved = true;
					trace( Kiev.debugOperators, "Add possible resolved expression: "+res);
					results = new List.Cons<ASTNode>(res.resolve(reqType),results);
				}
			} catch(Exception e ) {
				if( ! may_be_resolved )
				Kiev.reportError(pos,e);
			} finally {
				NodeInfoPass.popState();
			}
			if( ! may_be_resolved )
				throw new CompilerException(pos, "unresolved expression: "+this);
			if( results.head() instanceof Expr )
				return ((Expr)results.head()).resolve(reqType);
			else
				return results.head();
		} finally { PassInfo.pop(this); }
	}

	/**
	 *  @param result	- output result of parsing
	 *  @param expr		- input list of subexpressions and operators
	 *  @param rest		- output rest of list (uprased yet part)
	 */

	public rule resolveExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
		pvar List<ASTNode>	expr1;
	{
		trace( Kiev.debugOperators, "resolving "+expr+" with priority "+priority),
		expr.length() > 1,
		{
			resolveCastExpr		(result1, expr, rest1, priority, may_be_resolved)
		;	resolvePrefixExpr	(result1, expr, rest1, priority, may_be_resolved)
		;	resolvePostfixExpr	(result1, expr, rest1, priority, may_be_resolved)
		;	resolveMultiExpr	(result1, expr, rest1, priority, may_be_resolved)
		;	resolveAssignExpr	(result1, expr, rest1, priority, may_be_resolved)
		;	resolveBinaryExpr	(result1, expr, rest1, priority, may_be_resolved)
		},
		{
			rest1.$var != null,
			expr1 ?= new List.Cons<ASTNode>(result1,rest1)
		;
			rest1.$var == null,
			expr1 ?= new List.Cons<ASTNode>(result1,List.Nil)
		},
		trace( Kiev.debugOperators, "partially resolved as "+expr1),
		resolveExpr(result, expr1, rest, priority, may_be_resolved),
		trace( Kiev.debugOperators, "return expr "+result+" and rest "+rest)
	;
		expr.length() > 1 && priority > 0,
		trace( Kiev.debugOperators, "check that "+expr.head()+" is an expression ("+(expr.head() instanceof Expr)+") and has priority >= "+priority),
		expr.head() instanceof Expr && ((Expr)expr.head()).getPriority() >= priority,
		trace( Kiev.debugOperators, "return expr "+expr.head()+" and rest "+expr.tail()),
		result ?= expr.head(),
		rest.$var = expr.tail()
	;
		expr.length() == 1,
		result ?= expr.head(),
		rest.$var = expr.tail()
//	;
//		!may_be_resolved,
//		throwResolveError(expr.head().pos,"resolve error")
	}

	void throwResolveError(int p, String msg) {
		throw new CompilerException(pos,msg);
	}

	rule resolveCastExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
	{
		Constants.opCastPriority >= priority,
		expr.length() > 1,
		expr.head() instanceof ASTCastOperator,
		op ?= ((ASTCastOperator)expr.head()).resolveOperator(),
		trace( Kiev.debugOperators, "trying cast "+op),
		resolveExpr(result1,expr.tail(),rest1,Constants.opCastPriority, may_be_resolved),
		result ?= new CastExpr(expr.head().pos,((CastOperator)op.$var).type,getExpr(result1),false,((CastOperator)op.$var).reinterp),
		trace( Kiev.debugOperators, "found cast "+result),
		rest.$var = rest1.$var
	}

	rule resolvePrefixExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
	{
		expr.length() > 1,
		{
			expr.head() instanceof ASTOperator,
			op ?= PrefixOperator.getOperator(((ASTOperator)expr.head()).image)
		;	expr.head() instanceof ASTIdentifier,
			op ?= PrefixOperator.getOperator(((ASTIdentifier)expr.head()).name),
			trace( Kiev.debugOperators,"identifier as operator: "+op)
		},
		op.priority >= priority,
		trace( Kiev.debugOperators, "trying prefix "+op),
		resolveExpr(result1,expr.tail(),rest1,op.getArgPriority(0), may_be_resolved),
		result ?= new UnaryExpr(expr.head().pos,op,getExpr(result1)),
		trace( Kiev.debugOperators, "found prefix "+result),
		rest.$var = rest1.$var
	}

	rule resolvePostfixExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
	{
		expr.length() > 1,
		{
			expr.tail().head() instanceof ASTOperator,
			op ?= PostfixOperator.getOperator(((ASTOperator)expr.tail().head()).image)
		;	expr.tail().head() instanceof ASTIdentifier,
			op ?= PostfixOperator.getOperator(((ASTIdentifier)expr.tail().head()).name),
			trace( Kiev.debugOperators,"identifier as operator: "+op)
		},
		op.priority >= priority,
		getPriority(expr.head()) >= op.getArgPriority(0),
		trace( Kiev.debugOperators, "trying postfix "+op),
		result ?= new UnaryExpr(expr.tail().head().pos,op,getExpr(expr.head())),
		trace( Kiev.debugOperators, "found postfix "+result),
		rest.$var = expr.tail().tail()
	}

	rule resolveBinaryExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
	{
		expr.length() > 2,
		expr.head() instanceof Expr,
		{
			expr.tail().head() instanceof ASTOperator,
			op ?= BinaryOperator.getOperator(((ASTOperator)expr.tail().head()).image)
		;	expr.tail().head() instanceof ASTIdentifier,
			op ?= BinaryOperator.getOperator(((ASTIdentifier)expr.tail().head()).name),
			trace( Kiev.debugOperators,"identifier as operator: "+op)
		},
		op.priority >= priority,
		trace( Kiev.debugOperators, "trying binary "+op),
		getPriority(expr.head()) >= op.getArgPriority(0),
		{
			op ?= BinaryOperator.InstanceOf, $cut,	expr.at(2) instanceof ASTType,
			result ?= new InstanceofExpr(expr.at(1).getPos(),(Expr)expr.head(),((ASTType)expr.at(2)).pass2()),
			rest1 ?= expr.tail().tail().tail()
		;	resolveExpr(result1,expr.tail().tail(),rest1,op.getArgPriority(1), may_be_resolved),
			{
				((BinaryOperator)op.$var).is_boolean_op, $cut,
				result ?= new BinaryBooleanExpr(expr.tail().head().pos,(BinaryOperator)op.$var,getExpr(expr.head()),getExpr(result1))
			;	!((BinaryOperator)op.$var).is_boolean_op, $cut,
				result ?= new BinaryExpr(expr.tail().head().pos,(BinaryOperator)op.$var,getExpr(expr.head()),getExpr(result1))
			}
		},
		trace( Kiev.debugOperators, "found binary "+result+" and rest is "+rest1),
		rest.$var = rest1.$var
	}

	rule resolveAssignExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar ASTNode		result1;
		pvar List<ASTNode>	rest1;
	{
		expr.length() > 2,
		expr.head() instanceof Expr,
		{
			expr.tail().head() instanceof ASTOperator,
			op ?= AssignOperator.getOperator(((ASTOperator)expr.tail().head()).image)
		;	expr.tail().head() instanceof ASTIdentifier,
			op ?= AssignOperator.getOperator(((ASTIdentifier)expr.tail().head()).name),
			trace( Kiev.debugOperators,"identifier as operator: "+op)
		},
		op.priority >= priority,
		trace( Kiev.debugOperators, "trying assign "+op),
		getPriority(expr.head()) >= op.getArgPriority(0),
		resolveExpr(result1,expr.tail().tail(),rest1,op.getArgPriority(1), may_be_resolved),
		result ?= new AssignExpr(expr.tail().head().pos,(AssignOperator)op.$var,getExpr(expr.head()),getExpr(result1)),
		trace( Kiev.debugOperators, "found assign "+result+" and rest is "+rest1),
		rest.$var = rest1.$var
	}

	rule resolveMultiExpr(pvar ASTNode result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, int priority, boolean may_be_resolved)
		pvar Operator		op;
		pvar List<ASTNode>	result1;
		pvar List<ASTNode>	rest1;
	{
		expr.length() > 2,
		{
			expr.tail().head() instanceof ASTOperator,
			op ?= MultiOperator.getOperator(((ASTOperator)expr.tail().head()).image)
		;	expr.tail().head() instanceof ASTIdentifier,
			op ?= MultiOperator.getOperator(((ASTIdentifier)expr.tail().head()).name),
			trace( Kiev.debugOperators,"identifier as operator: "+op)
		},
		op.priority >= priority,
		getPriority(expr.head()) >= op.getArgPriority(0),
		resolveMultiExpr((MultiOperator)op.$var,1,result1,expr.tail().tail(),rest1, may_be_resolved),
		result ?= new MultiExpr(expr.tail().head().pos,(MultiOperator)op.$var,new ConsAN(expr.head(),result1)),
		rest.$var = rest1.$var
	}

	rule resolveMultiExpr(MultiOperator op, int n, pvar List<ASTNode> result, pvar List<ASTNode> expr, pvar List<ASTNode> rest, boolean may_be_resolved)
		pvar ASTNode		result1;
		pvar List<ASTNode>	result2;
		pvar List<ASTNode>	rest1;
		pvar List<ASTNode>	rest2;
	{
		resolveExpr(result1,expr,rest1,op.getArgPriority(n), may_be_resolved),
		{
			n == op.images.length,
			rest.$var = rest1.$var,
			result ?= new ConsAN(result1,List.Nil)
		;
			n < op.images.length,
			rest1.length() > 0,
			{
				rest1.head() instanceof ASTOperator,
				op.images[n].equals(((ASTOperator)rest1.head()).image)
			;	rest1.head() instanceof ASTIdentifier,
				op.images[n].equals(((ASTIdentifier)rest1.head()).name)
			},
			resolveMultiExpr(op,n+1,result2,rest1.tail(),rest2, may_be_resolved),
			rest.$var = rest2.$var,
			result ?= new ConsAN(result1,result2)
		}
	}

	public int getPriority(Object:Object expr) {
		return 256;
	}

	public int getPriority(ASTExpression:Object expr) {
		return 256;
	}

	public int getPriority(Expr:Object expr) {
		return expr.getPriority();
	}

	public Expr getExpr(Expr:Object expr) {
		return expr;
	}

	public Expr getExpr(PVar<Object>:Object expr) {
		return getExpr(expr.$var);
	}

	public Expr getExpr(Struct:Object expr) {
		return new WrapedExpr(expr.pos,expr);
	}

	public Expr getExpr(Type:Object expr) {
		return new WrapedExpr(expr.pos,expr);
	}

	public Expr getExpr(Object:Object expr) {
		throw new CompilerException(pos,"Node of type "+expr.getClass()+" cannot be an expression");
	}

/*
	rule resolveE(pvar List<ASTNode> ln, int priority, Type tp)
		pvar List<ASTNode> ln1;
		pvar Operator op;
		pvar OpTypes opt;
		pvar ASTNode expr;
		pvar Method opm;
	{
		trace( Kiev.debugOperators,"resolving "+ln+" with pr="+priority+" to be of type "+(tp==null?"<any>":tp.toString())),
		{
			ln.length() > 1,
			ln.at(0) instanceof ASTCastOperator,
			op ?= ((ASTCastOperator)ln.head()).resolveOperator(),
			op.priority >= priority,
			ln1.$var = ln.tail(),
			resolveE(ln1,op.getArgPriority(),((CastOperator)op.$var).type),
			ln.$var = new List.Cons<ASTNode>(
				(Expr)new CastExpr(ln.head().pos,((CastOperator)op.$var).type,(Expr)ln1.head(),true
				).resolve(tp),
				ln1.tail()
			),
			$cut,
			trace( Kiev.debugOperators,"resolved cast "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() > 1,
			{
				ln.at(0) instanceof ASTOperator,
				op ?= PrefixOperator.getOperator(((ASTOperator)ln.at(0)).image)
			;	ln.at(0) instanceof ASTIdentifier,
				op ?= PrefixOperator.getOperator(((ASTIdentifier)ln.at(0)).name),
				trace( Kiev.debugOperators,"identifier as operator: "+op)
			},
			op.priority >= priority,
			ln1.$var = ln.tail(),
			trace( Kiev.debugOperators,"trying prefix "+op+" to be of type "+(tp==null?"<any>":tp.toString())),
			resolveE(ln1,op.getArgPriority(),tp),
			opt @= op.types,
			opt.match(new ASTNode[]{null,ln1.head()}),
			{
				opm ?= opt.method,
				{
					opm.$var.isStatic(),
					expr ?= new CallExpr(ln.at(0).getPos(),opm.$var,new Expr[]{(Expr)ln1.head()}).resolve(tp)
				;
					!opm.$var.isStatic(),
					expr ?= new CallAccessExpr(ln.at(0).getPos(),(Expr)ln1.head(),opm.$var,Expr.emptyArray).resolve(tp)
				}
			;
				expr ?= new UnaryExpr(ln.at(0).getPos(),op,(Expr)ln1.head()).resolve(tp)
			},
			ln.$var = new List.Cons<ASTNode>(expr.$var,ln1.tail()),
			$cut,
			trace( Kiev.debugOperators,"resolved prefix "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() > 1,
			canBeAnExpr(ln),
			ln.at(1) instanceof ASTOperator,
			op ?= PostfixOperator.getOperator(((ASTOperator)ln.at(1)).image),
			op.priority >= priority,
			trace( Kiev.debugOperators,"trying postfix "+op+" to be of type "+(tp==null?"<any>":tp.toString())),
			expr ?= ((Expr)ln.head()).resolve(tp),
			opt @= op.types,
			opt.match(new ASTNode[]{null,expr.$var}),
			ln.$var = new List.Cons<ASTNode>(
				(Expr)new UnaryExpr(
					ln.at(1).getPos(),op,(Expr)expr.$var
				).resolve(tp),
				ln.tail().tail()
			),
			$cut,
			trace( Kiev.debugOperators,"resolved postfix "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() > 4,
			canBeAnExpr(ln),
			ln.at(1) instanceof ASTOperator,
			op ?= MultiOperator.getOperator(((ASTOperator)ln.at(1)).image),
			op.priority >= priority,
			trace( Kiev.debugOperators,"trying multi "+op+" to be of type "+(tp==null?"<any>":tp.toString())),
			checkMultiOperator(ln,tp,(MultiOperator)op.$var),
			$cut,
			trace( Kiev.debugOperators,"resolved assign "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() > 2,
			canBeAnExpr(ln),
			ln.at(1) instanceof ASTOperator,
			op ?= AssignOperator.getOperator(((ASTOperator)ln.at(1)).image),
			op.priority >= priority,
			{
				ln.head() instanceof LvalueExpr
			;	!ln.head().isResolved(),
				expr ?= ((Expr)ln.head()).resolve(tp),
				expr.$var instanceof LvalueExpr,
				ln.$var = new List.Cons<ASTNode>(expr.$var,ln.tail())
			},
			ln1 ?= ln.tail().tail(),
			trace( Kiev.debugOperators,"trying assign "+op+" to be of type "+(tp==null?"<any>":tp.toString())),
			resolveE(ln1,op.getArgPriority(),tp),
			{ canBeAnExpr(ln1); true },
			opt @= op.types,
			opt.match(new ASTNode[]{null,ln.head(),ln1.head()}),
			ln.$var = new List.Cons<ASTNode>(
				makeAssignExpr(tp,ln.at(1).getPos(),(AssignOperator)op.$var,opt,
					(Expr)ln.head(),
					(Expr)ln1.head()
				),ln1.tail()
			),
			$cut,
			trace( Kiev.debugOperators,"resolved assign "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() > 2,
			canBeAnExpr(ln),
			{
				ln.at(1) instanceof ASTOperator,
				op ?= BinaryOperator.getOperator(((ASTOperator)ln.at(1)).image)
			;
				ln.at(1) instanceof ASTIdentifier,
				op ?= BinaryOperator.getOperator(((ASTIdentifier)ln.at(1)).name),
				trace( Kiev.debugOperators,"identifier as operator: "+op)
			},
			ln.$var = new List.Cons<ASTNode>(((Expr)ln.head()).resolve(null),ln.tail()),
			op.priority >= priority,
			trace( Kiev.debugOperators,"trying binary "+op+" to be of type "+(tp==null?"<any>":tp.toString())),
			{
				op ?= BinaryOperator.InstanceOf,
				$cut,
				ln.at(2) instanceof ASTType,
				expr ?= ((ASTType)ln.at(2)).pass2(),
				ln.$var = new List.Cons<ASTNode>(
					new InstanceofExpr(ln.at(1).getPos(),(Expr)ln.head(),(Type)expr.$var).resolve(Type.tpBoolean),
					ln.tail().tail().tail()
				)
			;
				ln1 ?= ln.tail().tail(),
				resolveE(ln1,op.getArgPriority(),null),
				{ canBeAnExpr(ln1); true },
				opt @= op.types,
				opt.match(new ASTNode[]{null,ln.head(),ln1.head()}),
				ln.$var = new List.Cons<ASTNode>(
					makeBinaryExpr(tp,ln.at(1).getPos(),op,opt,ln.head(),ln1.head()),
					ln1.tail()
				)
			},
			$cut,
			trace( Kiev.debugOperators,"resolved binary "+ln.head()+" and list is "+ln.tail())
		;
			ln.length() == 1,
			$cut,
			{
				ln.head() instanceof Expr,
				ln.$var = new List.Cons<ASTNode>(((Expr)ln.head()).resolve(tp),ln.tail())
			;	ln.head() instanceof Struct
			},
			trace( Kiev.debugOperators,"resolved expr "+ln.head()+" and list is "+ln.tail())
		},
		{
			while ln.length() > 1 && resolveE(ln,priority,tp)
		;	$cut
		}
	;
		canBeAnExpr(ln),
		$cut,
		trace( Kiev.debugOperators,"resolved primary "+ln.head()+" and list is "+ln.tail())
	}


	boolean canBeAnExpr(PVar<List<ASTNode>> ln)
	{
		if( ln.head() instanceof Expr ) {
			if( ln.head().isResolved() ) return true;
			ln.$var = new List.Cons<ASTNode>(((Expr)ln.head()).resolve(null),ln.tail());
			trace( Kiev.debugResolve,"resolved to be "+ln.head());
		}
		if( ln.head() instanceof Struct ) {
			ln.$var = new List.Cons<ASTNode>( Expr.toExpr((Struct)ln.head(),null,pos,parent),ln.tail());
			trace( Kiev.debugResolve,"resolved to be "+ln.head());
		}
		trace( Kiev.debugResolve,ln.head()+" instanceof Expr => "+(ln.head() instanceof Expr));
		return ln.head() instanceof Expr;
	}



	boolean checkMultiOperator(pvar List<ASTNode> ln, Type tp, MultiOperator op) {
		KString[] images = op.images;
		for(int i=0; i < images.length; i++) {
			if( ln.length() > i*2+2
			 && ln.at(i*2+1) instanceof ASTOperator
			 && ((ASTOperator)ln.at(i*2+1)).image.equals(images[i])
			) {
				PVar<List<ASTNode>> ln1 = new PVar<List<ASTNode>>(ln.drop(i*2+2));
				if( !resolveE(ln1,op.getArgPriority(),null) )
					return false;
				ln.$var = ln.take(i*2+2).concat(ln1.$var);
			}
		}
		Expr[] exprs = new Expr[op.images.length+1];
		int oppos = ln.at(1).pos;
		for(int i=0; i <= images.length; i++) {
			exprs[i] = (Expr)ln.$var.head();
			if( i == images.length )
				ln.$var = ln.tail();
			else
				ln.$var = ln.tail().tail();
		}
		if( op == MultiOperator.Conditional ) {
			Expr ce = new ConditionalExpr(oppos,exprs[0],exprs[1],exprs[2]);
			ce.parent = this;
			ln.$var = new List.Cons<ASTNode>(
				ce.resolve(null),ln.drop(exprs.length*2-1)
			);
		} else {
			throw new CompilerException(oppos,"Unknown multi-operator "+op);
		}
		return true;
	}
*/
	ASTNode makeAssignExpr(Type tp, int pos, Operator op, OpTypes opt, ASTNode expr1, ASTNode expr2) {
		Expr e;
		AssignOperator aop = (AssignOperator)op;
		if( expr1 instanceof Struct )
			expr1 = Expr.toExpr((Struct)expr1,null,pos,this);
		else
			expr1 = ((Expr)expr1).resolve(null);
		if( expr2 instanceof Struct )
			expr2 = Expr.toExpr((Struct)expr2,null,pos,this);
		else
			expr2 = ((Expr)expr2).resolveExpr(expr1.getType());
		if( opt.method != null )
			if( opt.method.isStatic() )
				e = new CallExpr(pos,opt.method,new Expr[]{(Expr)expr1,(Expr)expr2});
			else
				e = new CallAccessExpr(pos,(Expr)expr1,opt.method,new Expr[]{(Expr)expr2});
		else
			e = (Expr)new AssignExpr(pos,(AssignOperator)op,(Expr)expr1,(Expr)expr2);
		return e.resolve(tp);
	}

	ASTNode makeBinaryExpr(Type tp, int pos, Operator op, OpTypes opt, ASTNode expr1, ASTNode expr2) {
		Expr e;
		BinaryOperator bop = (BinaryOperator)op;
		if( bop.is_boolean_op ) {
			if( bop == BinaryOperator.BooleanOr ) {
				if( !(expr1 instanceof BooleanExpr) ) expr1 = new BooleanWrapperExpr(expr1.getPos(),(Expr)expr1);
				if( !(expr2 instanceof BooleanExpr) ) expr2 = new BooleanWrapperExpr(expr2.getPos(),(Expr)expr2);
				e = (Expr)new BinaryBooleanOrExpr(pos,(BooleanExpr)expr1,(BooleanExpr)expr2)
					.resolve(Type.tpBoolean);
			}
			else if( bop == BinaryOperator.BooleanAnd ) {
				if( !(expr1 instanceof BooleanExpr) ) expr1 = new BooleanWrapperExpr(expr1.getPos(),(Expr)expr1);
				if( !(expr2 instanceof BooleanExpr) ) expr2 = new BooleanWrapperExpr(expr2.getPos(),(Expr)expr2);
				e = (Expr)new BinaryBooleanAndExpr(pos,(BooleanExpr)expr1,(BooleanExpr)expr2)
					.resolve(Type.tpBoolean);
			}
			else {
				if( opt.method != null )
					if( opt.method.isStatic() )
						e = (Expr)new CallExpr(pos,opt.method,new Expr[]{(Expr)expr1,(Expr)expr2}).resolve(tp);
					else
						e = (Expr)new CallAccessExpr(pos,(Expr)expr1,opt.method,new Expr[]{(Expr)expr2}).resolve(tp);
				else
					e = (Expr)new BinaryBooleanExpr(pos,(BinaryOperator)op,getExpr(expr1),getExpr(expr2)).resolve(Type.tpBoolean);
			}
		} else {
			if( expr1 instanceof Struct )
				expr1 = Expr.toExpr((Struct)expr1,null,pos,this);
			else
				expr1 = (Expr)((Expr)expr1).resolve(null);
			if( expr2 instanceof Struct )
				expr2 = Expr.toExpr((Struct)expr2,null,pos,this);
			else
				expr2 = (Expr)((Expr)expr2).resolve(null);
			if( opt.method != null )
				if( opt.method.isStatic() )
					e = (Expr)new CallExpr(pos,opt.method,new Expr[]{(Expr)expr1,(Expr)expr2}).resolve(tp);
				else
					e = (Expr)new CallAccessExpr(pos,(Expr)expr1,opt.method,new Expr[]{(Expr)expr2}).resolve(tp);
			else
				e = (Expr)new BinaryExpr(pos,(BinaryOperator)op,(Expr)expr1,(Expr)expr2).resolve(tp);
		}
		return e;
	}

	public int		getPriority() { return 256; }

    public String toString() {
    	StringBuffer sb = new StringBuffer();
    	foreach(ASTNode n; nodes)
	    	sb.append(' ').append(n);
        return sb.toString();
    }

    public Dumper toJava(Dumper dmp) {
    	foreach(ASTNode n; nodes)
	    	dmp.space().append(n).space();
        return dmp;
    }
}


