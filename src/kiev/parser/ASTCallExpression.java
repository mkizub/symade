/* Generated By:JJTree: Do not edit this line. ASTCallExpression.java */

/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

package kiev.parser;

import kiev.Kiev;
import kiev.vlang.*;
import kiev.stdlib.*;
import kiev.transf.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 * @version $Revision$
 *
 */

@node
@dflow(out="args")
public class ASTCallExpression extends Expr {

	@att public NameRef					func;

	@dflow(in="", seq="true")
    @att public final NArr<ENode>		args;

	public ASTCallExpression() {
	}

	public ASTCallExpression(int pos, KString func, ENode[] args) {
		super(pos);
		this.func = new NameRef(pos, func);
		foreach (Expr e; args) {
			this.args.append(e);
		}
	}

	public ASTCallExpression(int pos, KString func, NArr<ENode> args) {
		super(pos);
		this.func = new NameRef(pos, func);
		this.args = args;
		foreach (Expr e; args) this.args.append(e);
	}

	public void mainResolveOut() {
		// method of current class or first-order function
		ASTNode@ m;
		Type tp = pctx.clazz.type;
		if( func.name.equals(nameThis) ) {
			Method mmm = pctx.method;
			if( mmm.name.equals(nameInit) && pctx.clazz.type.args.length > 0 ) {
				// Insert our-generated typeinfo, or from childs class?
				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[0]),0);
				else
					args.insert(pctx.clazz.accessTypeInfoField(this,pctx.clazz.type),0);
			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(pctx.clazz.type,m,info,pctx.method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
			if( info.isEmpty() ) {
				Type st = pctx.clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),false);
				replaceWithNode(ce);
				((Method)m).makeArgs(args,st);
				return;
			}
			throw new CompilerException(this,"Constructor call via forwarding is not allowed");
		}
		else if( func.name.equals(nameSuper) ) {
			Method mmm = pctx.method;
			if( mmm.name.equals(nameInit) && pctx.clazz.super_type.args.length > 0 ) {
				// no // Insert our-generated typeinfo, or from childs class?
				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[0]),0);
				else if( mmm.type.args.length > 1 && mmm.type.args[1].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[1]),0);
				else
					args.insert(pctx.clazz.accessTypeInfoField(this,pctx.clazz.super_type),0);
			}
			// If we extend inner non-static class - pass this$N as first argument
			if(  pctx.clazz.super_type.getStruct().package_clazz.isClazz()
			 && !pctx.clazz.super_type.getStruct().isStatic()
			) {
				if( pctx.clazz.isStatic() )
					throw new CompilerException(this,"Non-static inner super-class of static class");
				args.insert(new VarAccessExpr(pos,(Var)pctx.method.params[0]),0);
			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(pctx.clazz.super_type,m,info,pctx.method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
			if( info.isEmpty() ) {
				Type st = pctx.clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),true);
				replaceWithNode(ce);
				((Method)m).makeArgs(args,st);
				return;
			}
			throw new CompilerException(this,"Super-constructor call via forwarding is not allowed");
		} else {
			MethodType mt;
			Type[] ta = new Type[args.length];
			for(int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			mt = MethodType.newMethodType(null,ta,null);
			ResInfo info = new ResInfo(this);
			if( !PassInfo.resolveMethodR(this,m,info,func.name,mt) ) {
				// May be a closure
				ASTNode@ closure;
				ResInfo info = new ResInfo(this);
				if( !PassInfo.resolveNameR(this,closure,info,func.name) ) {
					throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args,null));
				}
				try {
					if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
					||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
					) {
						replaceWithNode(new ClosureCallExpr(pos,info.buildAccess(this,closure),args.delToArray()));
						return;
					}
				} catch(Exception eee) {
					Kiev.reportError(this,eee);
				}
				throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args));
			}
//				if( reqType instanceof CallableType ) {
//					ASTAnonymouseClosure ac = new ASTAnonymouseClosure();
//					ac.pos = pos;
//					ac.rettype = new TypeRef(pos, ((CallableType)reqType).ret);
//					for (int i=0; i < ac.params.length; i++)
//						ac.params.append(new FormPar(pos,KString.from("arg"+(i+1)),((Method)m).type.args[i],0));
//					BlockStat bs = new BlockStat(pos,ENode.emptyArray);
//					ENode[] oldargs = args.toArray();
//					Expr[] cargs = new Expr[ac.params.length];
//					for(int i=0; i < cargs.length; i++)
//						cargs[i] = new VarAccessExpr(pos,(Var)ac.params[i]);
//					args.delAll();
//					foreach (Expr e; cargs)
//						args.add(e);
//					if( ac.rettype.getType() == Type.tpVoid ) {
//						bs.addStatement(new ExprStat(pos,this));
//						bs.addStatement(new ReturnStat(pos,null));
//					} else {
//						bs.addStatement(new ReturnStat(pos,this));
//					}
//					ac.body = bs;
//					if( oldargs.length > 0 ) {
//						replaceWithNode(new ClosureCallExpr(pos,ac,oldargs));
//					} else {
//						replaceWithNode(ac);
//					}
//					return false;
//				} else {
				if( m.isStatic() )
					assert (info.isEmpty());
				((Method)m).makeArgs(args,tp);
				ENode e = info.buildCall(this,null,m,args.toArray());
				if (e instanceof UnresExpr)
					e = ((UnresExpr)e).toResolvedExpr();
				this.replaceWithNode(e);
//				}
		}
	}
	
	public void resolve(Type reqType) {
    	for(int i=0; i < args.length; i++) {
			args[i].resolve(null);
        }
		// method of current class or first-order function
		ASTNode@ m;
		Type tp = pctx.clazz.type;
		Type ret = reqType;
	retry_with_null_ret:;
		if( func.name.equals(nameThis) ) {
			Method mmm = pctx.method;
			if( mmm.name.equals(nameInit) && pctx.clazz.type.args.length > 0 ) {
				// Insert our-generated typeinfo, or from childs class?
				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[0]),0);
				else
					args.insert(pctx.clazz.accessTypeInfoField(this,pctx.clazz.type),0);
			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(pctx.clazz.type,m,info,pctx.method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
            if( info.isEmpty() ) {
				Type st = pctx.clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),false);
				replaceWithNode(ce);
				((Method)m).makeArgs(args,st);
				ce.resolve(ret);
				return;
			}
			throw new CompilerException(this,"Constructor call via forwarding is not allowed");
		}
		else if( func.name.equals(nameSuper) ) {
			Method mmm = pctx.method;
			if( mmm.name.equals(nameInit) && pctx.clazz.super_type.args.length > 0 ) {
				// no // Insert our-generated typeinfo, or from childs class?
				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[0]),0);
				else if( mmm.type.args.length > 1 && mmm.type.args[1].isInstanceOf(Type.tpTypeInfo) )
					args.insert(new VarAccessExpr(pos,mmm.params[1]),0);
				else
					args.insert(pctx.clazz.accessTypeInfoField(this,pctx.clazz.super_type),0);
			}
			// If we extend inner non-static class - pass this$N as first argument
			if(  pctx.clazz.super_type.getStruct().package_clazz.isClazz()
			 && !pctx.clazz.super_type.getStruct().isStatic()
			) {
				if( pctx.clazz.isStatic() )
					throw new CompilerException(this,"Non-static inner super-class of static class");
				args.insert(new VarAccessExpr(pos,(Var)pctx.method.params[0]),0);
			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(pctx.clazz.super_type,m,info,pctx.method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
            if( info.isEmpty() ) {
				Type st = pctx.clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),true);
				replaceWithNode(ce);
				((Method)m).makeArgs(args,st);
				ce.resolve(ret);
				return;
			}
			throw new CompilerException(this,"Super-constructor call via forwarding is not allowed");
		} else {
			MethodType mt;
			if( reqType instanceof MethodType && reqType.args.length > 0 ) {
				mt = (MethodType)reqType;
			} else {
				Type[] ta = new Type[args.length];
				for(int i=0; i < ta.length; i++)
					ta[i] = args[i].getType();
				mt = MethodType.newMethodType(null,ta,ret);
			}
			ResInfo info = new ResInfo(this);
			if( !PassInfo.resolveMethodR(this,m,info,func.name,mt) ) {
				// May be a closure
				ASTNode@ closure;
				ResInfo info = new ResInfo(this);
				if( !PassInfo.resolveNameR(this,closure,info,func.name) ) {
					if( ret != null ) { ret = null; goto retry_with_null_ret; }
					throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args,ret));
				}
				try {
					if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
					||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
					) {
						replaceWithNodeResolve(ret, new ClosureCallExpr(pos,info.buildAccess(this,closure),args.delToArray()));
						return;
					}
				} catch(Exception eee) {
					Kiev.reportError(this,eee);
				}
				if( ret != null ) { ret = null; goto retry_with_null_ret; }
				throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args));
			}
			if( reqType instanceof CallableType ) {
				ASTAnonymouseClosure ac = new ASTAnonymouseClosure();
				ac.pos = pos;
				ac.rettype = new TypeRef(pos, ((CallableType)reqType).ret);
				for (int i=0; i < ac.params.length; i++)
					ac.params.append(new FormPar(pos,KString.from("arg"+(i+1)),((Method)m).type.args[i],0));
				BlockStat bs = new BlockStat(pos,ENode.emptyArray);
				ENode[] oldargs = args.toArray();
				Expr[] cargs = new Expr[ac.params.length];
				for(int i=0; i < cargs.length; i++)
					cargs[i] = new VarAccessExpr(pos,(Var)ac.params[i]);
				args.delAll();
				foreach (Expr e; cargs)
					args.add(e);
				if( ac.rettype.getType() == Type.tpVoid ) {
					bs.addStatement(new ExprStat(pos,this));
					bs.addStatement(new ReturnStat(pos,null));
				} else {
					bs.addStatement(new ReturnStat(pos,this));
				}
				ac.body = bs;
				if( oldargs.length > 0 ) {
					replaceWithNodeResolve(reqType, new ClosureCallExpr(pos,ac,oldargs));
				} else {
					replaceWithNodeResolve(reqType, ac);
				}
				return;
			} else {
				if( m.isStatic() )
					assert (info.isEmpty());
				((Method)m).makeArgs(args,tp);
				ENode e = info.buildCall(this,null,m,args.toArray());
				this.replaceWithNodeResolve( reqType, e );
			}
		}
	}

	public int		getPriority() { return Constants.opCallPriority; }

	public String toString() {
		StringBuffer sb = new StringBuffer();
    	sb.append(func).append('(');
		for(int i=0; i < args.length; i++) {
			sb.append(args[i]);
			if( i < args.length-1 )
				sb.append(',');
		}
		return sb.append(')').toString();
	}

	public Dumper toJava(Dumper dmp) {
    	dmp.append(func).append('(');
		for(int i=0; i < args.length; i++) {
			args[i].toJava(dmp);
			if( i < args.length-1 )
				dmp.append(',');
		}
		return dmp.append(')');
	}
}
