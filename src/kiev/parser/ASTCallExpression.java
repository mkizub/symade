/* Generated By:JJTree: Do not edit this line. ASTCallExpression.java */

package kiev.parser;

import kiev.Kiev;
import kiev.vlang.*;
import kiev.stdlib.*;
import kiev.transf.*;

import static kiev.stdlib.Debug.*;
import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 * @version $Revision$
 *
 */

@node
public class ASTCallExpression extends ENode {

	@dflow(out="args") private static class DFI {
	@dflow(in="this:in", seq="true")		ENode[]		args;
	}

	@att public NameRef					func;

    @att public final NArr<ENode>		args;

	public ASTCallExpression() {
	}

	public ASTCallExpression(int pos, KString func, ENode[] args) {
		super(pos);
		this.func = new NameRef(pos, func);
		foreach (ENode e; args) {
			this.args.append(e);
		}
	}

	public ASTCallExpression(int pos, KString func, NArr<ENode> args) {
		super(pos);
		this.func = new NameRef(pos, func);
		this.args = args;
		foreach (ENode e; args) this.args.append(e);
	}

	public void mainResolveOut() {
		// method of current class or first-order function
		DNode@ m;
		Type tp = ctx_clazz.type;
		if( func.name.equals(nameThis) ) {
//			Method mmm = ctx_method;
//			if( mmm.name.equals(nameInit) && ctx_clazz.type.args.length > 0 ) {
//				// Insert our-generated typeinfo, or from childs class?
//				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[0]),0);
//				else
//					args.insert(ctx_clazz.accessTypeInfoField(this,ctx_clazz.type),0);
//			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			try {
				if( !PassInfo.resolveBestMethodR(ctx_clazz.type,m,info,ctx_method.name.name,mt) )
					throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
			} catch (RuntimeException e) { throw new CompilerException(this,e.getMessage()); }
			if( info.isEmpty() ) {
				Type st = ctx_clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),false);
				replaceWithNode(ce);
				//((Method)m).makeArgs(ce.args,st);
				return;
			}
			throw new CompilerException(this,"Constructor call via forwarding is not allowed");
		}
		else if( func.name.equals(nameSuper) ) {
//			Method mmm = ctx_method;
//			if( mmm.name.equals(nameInit) && ctx_clazz.super_type.args.length > 0 ) {
//				// no // Insert our-generated typeinfo, or from childs class?
//				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[0]),0);
//				else if( mmm.type.args.length > 1 && mmm.type.args[1].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[1]),0);
//				else
//					args.insert(ctx_clazz.accessTypeInfoField(this,ctx_clazz.super_type),0);
//			}
//			// If we extend inner non-static class - pass this$N as first argument
//			if(  ctx_clazz.super_type.getStruct().package_clazz.isClazz()
//			 && !ctx_clazz.super_type.getStruct().isStatic()
//			) {
//				if( ctx_clazz.isStatic() )
//					throw new CompilerException(this,"Non-static inner super-class of static class");
//				args.insert(new LVarExpr(pos,(Var)ctx_method.params[0]),0);
//			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			try {
				if( !PassInfo.resolveBestMethodR(ctx_clazz.super_type,m,info,ctx_method.name.name,mt) )
					throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
			} catch (RuntimeException e) { throw new CompilerException(this,e.getMessage()); }
			if( info.isEmpty() ) {
				Type st = ctx_clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,(Method)m,args.delToArray(),true);
				replaceWithNode(ce);
				//((Method)m).makeArgs(ce.args,st);
				return;
			}
			throw new CompilerException(this,"Super-constructor call via forwarding is not allowed");
		} else {
			MethodType mt;
			Type[] ta = new Type[args.length];
			for(int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			mt = MethodType.newMethodType(null,ta,null);
			ResInfo info = new ResInfo(this);
			try {
				if( !PassInfo.resolveMethodR(this,m,info,func.name,mt) ) {
					// May be a closure
					DNode@ closure;
					ResInfo info = new ResInfo(this);
					try {
						if( !PassInfo.resolveNameR(this,closure,info,func.name) )
							throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args,null));
					} catch (RuntimeException e) { throw new CompilerException(this,e.getMessage()); }
					try {
						if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
						||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
						) {
							replaceWithNode(new ClosureCallExpr(pos,info.buildAccess(this,closure),args.delToArray()));
							return;
						}
					} catch(Exception eee) {
						Kiev.reportError(this,eee);
					}
					throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args));
				}
			} catch (RuntimeException e) { throw new CompilerException(this,e.getMessage()); }
//				if( reqType instanceof CallableType ) {
//					ASTAnonymouseClosure ac = new ASTAnonymouseClosure();
//					ac.pos = pos;
//					ac.rettype = new TypeRef(pos, ((CallableType)reqType).ret);
//					for (int i=0; i < ac.params.length; i++)
//						ac.params.append(new FormPar(pos,KString.from("arg"+(i+1)),((Method)m).type.args[i],0));
//					BlockStat bs = new BlockStat(pos,ENode.emptyArray);
//					ENode[] oldargs = args.toArray();
//					Expr[] cargs = new Expr[ac.params.length];
//					for(int i=0; i < cargs.length; i++)
//						cargs[i] = new LVarExpr(pos,(Var)ac.params[i]);
//					args.delAll();
//					foreach (ENode e; cargs)
//						args.add(e);
//					if( ac.rettype.getType() == Type.tpVoid ) {
//						bs.addStatement(new ExprStat(pos,this));
//						bs.addStatement(new ReturnStat(pos,null));
//					} else {
//						bs.addStatement(new ReturnStat(pos,this));
//					}
//					ac.body = bs;
//					if( oldargs.length > 0 ) {
//						replaceWithNode(new ClosureCallExpr(pos,ac,oldargs));
//					} else {
//						replaceWithNode(ac);
//					}
//					return false;
//				} else {
				if( m.isStatic() )
					assert (info.isEmpty());
				//((Method)m).makeArgs(args,tp);
				ENode e = info.buildCall(this,null,m,args.toArray());
				if (e instanceof UnresExpr)
					e = ((UnresExpr)e).toResolvedExpr();
				this.replaceWithNode(e);
//				}
		}
	}
	
	public void resolve(Type reqType) {
    	for(int i=0; i < args.length; i++) {
			args[i].resolve(null);
        }
		// method of current class or first-order function
		Method@ m;
		Type tp = ctx_clazz.type;
		Type ret = reqType;
	retry_with_null_ret:;
		if( func.name.equals(nameThis) ) {
//			Method mmm = ctx_method;
//			if( mmm.name.equals(nameInit) && ctx_clazz.type.args.length > 0 ) {
//				// Insert our-generated typeinfo, or from childs class?
//				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[0]),0);
//				else
//					args.insert(ctx_clazz.accessTypeInfoField(this,ctx_clazz.type),0);
//			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(ctx_clazz.type,m,info,ctx_method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
            if( info.isEmpty() ) {
				Type st = ctx_clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,m,args.delToArray(),false);
				replaceWithNode(ce);
				//m.makeArgs(ce.args,st);
				ce.resolve(ret);
				return;
			}
			throw new CompilerException(this,"Constructor call via forwarding is not allowed");
		}
		else if( func.name.equals(nameSuper) ) {
//			Method mmm = ctx_method;
//			if( mmm.name.equals(nameInit) && ctx_clazz.super_type.args.length > 0 ) {
//				// no // Insert our-generated typeinfo, or from childs class?
//				if( mmm.type.args.length > 0 && mmm.type.args[0].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[0]),0);
//				else if( mmm.type.args.length > 1 && mmm.type.args[1].isInstanceOf(Type.tpTypeInfo) )
//					args.insert(new LVarExpr(pos,mmm.params[1]),0);
//				else
//					args.insert(ctx_clazz.accessTypeInfoField(this,ctx_clazz.super_type),0);
//			}
//			// If we extend inner non-static class - pass this$N as first argument
//			if(  ctx_clazz.super_type.getStruct().package_clazz.isClazz()
//			 && !ctx_clazz.super_type.getStruct().isStatic()
//			) {
//				if( ctx_clazz.isStatic() )
//					throw new CompilerException(this,"Non-static inner super-class of static class");
//				args.insert(new LVarExpr(pos,(Var)ctx_method.params[0]),0);
//			}
			Type[] ta = new Type[args.length];
			for (int i=0; i < ta.length; i++)
				ta[i] = args[i].getType();
			MethodType mt = MethodType.newMethodType(null,ta,Type.tpVoid);
			ResInfo info = new ResInfo(this,ResInfo.noSuper|ResInfo.noStatic|ResInfo.noForwards|ResInfo.noImports);
			if( !PassInfo.resolveBestMethodR(ctx_clazz.super_type,m,info,ctx_method.name.name,mt) )
				throw new CompilerException(this,"Method "+Method.toString(func.name,args)+" unresolved");
            if( info.isEmpty() ) {
				Type st = ctx_clazz.super_type;
				CallExpr ce = new CallExpr(pos,null,m,args.delToArray(),true);
				replaceWithNode(ce);
				//m.makeArgs(ce.args,st);
				ce.resolve(ret);
				return;
			}
			throw new CompilerException(this,"Super-constructor call via forwarding is not allowed");
		} else {
			MethodType mt;
			if( reqType instanceof MethodType && reqType.args.length > 0 ) {
				mt = (MethodType)reqType;
			} else {
				Type[] ta = new Type[args.length];
				for(int i=0; i < ta.length; i++)
					ta[i] = args[i].getType();
				mt = MethodType.newMethodType(null,ta,ret);
			}
			ResInfo info = new ResInfo(this);
			if( !PassInfo.resolveMethodR(this,m,info,func.name,mt) ) {
				// May be a closure
				DNode@ closure;
				ResInfo info = new ResInfo(this);
				if( !PassInfo.resolveNameR(this,closure,info,func.name) ) {
					if( ret != null ) { ret = null; goto retry_with_null_ret; }
					throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args,ret));
				}
				try {
					if( closure instanceof Var && Type.getRealType(tp,((Var)closure).type) instanceof ClosureType
					||  closure instanceof Field && Type.getRealType(tp,((Field)closure).type) instanceof ClosureType
					) {
						replaceWithNodeResolve(ret, new ClosureCallExpr(pos,info.buildAccess(this,closure),args.delToArray()));
						return;
					}
				} catch(Exception eee) {
					Kiev.reportError(this,eee);
				}
				if( ret != null ) { ret = null; goto retry_with_null_ret; }
				throw new CompilerException(this,"Unresolved method "+Method.toString(func.name,args));
			}
			if( reqType instanceof CallableType ) {
				ASTAnonymouseClosure ac = new ASTAnonymouseClosure();
				ac.pos = pos;
				ac.rettype = new TypeRef(pos, ((CallableType)reqType).ret);
				for (int i=0; i < ac.params.length; i++)
					ac.params.append(new FormPar(pos,KString.from("arg"+(i+1)),((Method)m).type.args[i],FormPar.PARAM_LVAR_PROXY,ACC_FINAL));
				BlockStat bs = new BlockStat(pos,ENode.emptyArray);
				ENode[] oldargs = args.toArray();
				ENode[] cargs = new ENode[ac.params.length];
				for(int i=0; i < cargs.length; i++)
					cargs[i] = new LVarExpr(pos,(Var)ac.params[i]);
				args.delAll();
				foreach (ENode e; cargs)
					args.add(e);
				if( ac.rettype.getType() == Type.tpVoid ) {
					bs.addStatement(new ExprStat(pos,this));
					bs.addStatement(new ReturnStat(pos,null));
				} else {
					bs.addStatement(new ReturnStat(pos,this));
				}
				ac.body = bs;
				if( oldargs.length > 0 ) {
					replaceWithNodeResolve(reqType, new ClosureCallExpr(pos,ac,oldargs));
				} else {
					replaceWithNodeResolve(reqType, ac);
				}
				return;
			} else {
				if( m.isStatic() )
					assert (info.isEmpty());
				//((Method)m).makeArgs(args,tp);
				ENode e = info.buildCall(this,null,m,args.toArray());
				this.replaceWithNodeResolve( reqType, e );
			}
		}
	}

	public int		getPriority() { return Constants.opCallPriority; }

	public String toString() {
		StringBuffer sb = new StringBuffer();
    	sb.append(func).append('(');
		for(int i=0; i < args.length; i++) {
			sb.append(args[i]);
			if( i < args.length-1 )
				sb.append(',');
		}
		return sb.append(')').toString();
	}

	public Dumper toJava(Dumper dmp) {
    	dmp.append(func).append('(');
		for(int i=0; i < args.length; i++) {
			args[i].toJava(dmp);
			if( i < args.length-1 )
				dmp.append(',');
		}
		return dmp.append(')');
	}
}
