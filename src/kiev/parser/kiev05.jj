options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
//  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = false;
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev050)
/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.parser;

import kiev.Kiev;
import java.io.Reader;

/*{

import static kiev.vlang.AccessFlags.*;
import syntax kiev.Syntax;

typedef SymbolRefPkg = SymbolRef<KievPackage> ;
typedef SymbolRefFld = SymbolRef<Field> ;

}*/ 

public final class Parser extends kiev050 {
	public Parser(Reader r) {
		super(r,1,1);
	}
}

public interface ParserConstants extends kiev050Constants {
}

public abstract class kiev050 {

	public FileUnit			curFileUnit;
	public ComplexTypeDecl	curClazz;
	public Method			curMethod;
	public boolean			interface_only = false;

	public boolean			declMode = true;

	public kiev050(java.io.Reader stream, int line, int pos) {
		jj_input_stream = new SimpleCharStream(stream, line, pos);
		token_source = new kiev050TokenManager(jj_input_stream, this);
		token = new Token();
		token.next = jj_nt = token_source.getNextToken();
	}

	/** Report Parser Error (Exception) */
	private void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	private void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e, e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	private boolean operatorLA() {
		Token t0 = getToken(0);
		Token t1 = getToken(1);
		if (t0.endLine != t1.beginLine || t0.endColumn+1 != t1.beginColumn)
			return false;
		switch (t1.kind) {
		case ARROW:
		case LT:
		case GT:
		case ASSIGN:
		case ASSIGN2:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR_UPPER_BOUND:
		case OPERATOR_LOWER_BOUND:
		case OPERATOR:
			return true;
		}
		return false;
	}

	private boolean ExpressionNoNoLA() {
		switch (getToken(1).kind) {
		case RPAREN:
		case RBRACE:
		case RBRACKET:
		case SEMICOLON:
		case COLON:
		case COMMA:
			return false;
		}
		return true;
	}

	/*{
	private ComplexTypeDecl mkMetaType(Symbol name, ASTModifiers modifiers, NameSpace fu) {
		KievPackage pkg = fu.getPackage();
		String uuid = modifiers == null ? null : modifiers.getUUID();
		MetaTypeDecl tdecl = Env.getRoot().newMetaType(new Symbol<MetaTypeDecl>(name.pos,name.sname), pkg, true, uuid);
		tdecl.setTypeDeclNotLoaded(false);
		modifiers.moveToNode(tdecl.meta);
		return tdecl;
	}

	private Struct mkStruct(Symbol name, Struct variant, int flags, ASTModifiers modifiers, ASTNode parent) {
		String nm;
		ComplexTypeDecl outer;
		boolean direct;
		if (parent instanceof NameSpace) {
			NameSpace ns = (NameSpace)parent;
			nm = name.sname;
			outer = ns.getPackage();
			direct = true;
		}
		else if (parent instanceof Struct) {
			nm = name.sname;
			outer = curClazz;
			direct = true;
		}
		else if (name != null) {
			// Construct name of local class
			nm = name.sname;
			outer = curClazz;
			direct = false;
		}
		else {
			// Local anonymouse class
			nm = null;
			outer = curClazz;
			direct = false;
		}
		String uuid = modifiers == null ? null : modifiers.getUUID();
		Struct clazz = Env.getRoot().newStruct(nm,direct,(Struct)curClazz,flags,variant,true,uuid);
		if (name != null)
			clazz.pos  = name.pos;
		else
			clazz.pos  = parent.pos;
		clazz.setTypeDeclNotLoaded(false);
		modifiers.moveToNode(clazz.meta);
		if (parent instanceof NameSpace)
			clazz.setLocal(false);
		else if (parent instanceof Struct)
			clazz.setLocal(parent.isLocal());
		else
			clazz.setLocal(true);
		
		return clazz;
	}

	private TypeAssign mkTypeAssign(Symbol name, ASTModifiers modifiers, boolean mkUUID) {
		String uuid = modifiers == null ? null : modifiers.getUUID();
		TypeAssign arg = new TypeAssign(name.sname);
		arg.pos = name.pos;
		if (modifiers != null)
			modifiers.moveToNode(arg.meta);
		if (uuid == null && mkUUID) {
			String uuid = arg.UUID; // will auti-generate
		}
		return arg;
	}

	private TypeConstr mkTypeConstr(Symbol name, ASTModifiers modifiers, boolean mkUUID) {
		TypeConstr arg = null;
		String uuid = modifiers == null ? null : modifiers.getUUID();
		if (uuid != null) {
			DNode dn = (DNode)Env.getRoot().getISymbolByUUID(uuid);
			if (dn instanceof TypeConstr) {
				arg = (TypeConstr)dn;
				arg.sname = name.sname;
				arg.meta.metas.delAll();
				arg.super_types.delAll();
				arg.lower_bound.delAll();
			}
		}
		if (arg == null)
			arg = new TypeConstr(name.sname);
		arg.pos = name.pos;
		if (modifiers != null)
			modifiers.moveToNode(arg.meta);
		if (uuid == null && mkUUID) {
			String uuid = arg.UUID; // will auti-generate
		}
		return arg;
	}

	private Constructor mkConstructor(Symbol id, ASTModifiers modifiers) {
		Constructor meth = new Constructor(0);
		meth.pos = id.pos;
		modifiers.moveToNode(meth.meta);
		return meth;
	}
	
	private Method mkMethod(Symbol id, ASTModifiers modifiers, TypeRef ret) {
		Method meth = new MethodImpl(id.sname, ret, 0);
		meth.pos = id.pos;
		modifiers.moveToNode(meth.meta);
		return meth;
	}
	
	private RuleMethod mkRuleMethod(Symbol id, ASTModifiers modifiers, TypeRef ret) {
		RuleMethod meth = new RuleMethod(id.sname, 0);
		meth.pos = id.pos;
		modifiers.moveToNode(meth.meta);
		return meth;
	}
	
	private Field mkField(Symbol id, ASTModifiers modifiers, TypeRef tp, ENode init) {
		if (tp == null)
			tp = new TypeDeclRef();
		Field f = new Field(id.sname, tp, 0);
		f.pos = id.pos;
		modifiers.copyToNode(f.meta);
		f.init = init;
		return f;
	}

	private Field mkEnumField(Symbol id, ASTModifiers modifiers) {
		Field f = new Field(id.sname,new TypeDeclRef(),0);
		f.meta.is_enum = true;
		f.pos = id.pos;
		modifiers.moveToNode(f.meta);
		f.setPublic();
		f.setStatic(true);
		f.setFinal(true);
		return f;
	}

	private Field mkCaseField(Symbol id, ASTModifiers modifiers, TypeRef tp) {
		Field f = new Field(id.sname,tp,0|ACC_PUBLIC);
		f.pos = id.pos;
		modifiers.moveToNode(f.meta);
		return f;
	}
	
	private LVar mkVar(Symbol id, ASTModifiers modifiers, TypeRef tp) {
		if (tp == null)
			tp = new TypeDeclRef();
		LVar v = new LVar(id.pos, id.sname, tp, Var.VAR_LOCAL, 0);
		modifiers.copyToNode(v.meta);
		return v;
	}
	
	private LVar mkRuleVar(Symbol id, ASTModifiers modifiers, TypeRef tp, boolean first) {
		if (!first)
			tp = tp.ncopy();
		LVar v = new LVar(id.pos, id.sname, tp, Var.VAR_RULE, 0);
		modifiers.copyToNode(v.meta);
		return v;
	}
	
	private LVar mkFormPar(Symbol id, ASTModifiers modifiers, TypeRef vt, TypeRef st) {
		LVar v = new LVar(id.pos, id.sname, vt, LVar.PARAM_NORMAL, 0);
		if (st != null)
			v.stype = st;
		modifiers.moveToNode(v.meta);
		return v;
	}
	
	private LVar mkVarargPar(Symbol id, ASTModifiers modifiers, TypeRef vt) {
		LVar v = new LVar(id.pos, id.sname, vt, LVar.PARAM_VARARGS, ACC_FINAL);
		modifiers.moveToNode(v.meta);
		return v;
	}
	
	private RewritePattern mkRewritePattern(Symbol id, ASTModifiers modifiers, TypeRef tp) {
		RewritePattern v = new RewritePattern(id.sname, tp);
		v.pos = id.pos;
		modifiers.moveToNode(v.meta);
		return v;
	}
	
	private	Initializer mkInitializer(int pos, ASTModifiers modifiers) {
		Initializer init = new Initializer();
		init.pos = pos;
		modifiers.moveToNode(init.meta);
		return init;
	}

	
	private ENode mkNotExpr(EToken not, ENode cond) {
		cond.setPrimaryExpr(true);
		ASTExpression e = new ASTExpression();
		e.pos = cond.pos;
		e.nodes.append(not);
		e.nodes.append(~cond);
		return e;
	}
	
	private void expandExpr(ASTExpression e, ENode n) {
		if (n instanceof ASTExpression) {
			foreach (ENode x; n.nodes.delToArray())
				e.nodes += x;
		} else {
			e.nodes += n;
		}
	}


	}*/

	void comments_alone(SpacePtr arr) {
		Comment[] comments = get_comments();
		if (comments == null || comments.length == 0)
			return;
		for (int i=0; i < comments.length; i++)
			arr += comments[i];
	}
	void comments_before(ASTNode node) {
		Comment[] comments = get_comments();
		if (comments == null || comments.length == 0)
			return;
		for (int i=0; i < comments.length; i++)
			Comment.ATTR_BEFORE.set(node, comments[i]);
	}

	Comment[] get_comments() {
		Token t0 = getToken(0);
		Token t1 = getToken(1);
		Token st = t1.specialToken;
		if (st == null)
			return null;
		Comment[] comments = new Comment[0];
		t1.specialToken = null;
		while (st.specialToken != null)
			st = st.specialToken;
		for (; st != null; st = st.next) {
			if (st.kind == SINGLE_LINE_COMMENT) {
				String text = st.image.substring(2);
				text = text.trim();
				if (comments.length > 0 && comments[comments.length-1].eol_form) {
					Comment c = comments[comments.length-1];
					c.text = new StringBuffer(c.text.length()+1+text.length()).append(c.text).append('\n').append(text).toString();
					c.multiline = true;
				} else {
					Comment c = new Comment();
					c.text = text;
					c.eol_form = true;
					c.nl_after = true;
					if (st.specialToken != null) {
						if (st.beginLine > st.specialToken.endLine)
							c.nl_before = true;
					} else {
						if (st.beginLine < t0.endLine)
							c.nl_before = true;
					}
					comments = (Comment[])Arrays.append(comments, c);
				}
			}
			else if (st.kind == FORMAL_COMMENT || st.kind == MULTI_LINE_COMMENT) {
				String text = (st.kind == FORMAL_COMMENT) ?
						st.image.substring(3, st.image.length()-5)
					:	st.image.substring(2, st.image.length()-4);
				String[] lines = text.trim().split("\n");
				for (int i=0; i < lines.length; i++) {
					String l = lines[i].trim();
					if (l.length() >= 1 && l.charAt(0) == '*') {
						l = l.substring(1);
						l = l.trim();
					}
					lines[i] = l;
				}
				Comment c = new Comment();
				c.doc_form = (st.kind == FORMAL_COMMENT);
				if (lines.length > 1) {
					c.multiline = true;
					c.text = "";
					for (int i=0; i < lines.length; i++) {
						String txt = lines[i].trim();
						c.text = new StringBuffer(c.text.length()+1+txt.length()).append(c.text).append('\n').append(txt).toString();
					}
				} else {
					c.text = lines[0];
				}
				
				if (st.specialToken != null) {
					if (st.beginLine > st.specialToken.endLine)
						c.nl_before = true;
				} else {
					if (st.beginLine < t0.endLine)
						c.nl_before = true;
				}
				
				if (st.next != null) {
					if (st.endLine < st.next.beginLine)
						c.nl_after = true;
				} else {
					if (st.endLine < t1.beginLine)
						c.nl_after = true;
				}
				comments = (Comment[])Arrays.append(comments, c);
			}
		}
		return comments;
	}

}

PARSER_END(kiev050)


TOKEN_MGR_DECLS :
{
	final kiev050 parser;
	public kiev050TokenManager(SimpleCharStream stream, kiev050 parser)
	{
		if (SimpleCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		this.parser = parser;
		this.input_stream = stream;
	}
}

<DEFAULT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT>
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<DEFAULT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IF_REWR: "if#" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INTERFACE: "interface" >
| < METATYPE: "metatype" >
| < NATIVE: "native" >
| < PACKAGE: "package">
| < RETURN: "return" >
| < STATIC: "static" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRY: "try" >
| < VOLATILE: "volatile" >
| < VIEW: "view" >
| < WHILE: "while" >
| < VARARGS: "..." >
| < PCUT: "$cut" >
| < ALIAS: "alias" >
| < TYPE: "type" >
| < TYPEDEF: "typedef" >
| < ENUM: "enum" >

| < REQUIRE: "require" >
| < ENSURE: "ensure" >
| < INVARIANT: "invariant" >

| < META_INTERFACE:    "@interface"    >
| < META_SINGLETON:    "@singleton"    >
| < META_MIXIN:        "@mixin"        >
| < META_FORWARD:      "@forward"      >
| < META_UNERASABLE:   "@unerasable"   >
| < META_VIRTUAL:      "@virtual"      >
| < META_PACKED:       "@packed"       >
| < META_MACRO:        "@macro"        >
| < META_STATIC:       "@static"       >
| < META_ABSTRACT:     "@abstract"     >
| < META_FINAL:        "@final"        >
| < META_NATIVE:       "@native"       >
| < META_SYNCHRONIZED: "@synchronized" >
| < META_TRANSIENT:    "@transient"    >
| < META_VOLATILE:     "@volatile"     >
| < META_THROWS:       "@throws"       >
| < META_UUID:         "@uuid"         >

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < META_ACCESS1:   "@access"    > : IN_ACCESS
| < META_PUBLIC:    "@public"    > : IN_ACCESS
| < PUBLIC:         "public"     > : IN_ACCESS
| < META_PROTECTED: "@protected" > : IN_ACCESS
| < PROTECTED:      "protected"  > : IN_ACCESS
| < META_PRIVATE:   "@private"   > : IN_ACCESS
| < PRIVATE:        "private"    > : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY:     "ro" | "r" >
 | < WRITE_ONLY:    "wo" | "w" >
 | < READ_WRITE:    "rw"       >
 | < NO_READ_WRITE: "no" | "n" >
 | < COMMA1: "," >
 | < COLON1: ":" >
 | < OPEN_ACCESS: "(" >
 | < CLOSE_ACCESS: ")" > : DEFAULT
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT>
TOKEN : /* RESERVED WORDS FOR EXPRS */
{
  < FUNCTION: "fun" >
| < FALSE: "false" >
| < NEW: "new" >
| < NULL: "null" >
| < TRUE: "true" >
| < OPERATOR_ID: "operator" >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "#id" <ID_STRING_LITERAL> "#" ) >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COLON: ":" >
| < DOT: "." >
| < COMMA: "," >
}

<DEFAULT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
| < LANGLE: "<\u0335" > // <̵
| < RANGLE: ">\u0335" > // >̵
}

<DEFAULT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >
| < ARROW: "->" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP: "#" >
| < OPERATOR_LRBRACKETS: "[" ( " " )* "]" >
| < OPERATOR_SUPERSCRIPT_PLUS: "\u207a" >
| < OPERATOR_SUPERSCRIPT_MINUS: "\u207b" >

| < OPERATOR_UPPER_BOUND:    "\u2264" > // ≤
| < OPERATOR_LOWER_BOUND:    "\u2265" > // ≥

| < OPERATOR:	    ["!","?","~","|","&","+","-","*","/","^","%","\u2190"-"\u22F1"] >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

FileUnit FileUnit(String filename) :
{ FileUnit oldFileUnit; ComplexTypeDecl oldClazz; }
{
	{
		oldFileUnit = curFileUnit;
		FileUnit fu = FileUnit.makeFile(filename, false);
		curFileUnit = fu;
		declMode = true;
		ASTModifiers modifiers;
		oldClazz = curClazz;
		curClazz = Env.getRoot();
	}
	try {
		(
			Pragma(fu)
		)*
		[
			fu.srpkg = Package()
			{ curClazz = fu.getPackage(); }
		]
		TopLevelDeclarations(fu)
		<EOF>
	}
	catch(ParseError e) { rpe("Bad declaration",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		curClazz = oldClazz;
		curFileUnit = oldFileUnit;
		declMode = true;
		return fu;
	}
}

NameSpace NameSpaceDeclaration(ASTModifiers modifiers, NameSpace parent) :
{ ComplexTypeDecl oldClazz = curClazz; NameSpace ns = new NameSpace(); SymbolRef sr; }
{
	{ declMode = true; }
	try {
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("namespace") })
		<IDENTIFIER>	// "namespace"
		(	LOOKAHEAD({ parent.getPackage() instanceof Env })
			sr = QName()		{ ns.srpkg = (SymbolRefPkg)sr; }
		|	sr = NameRef()		{ ns.srpkg = (SymbolRefPkg)sr; }
		)
		{ parent.members += ns; curClazz = ns.getPackage(); }
		"{"
		TopLevelDeclarations(ns)
		"}"
	}
	catch(ParseError e) { rpe("Bad declaration",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		curClazz = oldClazz;
		declMode = true;
		return ns;
	}
}

void TopLevelDeclarations(NameSpace ns) :
{ ASTModifiers modifiers; SpacePtr ns_members = ns.getSpacePtr("members"); }
{
	(	LOOKAHEAD({ getToken(1).kind != RBRACE && getToken(1).kind != EOF })
		{ comments_alone(ns_members); }
		modifiers = Modifiers()
		(
			ns.members += Import(modifiers)
		|	ns.members += Typedef(modifiers)
		|	ns.members += Opdef(modifiers)
		|	ns.members += MetaTypeDeclaration(modifiers, ns) [ ";" ]
		|	ns.members += TypeDeclaration(modifiers, ns) [ ";" ]
		|	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			SyntaxDeclaration(modifiers, ns) [ ";" ]
		|	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("namespace") })
			NameSpaceDeclaration(modifiers, ns) [ ";" ]
		)
	)*
	{ comments_alone(ns_members); }
}

ASTModifiers Modifiers() :
{}
{	{ ASTModifiers n = new ASTModifiers(); }
	(
		SpecialAnnotation(n)
	|	Access(n)			// TODO: remove, use @access and views
	|	LOOKAHEAD({ getToken(1).kind==OPERATOR_AT })
		n.annotations	+= Annotation()
	)*
	{ return n; }
}

void InBlockModifiersLA() :
{}
{
		"@"

	|	"@access"
	|	"@public"
	|	"@protected"
	|	"@private"

	| "@singleton"
	| "@mixin"
	| "@forward"
	| "@unerasable"
	| "@virtual"
	| "@macro"
	| "static"
	| "@static"
	| "abstract"
	| "@abstract"
	| "final"
	| "@final"
	| "@native"
	| "@synchronized"
	| "@transient"
	| "@volatile"
	| "@packed"
	| "@throws"
	| "@uuid"
}

SymbolRefPkg Package() :
{ SymbolRef qn; }
{
	"package"
	qn = QName()
	";"
	{
		qn.symbol = Env.getRoot().newPackage(qn.name);
		return (SymbolRefPkg)qn;
	}
}

void Pragma(FileUnit fu) :
{ ASTPragma p = new ASTPragma(); }
{
	{ comments_before(p); }
	"pragma"
	(
		<PRAGMA_ENABLE>		{ p.enable = true; }
	|	<PRAGMA_DISABLE>	{ p.enable = false; }
	)
	( p.options += StringConstExpression() )+
	";"
	{ fu.setPragma(p); }
}

Import Import(ASTModifiers modifiers) :
{ Import imp = new Import(); }
{
	"import"
	(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
		<IDENTIFIER>{ imp.mode = Import.ImportMode.IMPORT_SYNTAX; }
		imp.name = QName()
	|
		[ "static"	{ imp.mode = Import.ImportMode.IMPORT_STATIC; } ]
		imp.name = QName()
		[	LOOKAHEAD( "." <OPERATOR>, { getToken(2).image.equals("*") })
			"." <OPERATOR> { imp.star = true; }
		|	"("		{ imp.of_method = true; }
			[
				imp.args += Type()
				(
					","
					imp.args += Type()
				)*
			]
			")"
		]
	)
	";"
	{ return imp; }
}

TypeDecl Typedef(ASTModifiers modifiers) :
{ Symbol id; TypeDecl n; TypeRef tr; Token t; EToken et; }
{
	("typedef"|"type")
	(
		LOOKAHEAD(3, <IDENTIFIER> "=" <IDENTIFIER>)
		id = Name()
		"="
		tr = Type()
		{ n = mkTypeAssign(id, modifiers,true); n.super_types += tr; }
	|
		LOOKAHEAD(3, <IDENTIFIER> (TypeOperatorChar()|<OPERATOR_LRBRACKETS>|"...") <IDENTIFIER>)
		{ n = new TypeOpDef(); }
		id     = Name()		{ n.arg = mkTypeAssign(id, new ASTModifiers(),true); }
		(	et   = Operator()            { n.op = et.ident; }
		|	t    = <OPERATOR_LRBRACKETS> { n.op = "[]"; }
		|	t    = "..."                 { n.op = "..."; }
		)
		n.dtype = Type()
	|
		tr = Type()
		id = Name()
		{ n = mkTypeAssign(id, modifiers,true); n.super_types += tr; }
	) ";"
	{ return n; }
}

Opdef Opdef(ASTModifiers modifiers) :
{ SymbolRef id; EToken op; ConstIntExpr ce; ConstStringExpr cs; Opdef opd = new Opdef(); }
{
	"operator"							{ opd.pos = getToken(0).getPos(); }
	(
		(
			op = Operator()            { opd.setImage(op); }
		|	id = NameRef()             { opd.setImage(id); }
		)
		","
		// FX,FY,XF,YF,XFX,YFX,XFY,YFY
		id = NameRef()                 { opd.setMode(id); }
		","
		ce = IntConstExpression()		{ opd.setPriority(ce); }
	|
		cs = StringConstExpression()	{ opd.decl = cs.value; }
		[ "," ]
		ce = IntConstExpression()		{ opd.setPriority(ce); }
	)
	";"
	{ return opd; }
}

KievSyntax SyntaxDeclaration(ASTModifiers modifiers, NameSpace parent) :
{ KievSyntax stx; Symbol name; ComplexTypeDecl oldClazz; }
{
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>	// "syntax"
	name = Name()
	{
		stx = (KievSyntax)mkStruct(name, new KievSyntax(), 0, modifiers, parent);
	}
	[
		"extends"
		stx.super_types += Type()
		( "," stx.super_types += Type()	)*
	]
	{ parent.members += stx; oldClazz = curClazz; curClazz = stx; }
	try {
		"{"
		(	LOOKAHEAD({ getToken(1).kind != RBRACE })
			modifiers = Modifiers()
			(
				stx.members += Typedef(modifiers)
			|	stx.members += Opdef(modifiers)
			|	stx.members += Import(modifiers)
			)
		)*
		"}"
	} finally { curClazz = oldClazz; }
	{ return stx; }
}

ComplexTypeDecl MetaTypeDeclaration(ASTModifiers modifiers, ASTNode parent) :
{ ComplexTypeDecl tdecl; Symbol name; TypeRef tp; ComplexTypeDecl oldClazz; TypeConstr[] args; }
{
	"metatype"
	name = Name()
	{
		tdecl = mkMetaType(name, modifiers, (NameSpace)parent);	
	}
	[
		args = ClazzArguments() { tdecl.args.addAll(args); }
	]
	[
		"extends"
		tdecl.super_types += Type()
		( "," tdecl.super_types += Type()	)*
	]
	{ oldClazz = curClazz; curClazz = null; }
	try {
		TypeBodyDeclaration(tdecl)
	} finally { curClazz = oldClazz; }
	{ return tdecl; }
}

Struct TypeDeclaration(ASTModifiers modifiers, ASTNode parent) :
{ Struct clazz; Symbol name; ComplexTypeDecl oldClazz; TypeConstr[] args; }
{
	(
		"class"
		name = Name()
		{
			clazz = mkStruct(name, new JavaClass(), 0, modifiers, parent);
		}
		[
			args = ClazzArguments() { clazz.args.addAll(args); }
		]
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
		[
			"implements"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	|	"interface"
		name = Name()
		{
			clazz = mkStruct(name, new JavaInterface(), ACC_INTERFACE, modifiers, parent);
		}
		[
			args = ClazzArguments() { clazz.args.addAll(args); }
		]
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	|	"@interface"
		(	name = Name()
		|	name = KeywordAsName()
		)
		{
			clazz = mkStruct(name, new JavaAnnotation(), ACC_INTERFACE|ACC_ANNOTATION, modifiers, parent);
		}
	|	"enum"
		name = Name()
		{
			clazz = mkStruct(name, new JavaEnum(), ACC_ENUM|ACC_STATIC, modifiers, parent);
		}
	|	"view"
		name = Name()
		{
			clazz = mkStruct(name, new KievView(), ACC_VIRTUAL, modifiers, parent);
			KievView kview = (KievView)clazz;
		}
		[
			args = ClazzArguments() { clazz.args.addAll(args); }
		]
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("of") })
		<IDENTIFIER> // "of"
		kview.view_of = NArrType()
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
		[
			"implements"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	)
	{ oldClazz = curClazz; curClazz = clazz; }
	try {
		TypeBodyDeclaration(clazz)
	} finally { curClazz = oldClazz; }
	{ return clazz; }
}

void TypeBodyDeclaration(ComplexTypeDecl clazz) :
{ ASTModifiers modifiers; SpacePtr clazz_members = clazz.getSpacePtr("members"); }
{
	"{"
	(
		LOOKAHEAD({ clazz.isEnum() })
		{ JavaEnum enum_clazz = (JavaEnum)clazz; }
		modifiers = Modifiers()
		enum_clazz.enum_fields += EnumFieldDeclaration(modifiers)
		(	","
			modifiers = Modifiers()
			enum_clazz.enum_fields += EnumFieldDeclaration(modifiers)
		)*
		[ ";" ]
	)?
	(
		LOOKAHEAD({ getToken(1).kind != RBRACE })
		{ comments_alone(clazz_members); }
		modifiers = Modifiers()
		(	LOOKAHEAD({ getToken(1).kind == LBRACE })
			clazz.members += Initializer(modifiers)
		|	LOOKAHEAD(1)
			clazz.members += InvariantDeclaration(modifiers) [ ";" ]
		|	LOOKAHEAD(1)
			clazz.members += TypeDeclaration(modifiers, clazz) [ ";" ]
		|	LOOKAHEAD(1)
			clazz.members += MemberArgDecl(modifiers)
		|	LOOKAHEAD(1)
			clazz.members += CaseTypeDeclaration(modifiers, (Struct)clazz)
		|
			//LOOKAHEAD( "rule" <IDENTIFIER> "(" )
			LOOKAHEAD(3, <IDENTIFIER> <IDENTIFIER> "(", { getToken(1).image.equals("rule") })
			clazz.members += RuleDeclaration(modifiers)
		|
			LOOKAHEAD(0)
			clazz.members += FieldOrMethodDecl(modifiers)
		)
	)*
	{ comments_alone(clazz_members); }
	"}"
}

DNode FieldOrMethodDecl(ASTModifiers modifiers) :
{ TypeConstr[] args; TypeRef dtype; DNode res = null; }
{
	(
		args = ClazzArguments()
		(
			LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
			res = ConstructorDeclaration(modifiers, args)
		|
			dtype = Type()
			res = MethodDeclaration(modifiers, args, dtype)
		)
	|
		LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
		res = ConstructorDeclaration(modifiers, null)
	|
		dtype = Type()
		(
			LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
			res = MethodDeclaration(modifiers, null, dtype)
		|
			LOOKAHEAD(0)
			res = FieldDecl(modifiers, dtype)
		)
	)
	{ return res; }
}


Field EnumFieldDeclaration(ASTModifiers modifiers) :
{ Symbol id; Field f; NewEnumExpr ne; }
{
	id = Name()
	{ f = mkEnumField(id, modifiers); }
	(
		":"
		f.alt_enum_id = StringConstExpression()
	|
		"("
			{ ne = new NewEnumExpr(); f.init = ne; }
			[	LOOKAHEAD({ getToken(1).kind != RPAREN })
				ne.args += ExpressionColon()
				(	"," ne.args += ExpressionColon()	)*
			]
		")"
	|
		{}
	)
	{ return f; }
}

Struct CaseTypeDeclaration(ASTModifiers modifiers, Struct parent) :
{ Symbol name; PizzaCase clazz; TypeConstr[] args; }
{
	"case"
	name = Name()
	{
		clazz = (PizzaCase)mkStruct(name, new PizzaCase(), ACC_STATIC|ACC_FINAL, modifiers, parent);
		clazz.setSingleton(true);
	}
	[
		args = ClazzArguments() { clazz.args.addAll(args); }
	]
	[
	"(" { clazz.setSingleton(false); }
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			clazz.case_fields += CaseTypeField(modifiers)
			(
				","
				modifiers = Modifiers()
				clazz.case_fields += CaseTypeField(modifiers)
			)*
		)?
	")"
	]
	";"
	{ return clazz; }
}


TypeConstr[] ClazzArguments() :
{ TypeConstr[] args = new TypeConstr[0]; TypeConstr arg; }
{
	("<" | <LANGLE>)
		arg = ArgumentDeclaration()
		{ args = (TypeConstr[])Arrays.append(args,arg); }
		(	","
			arg = ArgumentDeclaration()
			{ args = (TypeConstr[])Arrays.append(args,arg); }
		)*
	(">" | <RANGLE>)
	{ return args; }
}

TypeDef MemberArgDecl(ASTModifiers modifiers) :
{ Symbol name; TypeDef arg; TypeRef t; }
{
	("typedef"|"type")
	(
		name      = Name()
		(
			"="
			{ arg = mkTypeAssign(name,modifiers,true); }
			t = Type() { arg.super_types += t; }
			";"
		|
			{ arg = mkTypeConstr(name,modifiers,true); }
			(
				<OPERATOR_UPPER_BOUND> t = Type() { arg.super_types.add(t);}
			|	<OPERATOR_LOWER_BOUND> t = Type() { arg.lower_bound.add(t);}
			)+
			";"
		)
	)
	{ return arg; }
}

TypeConstr ArgumentDeclaration() :
{ ASTModifiers modifiers; Symbol name; TypeConstr arg; TypeRef tr; TypeVariance variance = null; }
{
	modifiers = Modifiers()
	(
		LOOKAHEAD( <OPERATOR> /*, { getToken(1).image.equals("+") || getToken(1).image.equals("-") || getToken(1).image.equals("*") } */)
		//"+" | "-" | "*"
		<OPERATOR>
		{
			String img = getToken(0).image;
			if (img.equals("+"))
				variance = TypeVariance.CO_VARIANT;
			else if (img.equals("-"))
				variance = TypeVariance.CONTRA_VARIANT;
			else if (img.equals("*"))
				variance = TypeVariance.IN_VARIANT;
		}
	)?
	name      = Name()
	{
		arg = mkTypeConstr(name,modifiers,true); arg.setAbstract(true);
		if (variance != null)
			arg.variance = variance;
	}
	[
		"extends"
		tr = Type() { arg.super_types.add(tr); }
		(	LOOKAHEAD( <OPERATOR>, { getToken(1).image.equals("&") })
			<OPERATOR>
			tr = Type() { arg.super_types.add(tr); }
		)*
	]
	[
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("super") }) //"super"
		<IDENTIFIER>
		tr = Type() { arg.lower_bound.add(tr); }
		(	LOOKAHEAD( <OPERATOR>, { getToken(1).image.equals("&") })
			<OPERATOR>
			tr = Type() { arg.lower_bound.add(tr); }
		)*
	]
	(
		<OPERATOR_UPPER_BOUND> tr = Type() { arg.super_types.add(tr);}
	|	<OPERATOR_LOWER_BOUND> tr = Type() { arg.lower_bound.add(tr);}
	)*
	{ return arg; }
}

void Access(ASTModifiers modifiers) :
{ int acc; 	int accflags = 0; int offset = 6; MetaAccess ma; }
{
	(
		"@access"		{ ma = new MetaAccess(); }
	|	"@public"		{ ma = new MetaAccess("public"); }
	|	"public"		{ ma = new MetaAccess("public"); }
	|	"@protected"	{ ma = new MetaAccess("protected"); }
	|	"protected"		{ ma = new MetaAccess("protected"); }
	|	"@private"		{ ma = new MetaAccess("private"); }
	|	"private"		{ ma = new MetaAccess("private"); }
	)
	{ modifiers += ma; }
	(
		<COLON1> // ":"
		acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		]]]
		{ ma.setFlags(accflags); }
	|	<OPEN_ACCESS> // "("
		acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		]]]
		<CLOSE_ACCESS> // ")"
		{ ma.setFlags(accflags); }
	)?
}

int AccessSpec() :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

void SpecialAnnotation(ASTModifiers modifiers) :
{ MetaPacked mp; MetaThrows mthr; MetaUUID muuid; TypeNameRef thr; ConstIntExpr ice; ConstStringExpr cs; SymbolRef nr; }
{
	  "@singleton"		{ modifiers += new MetaSingleton(); }
	| "@mixin"			{ modifiers += new MetaMixin(); }

	| "@forward"		{ modifiers += new MetaForward(); }
	| "@unerasable"		{ modifiers += new MetaUnerasable(); }
	| "@virtual"		{ modifiers += new MetaVirtual(); }
	| "@macro"			{ modifiers += new MetaMacro(); }
	
	| "static"			{ modifiers += new MetaStatic(); }
	| "@static"			{ modifiers += new MetaStatic(); }
	
	| "abstract"		{ modifiers += new MetaAbstract(); }
	| "@abstract"		{ modifiers += new MetaAbstract(); }

	| "final"			{ modifiers += new MetaFinal(); }
	| "@final"			{ modifiers += new MetaFinal(); }
	
	| "native"			{ modifiers += new MetaNative(); }
	| "@native"			{ modifiers += new MetaNative(); }
	
	| "synchronized"	{ modifiers += new MetaSynchronized(); }
	| "@synchronized"	{ modifiers += new MetaSynchronized(); }

	| "transient"		{ modifiers += new MetaTransient(); }
	| "@transient"		{ modifiers += new MetaTransient(); }

	| "volatile"		{ modifiers += new MetaVolatile(); }
	| "@volatile"		{ modifiers += new MetaVolatile(); }
	
	| "@packed"
		{ mp = new MetaPacked(); }
		(
			"("
						ice = IntConstExpression() { mp.size = ice.value; }
			[	","		nr  = NameRef() { mp.fld = (SymbolRefFld)nr; }
				","		ice = IntConstExpression() { mp.offset = ice.value; }
			]
			")"
		|
			":" 	ice = IntConstExpression() { mp.size = ice.value; }
			[
			","		nr  = NameRef() { mp.fld = (SymbolRefFld)nr; }
			","		ice = IntConstExpression() { mp.offset = ice.value; }
			]
		|
			{}
		)
		{ modifiers += mp; }

	| "@throws"
		{ mthr = new MetaThrows(); }
		(
			thr = TypeQName() { mthr.add(thr); }
			( "," thr = TypeQName() { mthr.add(thr); } )*
		|
			"(" [ LOOKAHEAD(2) <IDENTIFIER> "="] ["{"]
			thr = TypeQName() { mthr.add(thr); }
			( "," thr = TypeQName() { mthr.add(thr); } )*
			 ["}"] ")"
		)
		{ modifiers += mthr; }

	| "@uuid"
		{ muuid = new MetaUUID(); }
		"("
		cs = StringConstExpression()
		")"
		{ muuid.value = cs.value; modifiers += muuid; }
}

SymbolRef KeywordAsNameRef() :
{ Token t; SymbolRef id; }
{
	(
		t="alias"
	|	t="throws"
	)
	{
		id = new SymbolRef();
		id.set(t);
		return id;
	}
}

Symbol KeywordAsName() :
{ Token t; Symbol id; }
{
	(
		t="alias"
	|	t="throws"
	)
	{
		id = new Symbol();
		id.set(t);
		return id;
	}
}

UserMeta Annotation() :
{ SymbolRef id; MetaValue v; }
{
	{ UserMeta n = new UserMeta(); }
	"@"
	(
		id = QName()
	|	id = KeywordAsNameRef()
	)
	{	n.pos = id.pos;	 n.decl.name = id.name; }
	[	LOOKAHEAD({ getToken(1).kind == LPAREN })
		"("
		[	LOOKAHEAD({ getToken(1).kind != RPAREN })
			(
				LOOKAHEAD( <IDENTIFIER> "=" )
				AnnotationValues(n)
			|
				LOOKAHEAD( 0 )
				v = AnnotationValueAny(new SymbolRef("value")) { n.set(v); }
			)
		]
		")"
	]
	{ return n; }
}

void AnnotationValues(UserMeta m) :
{ SymbolRef id; MetaValue v; }
{
	id = NameRef()
	"="
	v = AnnotationValueAny(id)
	{ m.set(v); }
	(
		","
		id = NameRef()
		"="
		v = AnnotationValueAny(id)
		{ v.ident = id.name; v.pos = id.pos; m.set(v); }
	)*
}

MetaValue AnnotationValueAny(SymbolRef id) :
{ ASTNode n; MetaValue v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	|
		v = AnnotationValueValueArrayInitializer(id)
	|
		LOOKAHEAD( 0 )
		n = Expression()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueScalar AnnotationValueScalar(SymbolRef id) :
{ ASTNode n; MetaValueScalar v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	|
		LOOKAHEAD( 0 )
		n = Expression()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueArray AnnotationValueValueArrayInitializer(SymbolRef id) :
{ MetaValueScalar n; MetaValueArray v; }
{
	{ v = new MetaValueArray(id); }
	"{"
	[	LOOKAHEAD({ getToken(1).kind != RBRACE })
		n = AnnotationValueScalar(null) { v.values.add(~n.value); }
		(	","
			n = AnnotationValueScalar(null) { v.values.add(~n.value); }
		)*
	]
	"}"
	{ return v; }
}


Field FieldDecl(ASTModifiers modifiers, TypeRef dtype) :
{ boolean old_declMode; Symbol id; ENode init; Field fld; }
{
	{
		old_declMode = declMode;
		declMode = false;
		init = null;
	}
	try {
		id = Name()
		[	"="	init = VariableInitializer()	]
		{
			fld = mkField(id, modifiers, dtype, init);
		}
		";"
		{	return fld;	}
	} finally { declMode = old_declMode; }
}

void LocalVarDecls(ASTModifiers modifiers, RuleMethod meth) :
{ TypeRef dtype; }
{
	dtype = Type()
	meth.localvars += RuleVarDecl(modifiers, dtype, true)
	(	","
		meth.localvars += RuleVarDecl(modifiers, dtype, false)
	)*
	";"
}

LVar RuleVarDecl(ASTModifiers modifiers, TypeRef dtype, boolean first) :
{ Token t; Symbol id; LVar lv; }
{
	id = Name()
	{ lv = mkRuleVar(id, modifiers, dtype, first); }
	[
		"="
		lv.init = VariableInitializer()
	]
	{ return lv; }
}

void VarDecls(ASTModifiers modifiers, SpacePtr stats) :
{ boolean old_declMode; TypeRef dtype; Symbol id; ENode init; Var var; }
{
	{
		old_declMode = declMode;
		declMode = false;
		init = null;
		var = null;
	}
	try {
		dtype = Type()
		id = Name()
		[	"="	init = VariableInitializer()	]
		{
			var = mkVar(id, new ASTModifiers(), dtype);
			modifiers.copyToNode(var.meta);
			var.init = init;
			stats += var;
		}
		(
			","
			id = Name()
			[	"="	init = VariableInitializer()	]
			{
				var = mkVar(id, new ASTModifiers(), dtype.ncopy());
				modifiers.copyToNode(var.meta);
				var.init = init;
				stats += var;
			}
		)*
	} finally { declMode = old_declMode; }
}

ENode VariableInitializer() :
{ ENode e; }
{
	(
		e = ArrayInitializer()
	|
		LOOKAHEAD( 0 )
		e = ExpressionColon()
	)
	{ return e; }
}

ENode ArrayInitializer() :
{ NewInitializedArrayExpr e = new NewInitializedArrayExpr(); e.pos = getToken(1).getPos(); }
{
	"{"
	[	LOOKAHEAD(2)
		e.args += VariableInitializer()
		(	LOOKAHEAD(2)
			","
			e.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ return e; }
}

Field CaseTypeField(ASTModifiers modifiers) :
{ Token t; TypeRef tp; Symbol id; }
{
	tp = Type()
	id = Name()
	{
		return mkCaseField(id, modifiers, tp);
	}
}

Var PizzaCaseFormalParameter(ASTModifiers modifiers) :
{ Token t; TypeRef tp; Symbol id; }
{
	(
		LOOKAHEAD({ getToken(1).image.equals("_") })
		id = Name() { tp = new TypeRef(Type.tpVoid); tp.pos = id.pos; }
	|
		tp = Type()
		id = Name()
	)
	{ return mkVar(id, modifiers, tp); }
}

LVar MethodFormalParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; TypeRef st=null; Symbol id; }
{
	[
		":"
		st = Type()
	]
	id = Name()
	{ return mkFormPar(id, modifiers, tp, st); }
}

LVar MethodVarargsParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; Symbol id = null; }
{
	t = "..."
	[ id = Name() ]
	{
		if (tp == null)
			tp = new TypeExpr(new TypeRef(Type.tpObject), t);
		else
			tp = new TypeExpr(tp, t);
		tp.pos = t.getPos();
		if (id == null) {
			id = new Symbol(t.getPos(), Constants.nameVarArgs);
		}
		return mkVarargPar(id, modifiers, tp);
	}
}

LVar FormalParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; Symbol id; }
{
	id = Name()
	{ return mkFormPar(id, modifiers, tp, null); }
}

MetaThrows Throws() :
{ MetaThrows n = new MetaThrows(); TypeNameRef thr; }
{
	"throws"
	thr = TypeQName() { n.add(thr); }
	(
		","
		thr = TypeQName() { n.add(thr); }
	)*
	{ return n; }
}


Symbol Alias() :
{ Token t; Symbol a; SymbolRef id; EToken op; ConstIntExpr ce; ConstStringExpr cs; }
{
	(
		"alias"
		(
			a = Name()
			[
				"operator"
				{ String opmode = a.sname; a = new ASTOperatorAlias(); a.setMode(opmode); }
				(
					op = Operator()				{ a.setImage(op); }
				|	id = NameRef()				{ a.setImage(id); }
				|	<OPERATOR_LRBRACKETS>		{ a.image = "[]"; }
				|	"new"						{ a.image = "new"; }
				//|	"$cast"						{ a.image = "$cast"; }
				)
			]
		|	"operator"
			cs = StringConstExpression()
			{ a = new ASTOperatorAlias(); a.setName(cs); }
		)
	|	"operator"
		cs = StringConstExpression()
		{ a = new ASTOperatorAlias(); a.setName(cs); }
	)
	{ return a; }
}

void SkipBlock() :
{}
{
	LOOKAHEAD({ interface_only })
	"{"
	{
		Token tk = getToken(0);
		int depth = 1;
		do {
			tk = getNextToken();
			if( tk.kind == LBRACE ) depth++;
			else if( tk.kind == RBRACE ) depth--;
		} while( depth > 0 );
	}
}
/*
ENode MaybeSkipBlock(ASTNode target) :
{ ENode bl = null; }
{
	(
		LOOKAHEAD({ interface_only })
		"{"
		{
			Token tk = getToken(0);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
		}
	|
		LOOKAHEAD({ target instanceof RuleMethod })
		bl = RuleBlock()
	|
		LOOKAHEAD({ target instanceof Method && ((Method)target).isMacro() })
		bl = RewriteMatch()
	|
		bl = Block()
	)
	{ return bl; }
}
*/
Method MethodDeclaration(ASTModifiers modifiers, TypeConstr[] args, TypeRef ret) :
{ Token t; Method m, oldMethod; Symbol id; ConstStringExpr cor; MetaThrows thr; TypeRef ptype; }
{
	id = Name()
	{
		m = mkMethod(id,modifiers,ret);
		if (args != null)
			m.targs.addAll(args);
		oldMethod = curMethod;
		curMethod = m;
	}
	try {
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			(	m.params += MethodFormalParameter(modifiers,ptype)
			|	m.params += MethodVarargsParameter(modifiers,ptype)
				{ m.setVarArgs(true); }
			)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				(	m.params += MethodFormalParameter(modifiers,ptype)
				|	m.params += MethodVarargsParameter(modifiers,ptype)
					{ m.setVarArgs(true); }
				)
			)*
		)?
	")"
	(
		m.aliases += Alias()
	)*
	[	thr = Throws()	{ m.setMeta(thr); } ]
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && m.isMacro() })
		m.body = RewriteMatch() [ ";" ]
	|	LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|	LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = Block() [ ";" ]
	|	"default" m.body = AnnotationValueAny(new SymbolRef(getToken(0).getPos(),m)) ";"
	|	"continue" cor = StringConstExpression() { m.body = CoreExpr.makeInstance(cor.pos, cor.value); } ";"
	|	";"
	)
	} finally { curMethod = oldMethod; }
	{ return m; }
}

Constructor ConstructorDeclaration(ASTModifiers modifiers, TypeConstr[] args) :
{ Token t; Constructor m; Symbol id; MetaThrows thr; Method oldMethod; TypeRef ptype; }
{
	id = Name()
	{
		if( !id.sname.equals(curClazz.sname) )
			Kiev.reportError(id,"Return type missed or bad constructor name "+id);
		m = mkConstructor(id,modifiers); 
		if (args != null)
			m.targs.addAll(args);
		oldMethod = curMethod;
		curMethod = m;
	}
	try {
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			(	m.params += MethodFormalParameter(modifiers,ptype)
			|	m.params += MethodVarargsParameter(modifiers,ptype)
				{ m.setVarArgs(true); }
			)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				(	m.params += MethodFormalParameter(modifiers,ptype)
				|	m.params += MethodVarargsParameter(modifiers,ptype)
					{ m.setVarArgs(true); }
				)
			)*
		)?
	")"
	(
		m.aliases += Alias()
	)*
	[	thr = Throws()	{ m.setMeta(thr); } ]
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|	LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = Block() [ ";" ]
	|	";"
	)
	} finally { curMethod = oldMethod; }
	{ return m; }
}

WBCCondition RequareDeclaration() :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondRequire;
	}
	"require"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	|
		LOOKAHEAD( 0 )
		n.body = CondBlock()
	)
	{ return n; }
}


WBCCondition EnsureDeclaration() :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondEnsure;
	}
	"ensure"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	|
		LOOKAHEAD( 0 )
		n.body = CondBlock()
	)
	{ return n; }
}

WBCCondition InvariantDeclaration(ASTModifiers modifiers) :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondInvariant;
	}
	"invariant"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|	LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	)
	{ return n; }
	
}

RuleMethod RuleDeclaration(ASTModifiers modifiers) :
{ RuleBlock bl; RuleMethod m; Symbol id; Method oldMethod; TypeRef ptype; }
{
	<IDENTIFIER> // "rule"
	id = Name()
	{ m = mkRuleMethod(id, modifiers, new TypeRef(Type.tpRule)); oldMethod = curMethod; curMethod = m; }
	try {
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			m.params += FormalParameter(modifiers,ptype)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				m.params += FormalParameter(modifiers,ptype)
			)*
		)?
	")"
	(
		m.aliases += Alias()
	)*
	(
		modifiers = Modifiers()
		LocalVarDecls(modifiers,m)
	)*
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|
		LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = RuleBlock() [ ";" ]
	|
		";"
	)
	} finally { curMethod = oldMethod; }
	{ return m; }
}

Initializer Initializer(ASTModifiers modifiers) :
{
	Initializer n = mkInitializer(getToken(0).getPos(),modifiers);
}
{
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|
		LOOKAHEAD(0)
		n.body = Block() [ ";" ]
	)
	{ return n; }
}



/*
 * Type, name and expression syntax follows.
 */


TypeRef Type() :
{ TypeRef res; }
{
	(
		LOOKAHEAD ( (<IDENTIFIER> ".")+ "type" )
		res = PathType()
	|
		res = TypeExpr()
	|
		res = ClosureType()
	)
	{ return res; }
}

TypeRef TypeExpr() :
{ TypeRef res; Token t; }
{
	res = TypeWithArgs()
	(
		(	t = TypeOperatorChar()
		|	t = <OPERATOR_LRBRACKETS>
		)
		{ res = new TypeExpr(res,t); }
	)*
	{ return res; }
}

PathTypeRef PathType() :
{ Token t; ENode e; }
{
	t = <IDENTIFIER>			{ e = new EToken(t,ETokenKind.IDENTIFIER); }
	"."
	(
		t = <IDENTIFIER>		{ e = new AccessExpr(t.getPos(),e,new EToken(t,ETokenKind.IDENTIFIER).ident); }
		"."
	)*
	t="type"
	{ PathTypeRef tr = new PathTypeRef(e); tr.pos = t.getPos(); return tr; }
}

TypeNameRef TypeQName() :
{ SymbolRef id; TypeNameRef res; }
{
	id = NameRef() { res = new TypeNameRef(id.name); res.pos = id.pos; }
	(	LOOKAHEAD("." <IDENTIFIER>)
		"."
		id = NameRef()  { res.ident = res.ident + '\u001f' + id.name; res.qualified = true; }
	)*
	{ return res; }
}

TypeRef TypeWithWildcard() :
{ TypeRef res; }
{
	(
		// "?"
		LOOKAHEAD({getToken(1).kind == OPERATOR && getToken(1).image.equals("?")})
		<OPERATOR>
		(
			"extends"
			res = Type()
			{ res = new TypeExpr(res, Operator.PostTypeWildcardCoVariant); }
		|
			LOOKAHEAD({getToken(1).kind == IDENTIFIER && getToken(1).image.equals("super")})
			<IDENTIFIER>
			res = Type()
			{ res = new TypeExpr(res, Operator.PostTypeWildcardContraVariant); }
		|
			{ res = new TypeExpr(StdTypes.tpObject, Operator.PostTypeWildcardCoVariant); res.pos = getToken(0).getPos(); }
		)
	|
		res = Type()
	)
	{ return res; }
}

TypeRef TypeWithArgs() :
{ SymbolRef qname; TypeRef res; }
{
	qname = QName()
	(	LOOKAHEAD({ getToken(1).kind == LT || getToken(1).kind == LANGLE })
		("<" | <LANGLE>)
			{ res = new TypeNameArgsRef(qname.name); }
			res.args += Type()
			(	LOOKAHEAD({ getToken(1).kind == COMMA })
				","
				res.args += Type()
			)*
		(">" | <RANGLE>)
		(	LOOKAHEAD("." <IDENTIFIER>)
			"."
			qname = QName()
			{ res = new TypeInnerNameRef(res, qname.name); }
			("<" | <LANGLE>)
				res.args += Type()
				(	LOOKAHEAD({ getToken(1).kind == COMMA })
					","
					res.args += Type()
				)*
			(">" | <RANGLE>)
		)*
	|
		{ res = new TypeNameRef(qname.name); }
	)
	{ return res; }
}

TypeRef NArrType() :
{ TypeRef res; Token t; }
{
	res = TypeWithArgs()
	(	LOOKAHEAD(2)
		(
			t = TypeOperatorChar()			{ res = new TypeExpr(res,t); }
		|
			t = <OPERATOR_LRBRACKETS>		{ res = new TypeExpr(res,t); }
			t = TypeOperatorChar()			{ res = new TypeExpr(res,t); }
		)
		{ res = new TypeExpr(res,t); }
	)*
	{ return res; }
}

TypeRef ClosureType() :
{ Token t; TypeClosureRef n = new TypeClosureRef(); }
{
	t="(" { n.pos = t.getPos(); }
	[
		n.args += Type()
		( "," n.args += Type() )*
	]
	")" "->" n.ret = Type()
	{ return n; }
}

LVarExpr Var() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		LVarExpr id = new LVarExpr();
		id.set(t);
		return id;
	}
}

Symbol Name() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		Symbol id = new Symbol();
		id.set(t);
		return id;
	}
}

SymbolRef NameRef() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		SymbolRef id = new SymbolRef();
		id.set(t);
		return id;
	}
}

SymbolRef QName() :
{ SymbolRef id; SymbolRef id2; }
{
	id = NameRef()
	(
		LOOKAHEAD(2)
		"."
		id2 = NameRef()
		{ id.name = id.name+'\u001f'+id2.name; }
	)*
	{
		id.qualified = true;
		return id;
	}
}

EToken Identifier() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		return new EToken(t,ETokenKind.IDENTIFIER);
	}
}

/*
 * Expression syntax follows.
 */

ENode CommaExpression() :
{ ENode e; CommaExpr ce = null; }
{
	e = Expression()
	(
		","
		{ if (ce==null) ce = new CommaExpr(e); }
		ce.exprs += Expression()
	)*
	{ return ce == null ? e : ce; }
}

ASTRuleNode RuleOrExpression() :
{ ASTRuleNode e; RuleOrExpr r = null; }
{
	e = RuleAndExpression()
	(
		";"
		{ if (r==null) { r = new RuleOrExpr(e); r.pos = getToken(0).getPos();} }
		r.rules += RuleAndExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleAndExpression() :
{ ASTRuleNode e; RuleAndExpr r = null; }
{
	e = RuleExpression()
	(
		","
		{ if (r==null) { r = new RuleAndExpr(e); r.pos = getToken(0).getPos();} }
		r.rules += RuleExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleExpression() :
{ ASTRuleNode r; }
{
	(
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_THE
		})
		r = RuleIstheExpression()
	|
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_ONE_OF
		})
		r = RuleIsoneofExpression()
	|
		LOOKAHEAD({getToken(1).kind == PCUT})
		r = RuleCutExpression()
	|
		LOOKAHEAD({getToken(1).kind == LBRACE})
		"{" r = RuleOrExpression() "}"
	|
		LOOKAHEAD({getToken(1).kind == WHILE})
		"while"
		{ r = new RuleWhileExpr(); }
		r.expr = Expression() 
		[
			":"
			r.bt_expr = Expression()
		]
	|
		LOOKAHEAD(0)
		{ r = new RuleExpr(); }
		r.expr = Expression()
		[
			":"
			r.bt_expr = Expression()
		]
	)
	{ return r; }
}

RuleIstheExpr RuleIstheExpression() :
{ Token t; RuleIstheExpr r = new RuleIstheExpr(); }
{
	r.var = Var()
	t = "?=" { r.pos = t.getPos(); }
	r.expr = Expression()
	{ return r; }
}

RuleIsoneofExpr RuleIsoneofExpression() :
{ Token t; RuleIsoneofExpr r = new RuleIsoneofExpr(); }
{
	r.var = Var()
	t = "@=" { r.pos = t.getPos(); }
	r.expr = Expression()
	{ return r; }
}

RuleCutExpr RuleCutExpression() :
{ RuleCutExpr r = new RuleCutExpr(); }
{
	"$cut"
	{
		r.pos = getToken(0).getPos();
		return r;
	}
}

Token TypeOperatorChar() :
{ Token t; }
{
	(
		t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR_SUPERSCRIPT_PLUS>
	|	t=<OPERATOR_SUPERSCRIPT_MINUS>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar() :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<LT>
	|	t=<GT>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR_UPPER_BOUND>
	|	t=<OPERATOR_LOWER_BOUND>
	|	t=<OPERATOR>
	)
	{ return t; }
}

EToken Operator() :
{ Token t; String image; int pos; }
{
	(
		t=OperatorChar()
		{ image = t.image; pos = t.getPos(); }
		(
			LOOKAHEAD({ operatorLA() })
			t=OperatorChar()
			{ image = image+t.image; }
		)*
	|
		t=":=" { image = t.image; pos = t.getPos(); }
	|
		t="->" { image = t.image; pos = t.getPos(); }
	|
		t="?=" { image = t.image; pos = t.getPos(); }
	|
		t="@=" { image = t.image; pos = t.getPos(); }
	|
		"operator" t=<IDENTIFIER>
		{
			pos = t.getPos();
			if (t.image.startsWith("#id\""))
				image = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
			else
				image = t.image;
		}
	)
	{	return new EToken(pos, image, ETokenKind.OPERATOR, true);		}
}

ENode ExpressionColonComma() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=":"	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|
		t=","	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		if (e.nodes.length == 1)
			return ~e.nodes[0];
		return e;
	}
}
ENode ExpressionColon() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=":"	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		if (e.nodes.length == 1)
			return ~e.nodes[0];
		return e;
	}
}
ENode ExpressionComma() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=","	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		if (e.nodes.length == 1)
			return ~e.nodes[0];
		return e;
	}
}
ENode Expression() :
{ ASTExpression e = new ASTExpression(); }
{
	(
		LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		if (e.nodes.length == 1)
			return ~e.nodes[0];
		return e;
	}
}

void ExpressionNoNo(ASTExpression e) :
{ Token t; ENode n; }
{
	(
		e.nodes += ConstExpression()
	|
		e.nodes += Identifier()
	|
		t="("	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		[
			n = ExpressionColonComma() { expandExpr(e,n); }
		]
		t=")"	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|
		t="["	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		e.nodes += ExpressionColonComma()
		t="]"	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|
		t=<LANGLE>		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		e.nodes += Type()
		(
			t=","	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); } 
			e.nodes += Type()
		)*
		t=<RANGLE>		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
	|
		t=<OPERATOR_LRBRACKETS>	{ e.nodes += new EToken(t.getPos(), "[]", ETokenKind.OPERATOR, true); }
	|
		t="."	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		(
			t="class"	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		|
			t="new"		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
			e.nodes += Type()
		|
			t="<"		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
			e.nodes += Type()
			(
				t=","	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); } 
				e.nodes += Type()
			)*
			t=">"		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		|
			t=<LANGLE>		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
			e.nodes += Type()
			(
				t=","	{ e.nodes += new EToken(t, ETokenKind.OPERATOR); } 
				e.nodes += Type()
			)*
			t=<RANGLE>		{ e.nodes += new EToken(t, ETokenKind.OPERATOR); }
		|
			{}
		)
	|
		e.nodes += AnonymouseClosure()
	|
		e.nodes += NewAny()
	|
		e.nodes += Operator()
	)
}

ENode NewAny() :
{ ENode n; TypeRef tp; Token t; }
{
	t="new"
	(
		//LOOKAHEAD("#")
		n = RewriteFactoryCall()
	|
		tp = NArrType()
		(
			//LOOKAHEAD((<OPERATOR_LRBRACKETS>)+ "{" )
			n = NewInitializedArrayExpression(tp)
		|
			//LOOKAHEAD("[" )
			n = NewArrayExpression(tp)
		|
			//LOOKAHEAD("(" )
			n = NewExpression(tp)
		)
	)
	{
		n.pos = t.getPos();
		return n;
	}
}

NewClosure AnonymouseClosure() :
{ ASTModifiers modifiers; TypeRef ptype; NewClosure nc = new NewClosure(getToken(1).getPos()); }
{
	"fun" "("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			nc.params += FormalParameter(modifiers,ptype)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				nc.params += FormalParameter(modifiers,ptype)
			)*
		)?
	")" "->"
    (
		LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(1).image.equals("rule") } )
		nc.type_ret = Type()
		nc.body = RuleBlock()
	|
		nc.type_ret = Type()
		nc.body = Block()
	)
	{ return nc; }
}

ConstExpr ConstExpression() :
{ ConstExpr ce; }
{
	(
		ce = BooleanConstExpression()
	|	ce = IntConstExpression()
	|	ce = LongConstExpression()
	|	ce = FloatConstExpression()
	|	ce = DoubleConstExpression()
	|	ce = CharConstExpression()
	|	ce = NullConstExpression()
	|	ce = StringConstExpression()
	)
	{ return ce; }
}

ConstBoolExpr BooleanConstExpression() :
{ Token t; }
{
	(
		t="true"
	|	t="false"
	)
	{ return (ConstBoolExpr)ConstExpr.fromSource(t); }
}

ConstIntExpr IntConstExpression() :
{ Token t; }
{
 	t=<INTEGER_LITERAL>
	{ return (ConstIntExpr)ConstExpr.fromSource(t); }
}

ConstLongExpr LongConstExpression() :
{ Token t; }
{
	t=<LONG_INTEGER_LITERAL>
	{ return (ConstLongExpr)ConstExpr.fromSource(t); }
}

ConstFloatExpr FloatConstExpression() :
{ Token t; }
{
	t=<FLOATING_POINT_LITERAL>
	{ return (ConstFloatExpr)ConstExpr.fromSource(t); }
}

ConstDoubleExpr DoubleConstExpression() :
{ Token t; }
{
	t=<DOUBLE_POINT_LITERAL>
	{ return (ConstDoubleExpr)ConstExpr.fromSource(t); }
}

ConstCharExpr CharConstExpression() :
{ Token t; }
{
	t=<CHARACTER_LITERAL>
	{ return (ConstCharExpr)ConstExpr.fromSource(t); }
}

ConstNullExpr NullConstExpression() :
{ Token t; }
{
	t="null"
	{ return (ConstNullExpr)ConstExpr.fromSource(t); }
}

ConstStringExpr StringConstExpression() :
{ Token t, t1; }
{
	t=<STRING_LITERAL>
	{ return (ConstStringExpr)ConstExpr.fromSource(t); }
}

NewExpr NewExpression(TypeRef tp) :
{
	boolean old_mode;
	Struct clazz;
	ComplexTypeDecl oldClazz;
	NewExpr ne = new NewExpr();
	ne.pos = tp.pos;
	ne.ntype = tp;
}
{
	//"new"
    //ne.ntype = NArrType()
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			ne.args += ExpressionColon()
			(	"," ne.args += ExpressionColon()	)*
		)?
	")"
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE })
		{
			old_mode = interface_only;
			interface_only = false;
			ne.clazz = clazz = mkStruct(null, new JavaAnonymouseClass(), ACC_FINAL, new ASTModifiers(), ne);
			oldClazz = curClazz;
			curClazz = clazz;
		}
		try {
			TypeBodyDeclaration(clazz)
		} finally {
			interface_only = old_mode;
			curClazz = oldClazz;
		}
	)?
	{ return ne; }
}

NewArrayExpr NewArrayExpression(TypeRef tp) :
{ NewArrayExpr ne; }
{
	//"new"
	//ne.ntype = NArrType()
	{
		NewArrayExpr ne = new NewArrayExpr();
		ne.pos = tp.pos;
		ne.ntype = tp;
	}
	(
		LOOKAHEAD(2)
		"["
		ne.args += Expression()
		"]"
	)+
	(	LOOKAHEAD({ getToken(1).kind == OPERATOR_LRBRACKETS })
		<OPERATOR_LRBRACKETS>
		{ ne.args += new NopExpr(); }
	)*
	{
		return ne;
	}
}

NewInitializedArrayExpr NewInitializedArrayExpression(TypeRef tp) :
{ NewInitializedArrayExpr ne; Token t; }
{
	//tn="new"
	//tr = NArrType()
	(
		t=<OPERATOR_LRBRACKETS> 
		{ tp = new TypeExpr(tp,t); }
	)+
	{ ne = new NewInitializedArrayExpr(tp.pos, (TypeExpr)tp, null); }
	"{"
	[
		ne.args += VariableInitializer()
		(	LOOKAHEAD(2)
			","
			ne.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ return ne; }
}


/*
 * Statement syntax follows.
 */

ENode Statement() :
{ ENode st; }
{
	(
	  LOOKAHEAD(2, <IDENTIFIER> ":")
	  st = LabeledStatement()
	| st = Block()
	| st = SwitchStatement()
	| st = IfStatement()
	| st = WhileStatement()
	| st = DoStatement()
	| st = ForStatement()
	| st = ForEachStatement()
	| st = BreakStatement()
	| st = ContinueStatement()
	| st = ReturnStatement()
	| st = ThrowStatement()
	| st = SynchronizedStatement()
	| st = WithStatement()
	| st = TryStatement()
	| st = GotoStatement()
	| st = IfRewr()
	| LOOKAHEAD(0)
	  st = StatementExpression()
	)
	{ return st; }
}

ENode LabeledStatement() :
{ LabeledStat st = new LabeledStat(); Symbol id; }
{
	id = Name() { st.lbl.sname = id.sname; st.pos = id.pos; }
	":"
	st.stat = Statement()
	{ return st; }
}

Block Block() :
{ boolean old_declMode; }
{
	"{"
	{
		Block bl = new Block();
		bl.pos = getToken(1).getPos();
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	(
			BlockStatement(bl.getSpacePtr("stats"))
		)*
	} finally { declMode = old_declMode; }
    "}"
	{ return bl; }
}

RuleBlock RuleBlock() :
{ boolean old_declMode; }
{
	"{"
	{
		RuleBlock bl = new RuleBlock();
		bl.pos = getToken(1).getPos();
		old_declMode = declMode;
		declMode = false;
	}
	try {
		bl.rnode = RuleOrExpression()
	} finally { declMode = old_declMode; }
	"}"
	{ return bl; }
}

Block CondBlock() :
{}
{
	{
		Block bl = new Block();
		bl.pos = getToken(1).getPos();
	}
	(
		"{"
			(
				bl.stats += CondStatement()
			)+
		"}"
	|
		bl.stats += CondStatement()
	)
	{ return bl; }
}

void BlockStatement(SpacePtr stats) :
{ boolean old_declMode; ASTModifiers modifiers; TypeRef tp; Var var; }
{
	{ comments_alone(stats); }
	(
		LOOKAHEAD(InBlockModifiersLA())
		(
			modifiers = Modifiers()
			(
				{ old_declMode = declMode; declMode = true; }
				try {
					stats += TypeDeclaration(modifiers, (ASTNode)stats.node)
				} finally { declMode = old_declMode; }
			|	LOOKAHEAD(0)
				VarDecls(modifiers, stats)
			)
		)
	|
		{ old_declMode = declMode; declMode = true; }
		try {
			stats += TypeDeclaration(new ASTModifiers(), (ASTNode)stats.node)
		} finally { declMode = old_declMode; }
	|
		LOOKAHEAD( Type() Name() )
		VarDecls(new ASTModifiers(), stats)
		";"
	|
		/* other statements */
		LOOKAHEAD(0)
		stats += Statement()
	)
}

CondStat CondStatement() :
{ Token t = getToken(1); CondStat st = new CondStat(); }
{
	st.cond = Expression()
	[
		":"
		{ t = null; }
		st.message = Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ConstStringExpr e = new ConstStringExpr(sb.toString());
			e.pos = pos;
			st.message = e;
		}
	}
	";"
	{ return st; }
}

ENode StatementExpression() :
{ ENode st; }
{
	(
		";" { st = new ExprStat(getToken(0).getPos(), null); } 
	|	st = ExpressionColonComma()
		[	LOOKAHEAD({ getToken(1).kind == SEMICOLON })
			";" { st = new ExprStat(st.pos, st); }
		]
	)
	{ return st; }
}

SwitchStat SwitchStatement() :
{ SwitchStat st = new SwitchStat(); }
{
	"switch"
	{ st.pos = getToken(0).getPos(); }
	"(" st.sel = ExpressionColonComma() ")"
	"{"
	(
		LOOKAHEAD( 1, "case" | "default" )
		st.cases += CaseStatements(st)
	)+
	"}"
	{ return st; }
}

CaseLabel CaseStatements(SwitchStat sw) :
{ CaseLabel st; }
{
	(
		LOOKAHEAD("case" QName() "(" )
		st = PizzaCase(sw)
	|
		st = NormalCase(sw)
	)
	{ return st; }
}

CaseLabel NormalCase(SwitchStat sw) :
{ CaseLabel c = new CaseLabel(); sw.stats += c; }
{
	(
		"case"	{ c.pos = getToken(0).getPos(); }
		c.val = Expression()
		":"
	|
		"default"	{ c.pos = getToken(0).getPos(); }
		":"
	)
	(
		BlockStatement(sw.getSpacePtr("stats"))
	)*
	{ return c; }
}

CaseLabel PizzaCase(SwitchStat sw) :
{ Token t; ASTModifiers modifiers; CaseLabel c = new CaseLabel(); sw.stats += c; }
{
	"case"		{ c.pos = getToken(0).getPos(); }
	c.val = TypeWithArgs()
	"("
	(	LOOKAHEAD({ getToken(1).kind != RPAREN })
		modifiers = Modifiers()
		c.pattern += PizzaCaseFormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			c.pattern += PizzaCaseFormalParameter(modifiers)
		)*
	)?
	")" ":"
	(
		BlockStatement(sw.getSpacePtr("stats"))
	)*
	{ return c; }
}

IfElseStat IfStatement() :
{ IfElseStat st = new IfElseStat(); EToken not = null; }
{
	"if"
	{ st.pos = getToken(0).getPos(); }
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")"
	st.thenSt = Statement()
	[	LOOKAHEAD(1)
		"else"
		st.elseSt = Statement()
	]
	{ return st; }
}

WhileStat WhileStatement() :
{ WhileStat st = new WhileStat(); EToken not = null; }
{
	"while"
	{ st.pos = getToken(0).getPos(); }
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")"
    st.body = Statement()
	{ return st; }
}

DoWhileStat DoStatement() :
{ DoWhileStat st = new DoWhileStat(); EToken not = null; }
{
	"do"
	{ st.pos = getToken(0).getPos(); }
    st.body = Statement()
    "while"
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")" ";"
	{ return st; }
}

ForStat ForStatement() :
{ ASTModifiers modifiers; ForStat st = new ForStat(); }
{
	"for"
	{ st.pos = getToken(0).getPos(); }
	"("
		(	LOOKAHEAD( InBlockModifiersLA())
			modifiers = Modifiers()
			VarDecls(modifiers, st.getSpacePtr("inits"))
		|
			LOOKAHEAD( Type() Name() )
			VarDecls(new ASTModifiers(), st.getSpacePtr("inits"))
		|
			st.inits += Expression()
			(
				","
				st.inits += Expression()
			)*
		)?
	";"
		[
			st.cond = Expression()
		]
	";"
		[
			st.iter = CommaExpression()
		]
	")"
	st.body = Statement()
	{ return st; }
}

ForEachStat ForEachStatement() :
{ ASTModifiers modifiers; ForEachStat st = new ForEachStat(); }
{
	"foreach"
	{ st.pos = getToken(0).getPos(); }
	"("
		[
			LOOKAHEAD( InBlockModifiersLA() | PizzaCaseFormalParameter() )
			modifiers = Modifiers()
			st.var = PizzaCaseFormalParameter(modifiers)
			";"
		]
		st.container = Expression()
		[
			";"
			st.cond = Expression()
		]
	")"
	st.body = Statement()
	{ return st; }
}

ENode GotoStatement() :
{ ENode st; ENode expr; SymbolRef id; }
{
	"goto"
	(
		"case"
		{
			st = new GotoCaseStat();
			st.pos = getToken(0).getPos();
		}
		expr = Expression()
		{ ((GotoCaseStat)st).expr = expr; }
	|
		"default"
		{
			st = new GotoCaseStat();
			st.pos = getToken(0).getPos();
		}
	|
		{
			st = new GotoStat();
			st.pos = getToken(0).getPos();
		}
    	id = NameRef()
		{ ((GotoStat)st).ident = id.name; }
    )
    ";"
	{ return st; }
}

BreakStat BreakStatement() :
{ SymbolRef id; BreakStat st = new BreakStat(); }
{
	"break"
	{ st.pos = getToken(0).getPos(); }
    [ id = NameRef() { st.ident = id.name; } ] ";"
	{ return st; }
}

ContinueStat ContinueStatement() :
{ SymbolRef id; ContinueStat st = new ContinueStat(); }
{
	"continue"
	{ st.pos = getToken(0).getPos(); }
    [ id = NameRef() { st.ident = id.name; } ] ";"
	{ return st; }
}

ReturnStat ReturnStatement() :
{ ReturnStat st = new ReturnStat(); }
{
	"return"
	{ st.pos = getToken(0).getPos(); }
    [ st.expr = ExpressionColonComma() ] ";"
	{ return st; }
}

ThrowStat ThrowStatement() :
{ ThrowStat st = new ThrowStat(); }
{
	"throw"
	{ st.pos = getToken(0).getPos(); }
    st.expr = ExpressionColonComma() ";"
	{ return st; }
}

SynchronizedStat SynchronizedStatement() :
{ SynchronizedStat st = new SynchronizedStat(); }
{
	"synchronized"
	{ st.pos = getToken(0).getPos(); }
	"(" st.expr = ExpressionColonComma() ")"
	st.body = Block()
	{ return st; }
}

WithStat WithStatement() :
{ WithStat st = new WithStat(); }
{
	"with"
	{ st.pos = getToken(0).getPos(); }
	"(" st.expr = ExpressionColonComma() ")"
	st.body = Block()
	{ return st; }
}

TryStat TryStatement() :
{ ASTModifiers modifiers; TryStat st = new TryStat(); }
{
	"try"
	{ st.pos = getToken(0).getPos(); }
    st.body = Block()
	(
		st.catchers += CatchInfo()
	)*
	[
		st.finally_catcher = FinallyInfo()
	]
	{ return st; }
}

CatchInfo CatchInfo() :
{ ASTModifiers modifiers; CatchInfo st = new CatchInfo(); }
{
	"catch"
	{ st.pos = getToken(0).getPos(); }
	"("
		modifiers = Modifiers()
		st.arg = PizzaCaseFormalParameter(modifiers)
	")"
	st.body = Block()
	{ return st; }
}

FinallyInfo FinallyInfo() :
{ Token t; FinallyInfo st = new FinallyInfo(); }
{
	"finally"
	{ st.pos = getToken(0).getPos(); }
	st.body = Block()
	{ return st; }
}



RewriteMatch RewriteMatch() :
{ TypeRef tp; Symbol id; RewriteMatch rm = new RewriteMatch(); }
{
	"{"
	(
		rm.cases += RewriteCase()
	)+
	"}"
	{ return rm; }
}

RewriteCase RewriteCase() :
{ RewriteCase c = new RewriteCase(); }
{
	"case"		{ c.pos = getToken(0).getPos(); }
	c.var = RewriteCasePattern()
	":"
	(
		BlockStatement(c.getSpacePtr("stats"))
	)+
	{ return c; }
}

RewritePattern RewriteCasePattern() :
{ ASTModifiers modifiers; TypeRef tp; Symbol id; RewritePattern p; }
{
	modifiers = Modifiers()
	tp = Type()
	id = Name()
	{ p = mkRewritePattern(id, modifiers, tp); }
	[
	"("
		[
			p.vars += RewriteCasePattern()
			(
				","
				p.vars += RewriteCasePattern()
			)*
		]
	")"
	]
	{ return p; }
}




RewriteNodeFactory RewriteFactoryCall() :
{ RewriteNodeFactory rn; SymbolRef id; }
{
	//"new"
	"#"
	id = QName()
	{ rn = new RewriteNodeFactory(id.name); }
	RewriteNodeArgs(rn)
	{ return rn; }
}

void RewriteNodeArgs(RewriteNodeFactory nf) :
{}
{
	"("
	[
		nf.args += RewriteNodeArg()
		( "," nf.args += RewriteNodeArg() )*
	]
	")"
}

RewriteNodeArg RewriteNodeArg() :
{ Token t; ENode rn; }
{
	t = <IDENTIFIER>
	"="
	(
		rn = RewriteNodeArgArrayInit()
	|
		rn = Expression()
	)
	{ return new RewriteNodeArg(t.image, rn); }
}

RewriteNodeArgArray RewriteNodeArgArrayInit() :
{ RewriteNodeArgArray rn = new RewriteNodeArgArray(); }
{
	"{" { rn.pos = getToken(0).getPos(); }
	[	LOOKAHEAD(2)
		rn.args += Expression()
		(	LOOKAHEAD(2)
			","
			rn.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ return rn; }
}

IfElseRewr IfRewr() :
{ IfElseRewr st = new IfElseRewr(); EToken not = null; }
{
	"if#"
	{ st.pos = getToken(0).getPos(); }
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")"
	st.thenSt = Statement()
	"else"
	st.elseSt = Statement()
	{ return st; }
}

