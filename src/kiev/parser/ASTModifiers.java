/* Generated By:JJTree: Do not edit this line. ASTModifiers.java */

package kiev.parser;

import kiev.Kiev;
import kiev.stdlib.*;
import kiev.vlang.*;

/**
 * @author Maxim Kizub
 *
 */

public class ASTModifiers extends ASTNode {
	public ASTModifier[]	modifier = ASTModifier.emptyArray;
	public ASTAccess 		acc;
	public ASTPack   		pack;
	public ASTAnnotation[]	annotations = ASTAnnotation.emptyArray;
	
	public ASTModifiers() {
		super(0);
	}

	public ASTModifiers(int id) {
		super(0);
	}

	public void jjtAddChild(ASTNode n, int i) {
		if (n instanceof ASTModifier) {
			modifier = (ASTModifier[])Arrays.append(modifier,n);
		}
		else if (n instanceof ASTAccess) {
			if (acc != null)
				Kiev.reportParserError(n.pos, "Multiple access specifiers");
			acc = (ASTAccess)n;
		}
		else if (n instanceof ASTPack) {
			if (pack != null)
				Kiev.reportParserError(n.pos, "Multiple field pack instructions");
			pack = (ASTPack)n;
		}
		else if (n instanceof ASTAnnotation) {
			annotations = (ASTAnnotation[])Arrays.append(annotations,n);
		}
		else {
			throw new CompilerException(n.getPos(),"Bad child number "+i+": "+n+" ("+n.getClass()+")");
		}
	}
	
	public int getFlags() {
		int flags = 0;
		foreach (ASTModifier m; modifier)
			flags |= m.flag();
		return flags;
	}

	public MetaSet getMetas(MetaSet ms) {
	next_annotation:
		foreach (ASTAnnotation a; annotations) {
			Meta m = a.getMeta();
			ms.set(m);
		}
		return ms;
	}

    public Dumper toJava(Dumper dmp) {
		for(int i=0; i < modifier.length; i++)
			modifier[i].toJava(dmp);
		return dmp;
    }
}

