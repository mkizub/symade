/* Generated By:JJTree: Do not edit this line. kiev020TreeConstants.java */

package kiev.parser;

public interface kiev020TreeConstants
{
  public int JJTFILEUNIT = 0;
  public int JJTMODIFIERS = 1;
  public int JJTPACKAGE = 2;
  public int JJTPRAGMA = 3;
  public int JJTIMPORT = 4;
  public int JJTTYPEDEF = 5;
  public int JJTOPDEF = 6;
  public int JJTSYNTAXDECLARATION = 7;
  public int JJTTYPEDECLARATION = 8;
  public int JJTVOID = 9;
  public int JJTENUMDECLARATION = 10;
  public int JJTENUMFIELDDECLARATION = 11;
  public int JJTCASETYPEDECLARATION = 12;
  public int JJTEXTENDS = 13;
  public int JJTIMPLEMENTS = 14;
  public int JJTGENERATE = 15;
  public int JJTARGUMENTDECLARATION = 16;
  public int JJTMODIFIER = 17;
  public int JJTPACK = 18;
  public int JJTACCESS = 19;
  public int JJTANNOTATION = 20;
  public int JJTANNOTATIONVALUE = 21;
  public int JJTANNOTATIONVALUEVALUEARRAYINITIALIZER = 22;
  public int JJTFIELDDECL = 23;
  public int JJTVARDECLS = 24;
  public int JJTVARDECL = 25;
  public int JJTNEWINITIALIZEDARRAYEXPRESSION = 26;
  public int JJTFORMALPARAMETER = 27;
  public int JJTTHROWS = 28;
  public int JJTIDENTIFIERALIAS = 29;
  public int JJTOPERATORALIAS = 30;
  public int JJTMETHODDECLARATION = 31;
  public int JJTREQUAREDECLARATION = 32;
  public int JJTENSUREDECLARATION = 33;
  public int JJTINVARIANTDECLARATION = 34;
  public int JJTRULEDECLARATION = 35;
  public int JJTINITIALIZER = 36;
  public int JJTTYPE = 37;
  public int JJTCLOSURETYPE = 38;
  public int JJTNONARRAYTYPE = 39;
  public int JJTPRIMITIVETYPE = 40;
  public int JJTIDENTIFIER = 41;
  public int JJTQNAME = 42;
  public int JJTCOMMAEXPRESSION = 43;
  public int JJTRULEOREXPRESSION = 44;
  public int JJTRULEANDEXPRESSION = 45;
  public int JJTRULEEXPRESSION = 46;
  public int JJTRULEISTHEEXPRESSION = 47;
  public int JJTRULEISONEOFEXPRESSION = 48;
  public int JJTRULECUTEXPRESSION = 49;
  public int JJTOPERATOR = 50;
  public int JJTCASTOPERATOR = 51;
  public int JJTEXPRESSION = 52;
  public int JJTREPARSEEXPRESSION = 53;
  public int JJTCALLEXPRESSION = 54;
  public int JJTTYPECLASSEXPRESSION = 55;
  public int JJTCALLACCESSEXPRESSION = 56;
  public int JJTACCESSEXPRESSION = 57;
  public int JJTARRAYELEMENTACCESSEXPRESSION = 58;
  public int JJTNEWACCESSEXPRESSION = 59;
  public int JJTANONYMOUSECLOSURE = 60;
  public int JJTCONSTEXPRESSION = 61;
  public int JJTNEWEXPRESSION = 62;
  public int JJTNEWARRAYEXPRESSION = 63;
  public int JJTREPARSESTATEMENT = 64;
  public int JJTLABELEDSTATEMENT = 65;
  public int JJTBLOCK = 66;
  public int JJTRULEBLOCK = 67;
  public int JJTCONDBLOCK = 68;
  public int JJTCONDSTATEMENT = 69;
  public int JJTEMPTYSTATEMENT = 70;
  public int JJTSTATEMENTEXPRESSION = 71;
  public int JJTSWITCHSTATEMENT = 72;
  public int JJTNORMALCASE = 73;
  public int JJTPIZZACASE = 74;
  public int JJTIFSTATEMENT = 75;
  public int JJTWHILESTATEMENT = 76;
  public int JJTDOSTATEMENT = 77;
  public int JJTFORSTATEMENT = 78;
  public int JJTFOREACHSTATEMENT = 79;
  public int JJTGOTOSTATEMENT = 80;
  public int JJTBREAKSTATEMENT = 81;
  public int JJTCONTINUESTATEMENT = 82;
  public int JJTRETURNSTATEMENT = 83;
  public int JJTTHROWSTATEMENT = 84;
  public int JJTSYNCHRONIZEDSTATEMENT = 85;
  public int JJTWITHSTATEMENT = 86;
  public int JJTTRYSTATEMENT = 87;
  public int JJTCATCHINFO = 88;
  public int JJTFINALLYINFO = 89;


  public String[] jjtNodeName = {
    "FileUnit",
    "Modifiers",
    "Package",
    "Pragma",
    "Import",
    "Typedef",
    "Opdef",
    "SyntaxDeclaration",
    "TypeDeclaration",
    "void",
    "EnumDeclaration",
    "EnumFieldDeclaration",
    "CaseTypeDeclaration",
    "Extends",
    "Implements",
    "Generate",
    "ArgumentDeclaration",
    "Modifier",
    "Pack",
    "Access",
    "Annotation",
    "AnnotationValue",
    "AnnotationValueValueArrayInitializer",
    "FieldDecl",
    "VarDecls",
    "VarDecl",
    "NewInitializedArrayExpression",
    "FormalParameter",
    "Throws",
    "IdentifierAlias",
    "OperatorAlias",
    "MethodDeclaration",
    "RequareDeclaration",
    "EnsureDeclaration",
    "InvariantDeclaration",
    "RuleDeclaration",
    "Initializer",
    "Type",
    "ClosureType",
    "NonArrayType",
    "PrimitiveType",
    "Identifier",
    "QName",
    "CommaExpression",
    "RuleOrExpression",
    "RuleAndExpression",
    "RuleExpression",
    "RuleIstheExpression",
    "RuleIsoneofExpression",
    "RuleCutExpression",
    "Operator",
    "CastOperator",
    "Expression",
    "ReparseExpression",
    "CallExpression",
    "TypeClassExpression",
    "CallAccessExpression",
    "AccessExpression",
    "ArrayElementAccessExpression",
    "NewAccessExpression",
    "AnonymouseClosure",
    "ConstExpression",
    "NewExpression",
    "NewArrayExpression",
    "ReparseStatement",
    "LabeledStatement",
    "Block",
    "RuleBlock",
    "CondBlock",
    "CondStatement",
    "EmptyStatement",
    "StatementExpression",
    "SwitchStatement",
    "NormalCase",
    "PizzaCase",
    "IfStatement",
    "WhileStatement",
    "DoStatement",
    "ForStatement",
    "ForEachStatement",
    "GotoStatement",
    "BreakStatement",
    "ContinueStatement",
    "ReturnStatement",
    "ThrowStatement",
    "SynchronizedStatement",
    "WithStatement",
    "TryStatement",
    "CatchInfo",
    "FinallyInfo",
  };
}
