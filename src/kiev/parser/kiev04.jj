/*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = true;
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev040)

package kiev.parser;

import kiev.Kiev;
import kiev.Kiev.Ext;
import kiev.vlang.*;

/*{

import syntax kiev.parser.TypeAliases;
import static kiev.vlang.AccessFlags.*;

typedef NArr<ASTArgumentDeclaration> NArrArgDecls;
typedef NArr<TypeWithArgsRef> NArrTypeWithArgsRefs;

}*/ 

public class kiev040 {

	public static boolean	interface_only = false;
	public static boolean	reparse_body = false;
	public static int		reparse_pos = 0;
	public static PreScanneable		presc = null;

	public static boolean	declMode = true;

    /** Report Parser Error (Exception) */
	public static void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	public static void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	private static boolean checkNoSpace(Token t1, Token t2) {
		return t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn;
	}

	public static final int[] noColonTokenSet = new int[]{COLON};

	public static int[] no_tokens;

	private static boolean notAToken(Token t) {
		if( no_tokens == null ) return true;
		for(int i=0; i < no_tokens.length; i++) {
			if( t.kind == no_tokens[i] ) return false;
		}
		return true;
	}

	private static boolean labledStatementLA() {
		for(int idx=1; ;idx+=2) {
			if (getToken(idx).kind != IDENTIFIER || getToken(idx+1).kind != COLON)
				return false;
			switch(getToken(idx+2).kind) {
			case LBRACE:
			case SEMICOLON:
			case SWITCH:
			case IF:
			case WHILE:
			case DO:
			case FOR:
			case FOREACH:
			case BREAK:
			case CONTINUE:
			case RETURN:
			case THROW:
			case SYNCHRONIZED:
			case WITH:
			case TRY:
			case GOTO:
			case REPARSE_STATEMENT:
				return true;
			}
		}
	}

	private static boolean operatorLA(int tk) {
		switch( getToken(tk).kind ) {
		case ASSIGN:
		case ASSIGN2:
		case LT:
		case GT:
		case COLON:
		case QUESTION:
		case ARROW:
		case BANG:
		case TILDE:
		case EQ:
		case LE:
		case GE:
		case NE:
		case SC_OR:
		case SC_AND:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
		case STAR:
		case SLASH:
		case BIT_AND:
		case BIT_OR:
		case XOR:
		case REM:
		case LSHIFT:
		case PLUSASSIGN:
		case MINUSASSIGN:
		case STARASSIGN:
		case SLASHASSIGN:
		case ANDASSIGN:
		case ORASSIGN:
		case XORASSIGN:
		case REMASSIGN:
		case LSHIFTASSIGN:
		case RSIGNEDSHIFTASSIGN:
		case RUNSIGNEDSHIFTASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR:
			return notAToken(getToken(tk));
		case OPERATOR_ID:
			return true;
		}
		return false;
	}

	private static boolean castLA_Start() {
		int i = 1;
		Token t = getToken(i);
		if (t.kind == IDENTIFIER) {
			String qname = t.image;
			while( getToken(i+1).kind == DOT && getToken(i+2).kind == IDENTIFIER) {
				i += 2;
				qname = qname + "." + getToken(i).image;
			}
			switch (getToken(i+1).kind) {
			case RPAREN:
			case LT:
			case OPERATOR_LRBRACKETS:
				break;
			default:
				return false;
			}
			try {
				if( PassInfo.checkClassName(KString.from(qname)) ) {
					return true;
				}
			} catch( Exception e ) {}
		}
		return false;
	}

	private static boolean castLA() {
		if( getToken(1).kind != LPAREN ) return false;
		if( getToken(2).kind == CAST ) return true;
		if( getToken(2).kind == REINTERP ) return true;
		return castLA(1,LPAREN,RPAREN);
	}

	private static boolean castLA(int offs, int exp_kind1, int exp_kind2) {
		if( getToken(offs).kind != exp_kind1 ) return false;
		switch( getToken(offs+1).kind ) {
		case BOOLEAN: case CHAR: case BYTE:
		case SHORT: case INT: case LONG: case FLOAT:
		case DOUBLE: case VOID:
			return true;
		case IDENTIFIER:
			break;
		case LPAREN:
			// Skip until matched ')' and check for "->"
			{
				int i = offs+2;
				int depth = 1;
				while( depth != 0 ) {
					switch(getToken(i++).kind) {
					case LPAREN: depth++; break;
					case RPAREN: depth--; break;
					}
				}
				if( getToken(i).kind==ARROW ) {
					return true;
				} else {
					return false;
				}
			}
		default:
			// TODO closure type
			return false;
		}
		// Qualified name resolving to be a class name
		String qname = getToken(offs+1).image;
	scan_qname:
		for(int i=offs+2; ; i+=2) {
			if( getToken(i).kind == DOT && getToken(i+1).kind == IDENTIFIER )
				qname = qname+"."+getToken(i+1).image;
			else {
				switch( getToken(i).kind ) {
				case RPAREN:
					if( exp_kind2 == RPAREN )  break scan_qname;
					else return false;
				case GT:
					if( exp_kind2 == GT ) break scan_qname;
					else return false;
				case LT:
					if( castLA(i,LT,GT) ) break scan_qname;
					else return false;
				case OPERATOR_LRBRACKETS:
					return true;
				case COMMA:
					if( exp_kind1 == LT ) break scan_qname;
					else return false;
				default:
					return false;
				}
			}
		}
		try {
			if( PassInfo.checkClassName(KString.from(qname)) ) {
				return true;
			}
		} catch( Exception e ) {}
		return false;
	}
	
	/*{
	private static Struct mkStruct(ASTIdentifier name, int flags, ASTModifiers modifiers, ASTNode parent) {
		ClazzName clname;
		if (parent instanceof FileUnit) {
			clname = ClazzName.fromOuterAndName(((FileUnit)parent).pkg.clazz,name.name,false,false);
		}
		else if (parent instanceof Struct) {
			clname = ClazzName.fromOuterAndName(PassInfo.clazz,name.name,false,true);
		}
		else if (name != null) {
			// Construct name of local class
			KString bytecode_name =
				KString.from(PassInfo.clazz.name.bytecode_name
					+"$"+PassInfo.clazz.countAnonymouseInnerStructs()
					+"$"+name.name);
			KString fixname = bytecode_name.replace('/','.');
			clname = new ClazzName(fixname,name.name,bytecode_name,false,false);
		}
		else {
			// Local anonymouse class
			KString bytecode_name =
				KString.from(PassInfo.clazz.name.bytecode_name
					+"$"+PassInfo.clazz.countAnonymouseInnerStructs());
			clname = ClazzName.fromBytecodeName(bytecode_name, false);
		}
		Struct clazz = Env.newStruct(clname,PassInfo.clazz,flags|modifiers.getFlags(),true);
		if (name != null)
			clazz.pos  = name.pos;
		else
			clazz.pos  = parent.pos;
		if (modifiers.acc != null)
			clazz.acc  = modifiers.acc;
		if      (parent instanceof FileUnit)
			clazz.setLocal(false);
		else if (parent instanceof Struct)
			clazz.setLocal(parent.isLocal());
		else
			clazz.setLocal(true);
		foreach (Meta m; modifiers.annotations)
			clazz.meta.set(m);
		return clazz;
	}

	private static BaseStruct mkStructArg(ASTIdentifier name, ASTModifiers modifiers, ASTNode parent) {
		BaseStruct arg;
		if (parent instanceof Struct) {
			Struct s = (Struct)parent;
			arg = Env.newArgument(name.name, s);
			s.args += arg;
		} else {
			ASTMethodDeclaration m = (ASTMethodDeclaration)parent;
			arg = Env.newMethodArgument(name.name, PassInfo.clazz);
			m.argtypes += arg;
		}
		arg.pos  = name.pos;
		foreach (Meta m; modifiers.annotations)
			arg.meta.set(m);
		return arg;
	}

	private static Field mkField(ASTIdentifier id, ASTModifiers modifiers, TypeRef type, boolean first) {
		if (!first)
			type = (TypeRef)type.copy();
		Field f = new Field(id.name,type,modifiers.getFlags());
		f.acc.flags = 0;
		f.pos = id.pos;
		if (first) {
			if (modifiers.acc != null)
				f.acc = modifiers.acc;
			foreach (Meta m; modifiers.annotations)
				f.meta.set(m);
		} else {
			if (modifiers.acc != null)
				f.acc = new Access(modifiers.acc.flags);
			foreach (Meta m; modifiers.annotations)
				f.meta.set((Meta)m.copy());
		}
		return f;
	}

	private static Field mkEnumField(ASTIdentifier id, ASTModifiers modifiers) {
		Field f = new Field(id.name,new TypeRef(),ACC_ENUM|ACC_STATIC|ACC_FINAL|ACC_PUBLIC);
		f.pos = id.pos;
		f.setEnumField(true);
		foreach (Meta m; modifiers.annotations)
			f.meta.set(m);
		return f;
	}
	}*/

}

PARSER_END(kiev040)


TOKEN_MGR_DECLS :
{
  static int skip_depth = 0;
}

<DEFAULT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT>
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<DEFAULT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
//| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
// | < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" > { if(Kiev.javaMode||Kiev.disabled(Ext.With)) matchedToken.kind=IDENTIFIER; }
// | < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < UNDERSCORE: "_" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ARROW: "->" >
| < FUNCTION: "fun" >
| < VIRTUAL: "virtual" > { if(Kiev.javaMode || Kiev.disabled(Ext.VirtualFields) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < VARARGS: "..." >
| < FORWARD: "forward" > { if(Kiev.javaMode || Kiev.disabled(Ext.Forward) /*|| !kiev040.declMode*/) matchedToken.kind=IDENTIFIER; }
| < RULE: "rule" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < PCUT: "$cut" > { if(Kiev.javaMode || Kiev.disabled(Ext.Logic) ) matchedToken.kind=IDENTIFIER; }
| < CAST: "$cast" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < REINTERP: "$reinterp" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ALIAS: "alias" > { if(Kiev.javaMode || Kiev.disabled(Ext.Alias)  || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < OPERATOR_ID: "operator" > { if(Kiev.javaMode || Kiev.disabled(Ext.Operator) ) matchedToken.kind=IDENTIFIER; }
| < TYPEDEF: "typedef" > { if(Kiev.javaMode || Kiev.disabled(Ext.Typedef)  || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < ENUM: "enum" > { if(Kiev.javaMode || Kiev.disabled(Ext.Enum) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }

| < REQUIRE: "require" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < ENSURE: "ensure" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < INVARIANT: "invariant" > { if(Kiev.javaMode || Kiev.disabled(Ext.Contract) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }

| < GENERATE: "$generate" > { if(Kiev.javaMode || Kiev.disabled(Ext.Templates) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }

| < PACKED: "packed" > { if(Kiev.javaMode || Kiev.disabled(Ext.PackedFields) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
| < WRAPPER: "$wrapper" > { if(Kiev.javaMode || Kiev.disabled(Ext.Wrappers) || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< ACCESS: "access:" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; } : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY: "ro" | "r" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
 | < WRITE_ONLY: "wo" | "w"> { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
 | < READ_WRITE: "rw" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
 | < NO_READ_WRITE: "n" | "no" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; }
 | < COMMA1: "," >
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(Kiev.javaMode || !kiev040.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < REPARSE_EXPRESSION:
      "#" ["E","e"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
|
  < REPARSE_STATEMENT:
      "#" ["S","s"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "ID#" <ID_STRING_LITERAL> ) >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON: ":" >
| < QUESTION: "?" >
}

<DEFAULT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
}

<DEFAULT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >
//| < GT: ">" >
//| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
//| < HOOK: "?" >
//| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//| < RSIGNEDSHIFT: ">>" >
//| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP:	"#" >
| < OPERATOR_LRBRACKETS: "[" ( " " )* "]" >
| < OPERATOR:	    ["\u2200"-"\u22F1"] >

}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTFileUnit FileUnit(String filename) :
{ ASTFileUnit old_fu; }
{
	{
		old_fu = Kiev.curFileUnit;
		ASTFileUnit fu = new FileUnit();
		Kiev.curFileUnit = fu;
		fu.filename = KString.from(filename);
		fu.setPos(0);
		declMode = true;
		ASTModifiers modifiers;
	}
	(	Pragma(fu) )*
	[	fu.pkg = Package()	]
	{ PassInfo.push(fu.pkg.clazz); }
	try {
		(	Pragma(fu) )*
		(
			fu.syntax += Import()
		|	fu.syntax += Typedef()
		|	fu.syntax += Opdef()
		)*
		(
			modifiers = Modifiers()
			(
				fu.members += TypeDeclaration(modifiers, fu) [ ";" ]
			|	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
				fu.members += SyntaxDeclaration(modifiers, fu) [ ";" ]
			)
		)*
		<EOF>
	}
	catch(ParseError e) { rpe("Bad modifiers",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		PassInfo.pop(fu.pkg.clazz);
		declMode = true;
		Kiev.curFileUnit = old_fu;
		return fu;
	}
}

ASTModifiers Modifiers() :
{}
{	{ ASTModifiers n = new ASTModifiers(); }
	(
		n.annotations += Annotation()
	)*
	(
		n.modifier    += Modifier()
	|	n.annotations += Pack()				// TODO: remove, use @packed
	|	n.acc          = Access()			// TODO: remove, use @access and views
	)*
	{ return n; }
}

StructRef Package() :
{ ASTIdentifier qn; }
{
	"package"
	qn = QName()
	";"
	{
		Struct pkg = Env.newPackage(qn.toKString());
		StructRef r = new StructRef(pkg);
		r.pos = qn.pos;
		return r;
	}
}

void Pragma(FileUnit fu) :
{ ASTPragma p = new ASTPragma(); }
{
	"pragma"
	(
		<PRAGMA_ENABLE>		{ p.enable = true; }
	|	<PRAGMA_DISABLE>	{ p.enable = false; }
	)
	( p.options += StringConstExpression() )+
	";"
	{ fu.setPragma(p); }
}

ASTImport Import() :
{ ASTImport imp = new ASTImport(); }
{
	"import"
	(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
		<IDENTIFIER>{ imp.mode = Import.ImportMode.IMPORT_SYNTAX; }
		imp.name = QName()
	|
		"package"	{ imp.mode = Import.ImportMode.IMPORT_PACKAGE; }
		imp.name = QName()
	|
		"static"	{ imp.mode = Import.ImportMode.IMPORT_STATIC; }
		imp.name = QName()
		[	"." "*" { imp.star = true; }
		|	"("		{ imp.of_method = true; }
			imp.args += Type()
			(
				","
				imp.args += Type()
			)*
			")"
		]
	|
		imp.name = QName()
		[	"." "*" { imp.star = true; }
		|	"("		{ imp.of_method = true; }
			imp.args += Type()
			(
				","
				imp.args += Type()
			)*
			")"
		]
	)
	";"
	{ return imp; }
}

ASTTypedef Typedef() :
{ ASTIdentifier id; ASTOperator op; TypeRef tp; ASTTypedef n = new ASTTypedef(); }
{
	"typedef"
	(
		LOOKAHEAD(3, <IDENTIFIER> TypeOperatorChar() <IDENTIFIER>, {checkNoSpace(getToken(1),getToken(2))})
		id = Name()
		op = Operator()
		tp = Type()
		{ n.set(id, op, tp); }
	|
		tp = Type()
		id = Name()
		{ n.set(tp, id); }
	) ";"
	{ return n; }
}

ASTOpdef Opdef() :
{ ASTIdentifier id; ASTOperator op; ConstIntExpr ce; ASTOpdef opd = new ASTOpdef(); }
{
	"operator"
	(
		op = Operator()            { opd.setImage(op); }
	|	id = Name()                { opd.setImage(id); }
	)
	","
	// FX,FY,XF,YF,XFX,YFX,XFY,YFY
	id = Name()                    { opd.setMode(id); }
	","
	ce = IntConstExpression()		{ opd.setPriority(ce); }
	";"
	{ return opd; }
}

Struct SyntaxDeclaration(ASTModifiers modifiers, ASTNode parent) :
{ Struct clazz; ASTIdentifier name; }
{
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>	// "syntax"
	name = Name()
	{
		clazz = mkStruct(name, ACC_SYNTAX|ACC_PRIVATE|ACC_ABSTRACT, modifiers, parent);
	}
	{ PassInfo.push(clazz); }
	"{"
	(
		clazz.members += Typedef()
	|	clazz.members += Opdef()
	)*
	"}"
	{ return clazz; }
}

Struct TypeDeclaration(ASTModifiers modifiers, ASTNode parent) :
{ Struct clazz; ASTIdentifier name; }
{
	(
		"class"
		name = Name()
		{
			clazz = mkStruct(name, 0, modifiers, parent);
		}
		ClazzArguments(clazz)
		[
			"extends"
			(
				LOOKAHEAD("rule")
				clazz.super_bound = PrimitiveType()
			|	clazz.super_bound = NArrType()
			)
		]
		[
			"implements"
			clazz.interfaces += NArrType()
			( "," clazz.interfaces += NArrType()	)*
		]
		[	Generate(clazz.name.name, clazz.gens)	]
	|	"interface"
		name = Name()
		{
			clazz = mkStruct(name, ACC_INTERFACE, modifiers, parent);
		}
		ClazzArguments(clazz)
		[
			"extends"
			clazz.interfaces += NArrType()
			( "," clazz.interfaces += NArrType()	)*
		]
		[	Generate(clazz.name.name, clazz.gens)	]
	|	"@" "interface"
		(	name = Name()
		|	name = KeywordAsName()
		)
		{
			clazz = mkStruct(name, ACC_INTERFACE|ACC_ANNOTATION, modifiers, parent);
		}
	|	"enum"
		name = Name()
		{
			clazz = mkStruct(name, ACC_ENUM|ACC_STATIC, modifiers, parent);
		}
	)
	{ PassInfo.push(clazz); }
	try {
		TypeBodyDeclaration(clazz)
	} finally { PassInfo.pop(clazz); }
	{ return clazz; }
}

void TypeBodyDeclaration(Struct clazz) :
{ ASTModifiers modifiers; }
{
	"{"
	(
		LOOKAHEAD({ clazz.isEnum() })
		modifiers = Modifiers()
		clazz.members += EnumFieldDeclaration(modifiers)
		(	","
			modifiers = Modifiers()
			clazz.members += EnumFieldDeclaration(modifiers)
		)*
		[ ";" ]
	)?
	(
		modifiers = Modifiers()
		(
			clazz.members += Initializer(modifiers)
		|	clazz.members += InvariantDeclaration(modifiers) [ ";" ]
		|	clazz.members += TypeDeclaration(modifiers, clazz) [ ";" ]
		|	clazz.members += CaseTypeDeclaration(modifiers, clazz) ";"
		|
			LOOKAHEAD( "rule" <IDENTIFIER> "(" )
			clazz.members += RuleDeclaration(modifiers)
		|
			LOOKAHEAD( <IDENTIFIER> "(" )
			clazz.members += ConstructorDeclaration(modifiers)
		|
			LOOKAHEAD( ClazzArguments() Type() <IDENTIFIER> "(" )
			clazz.members += MethodDeclaration(modifiers)
		|
			LOOKAHEAD( Type() <IDENTIFIER> (<OPERATOR_LRBRACKETS>)* ("=" | ":=" | "," | ";") )
			FieldDecls(modifiers, clazz)
		)
	)*
	"}"
}

Field EnumFieldDeclaration(ASTModifiers modifiers) :
{ ASTIdentifier id; Field f; ConstStringExpr text; }
{
	id = Name()
	{
		f = mkEnumField(id, modifiers);
	}
	[
		":"
		text = StringConstExpression()
		{
			text.value = KString.from("\""+text.value+"\"");
			f.meta.set(new MetaAlias(text));
		}
	]
	{ return f; }
}

Struct CaseTypeDeclaration(ASTModifiers modifiers, Struct parent) :
{ ASTIdentifier name; Struct clazz; }
{
	"case"
	name = Name()
	{
		clazz = mkStruct(name, ACC_PIZZACASE|ACC_STATIC, modifiers, parent);
		clazz.super_type = parent.type;
	}
	ClazzArguments(clazz)
	[
	"("
		[
			modifiers = Modifiers()
			clazz.members += FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				clazz.members += FormalParameter(modifiers)
			)*
		]
	")"
	]
	{ return clazz; }
}


void ClazzArguments(ASTNode parent) :
{}
{
	[
		"<"
			ArgumentDeclaration(parent)
			(	","
				ArgumentDeclaration(parent)
			)*
		">"
	]
}

void ArgumentDeclaration(ASTNode parent) :
{ ASTModifiers modifiers; ASTIdentifier name; BaseStruct arg; }
{
	modifiers = Modifiers()
	name      = Name()
	{ arg = mkStructArg(name, modifiers, parent); }
	[
		"extends"
		arg.super_bound = NArrType()
	]
}

// disabled
void Generate(KString name, NArrTypeWithArgsRefs types) :
{ Token t; ASTIdentifier id; TypeWithArgsRef tp; }
{
	"$generate"	// TODO: replace with @generate
	{ tp = new TypeWithArgsRef(new TypeNameRef(name)); }
	"<"
		( tp.args += PrimitiveType() | id = Name() { tp.args += new TypeNameRef(id); } )
		( "," (tp.args += PrimitiveType() | id = Name() { tp.args += new TypeNameRef(id); } ) )*
	">"
	{ /* types += tp; */ }
	(
		","
		{ tp = new TypeWithArgsRef(new TypeNameRef(name)); }
		"<"
			( tp.args += PrimitiveType() | id = Name() { tp.args += new TypeNameRef(id); } )
			( "," (tp.args += PrimitiveType() | id = Name() { tp.args += new TypeNameRef(id); } ) )*
		">"
		{ /* types += tp; */ }
	)*
}

ASTModifier Modifier() :
{ Token t=null; }
{
	(
	  t="public"
	| t="protected"
	| t="private"
	| t="static"
	| t="abstract"
	| t="final"
	| t="native"
	| t="synchronized"
	| t="transient"
	| t="volatile"
	| t="virtual"		// TODO: replace with @virtual
	| t="forward"		// TODO: replace with @forward

	| t="$wrapper"		// TODO: replace with @wrapper

	)
	{ ASTModifier n = new ASTModifier(); n.set(t); return n; }
}

Meta Pack() :
{ Token t; int size=-1; int offset=-1; String packer=null; }
{
	"packed"
	[
		":"
		t=<INTEGER_LITERAL> { size = Integer.parseInt(t.image); t = null; }
		[
		","
		t=<IDENTIFIER> { packer = t.image; t = null; }
		","
		t=<INTEGER_LITERAL> { offset = Integer.parseInt(t.image); t = null; }
		]
	]
	{
		MetaPacked mp = new MetaPacked();
		mp.size       = size;
		mp.offset     = offset;
		mp.fld        = KString.from(packer);
		return mp;
	}
}

Access Access() :
{ int acc; 	int accflags = 0; int offset = 6; }
{
	LOOKAHEAD({Kiev.enabled(Ext.Access)})
	"access:"
	acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
	]]]
	{ return new Access(accflags); }
}

int AccessSpec() :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

ASTIdentifier KeywordAsName() :
{ Token t; ASTIdentifier id; }
{
	(
		t="virtual"
	|	t="alias"
	|	t="packed"
	)
	{
		id = new ASTIdentifier();
		id.set(t);
		return id;
	}
}

ASTMeta Annotation() :
{ ASTIdentifier id; MetaValue v; }
{
	{ ASTMeta n = new ASTMeta(); }
	"@"
	(
		id = Name()
	|	id = KeywordAsName()
	)
	{	n.pos = id.pos;	n.type = new TypeNameRef(id); }
	[
		"("
		[	LOOKAHEAD( <IDENTIFIER> "=" )
			AnnotationValues(n)
		|	v = AnnotationValueAny() { n.set(v); }
		]
		")"
	]
	{ return n; }
}

void AnnotationValues(ASTMeta m) :
{ ASTIdentifier id; MetaValue v; }
{
	id = Name()
	"="
	v = AnnotationValueAny()
	{ v.type = new MetaValueType(id.name); m.set(v); }
	(
		","
		id = Name()
		"="
		v = AnnotationValueAny()
		{ v.type = new MetaValueType(id.name); m.set(v); }
	)*
}

MetaValue AnnotationValueAny() :
{ ASTNode n; MetaValue v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	|	v = AnnotationValueValueArrayInitializer()
	|	n = ExpressionNT(null)
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueScalar AnnotationValueScalar() :
{ ASTNode n; MetaValueScalar v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	|	n = ExpressionNT(null)
		{ v = new MetaValueScalar(); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueArray AnnotationValueValueArrayInitializer() :
{ MetaValueScalar n; MetaValueArray v; }
{
	{ v = new MetaValueArray(); }
	"{"
	[
		n = AnnotationValueScalar() { v.values.add(n.value); }
		(	","
			n = AnnotationValueScalar() { v.values.add(n.value); }
		)*
	]
	"}"
	{ return v; }
}


void FieldDecls(ASTModifiers modifiers, Struct clazz) :
{ boolean old_declMode; TypeRef type; }
{
	{ old_declMode = declMode; declMode = false; }
	try {
		type = Type()
		clazz.members += FieldDecl(modifiers, type, true)
		(	","
			clazz.members += FieldDecl(modifiers, type, false)
		)*
	} finally { declMode = old_declMode; }
	";"
}

Field FieldDecl(ASTModifiers modifiers, TypeRef type, boolean first) :
{ Token t; ASTIdentifier id; Field f; }
{
	id = Name()
	{ f = mkField(id, modifiers, type, first); }
	( t=<OPERATOR_LRBRACKETS> { f.ftype = new TypeExpr(f.ftype,t); } )*
	[
		(
			"="
		|	":=" { f.setInitWrapper(true); }
		)
		f.init = VariableInitializer()
	]
	{ return f; }
}

ASTVarDecls VarDecls(ASTModifiers modifiers) :
{ ASTVarDecls n = new ASTVarDecls(); }
{
	{ n.modifiers = modifiers; }
	n.type = Type()
	n.vars += VarDecl()
	(	","	n.vars += VarDecl() )*
	";"
	{ return n; }
}

ASTVarDecl VarDecl() :
{ ASTVarDecl v = new ASTVarDecl(); }
{
	v.name = Name()
	( <OPERATOR_LRBRACKETS> { v.dim += 1; } )*
	[
		("=" | ":=" { v.of_wrapper=true; })
		v.init = VariableInitializer()
	]
	{ return v; }
}

Expr VariableInitializer() :
{ Expr e; }
{
	(
		e = ArrayInitializer()
	|
		e = Expression()
	)
	{ return e; }
}

Expr ArrayInitializer() :
{ Token t; ASTNewInitializedArrayExpression e = new ASTNewInitializedArrayExpression(); }
{
	t="{"
	[	LOOKAHEAD(2)
		e.args += VariableInitializer()
		(	LOOKAHEAD(2)
			","
			e.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ return e; }
}

ASTFormalParameter FormalParameter(ASTModifiers modifiers) :
{ Token t; }
{
	{
		ASTFormalParameter n = new ASTFormalParameter();
		n.modifiers = modifiers;
	}
	(
		n.type  = Type()
		n.ident = Name()
		( t=<OPERATOR_LRBRACKETS> { n.type = new TypeExpr(n.type,t); } )*
	|
		t="_" { n.set(t); }
	)
	{ return n; }
}

ASTFormalParameter mmFormalParameter(ASTModifiers modifiers) :
{ Token t; }
{
	{
		ASTFormalParameter n = new ASTFormalParameter();
		n.modifiers = modifiers;
	}
	(
		n.type = Type()
		(
			LOOKAHEAD({ !Kiev.javaMode && (getToken(1).image.equals(":")) })
			(":") n.mm_type = Type()
		)?
		n.ident = Name()
		( t=<OPERATOR_LRBRACKETS> { n.type = new TypeExpr(n.type,t); if (n.mm_type != null) n.mm_type = new TypeExpr(n.mm_type,t); } )*
	|
		t="_" { n.set(t); }
	)
	{ return n; }
}

ASTThrows Throws() :
{ Token t; ASTThrows n = new ASTThrows(); }
{
	t="throws" { n.setPos(t.getPos()); }
	n.names += QName()
	(	"," n.names += QName()	)*
	{ return n; }
}


ASTAlias Alias() :
{ Token t; ASTAlias a; }
{
	"alias"
	(
		LOOKAHEAD(2)
		a = OperatorAlias()
	|	a = IdentifierAlias()
	)
	{ return a; }
}

ASTIdentifierAlias IdentifierAlias() :
{ ASTIdentifierAlias a = new ASTIdentifierAlias(); }
{
	a.name = Name()
	{ return a; }
}

ASTOperatorAlias OperatorAlias() :
{ Token t = null; ASTIdentifier id; ASTOperator op; ConstIntExpr ce; ASTOperatorAlias a = new ASTOperatorAlias(); }
{
	(	// temporary, for backward compatibility
		"operator"
		"("
		ce = IntConstExpression()		{ a.setPriority(ce); }
		","
		id = Name()						{ a.setMode(id); }
		","
		(
			op = Operator()				{ a.setImage(op); }
		|	id = Name()					{ a.setImage(id); }
		|	<OPERATOR_LRBRACKETS>		{ a.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"						{ a.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"						{ a.image = kiev.vlang.Constants.nameCastOp; }
		)
		")"
	|
		id = Name()						{ a.setMode(id); }
		"operator"
		(
			op = Operator()				{ a.setImage(op); }
		|	id = Name()					{ a.setImage(id); }
		|	<OPERATOR_LRBRACKETS>		{ a.image = kiev.vlang.Constants.nameArrayOp; }
		|	"new"						{ a.image = kiev.vlang.Constants.nameNewOp; }
		|	"$cast"						{ a.image = kiev.vlang.Constants.nameCastOp; }
		)
	)
	{ return a; }
}

ASTBlock MaybeSkipBlock() :
{ boolean old_declMode; ASTBlock bl = null; }
{
	(
		LOOKAHEAD({ interface_only })
		"{"
		{
			Token tk = getToken(0);
			PrescannedBody pbody = new PrescannedBody(tk.beginLine,tk.beginColumn);
			Kiev.curFileUnit.addPrescannedBody(pbody);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
			presc.pbody = pbody;
			if( presc instanceof ASTRuleDeclaration )
				pbody.mode = PrescannedBody.RuleBlockMode;
			else
				pbody.mode = PrescannedBody.BlockMode;
		}
	|
		LOOKAHEAD({ presc instanceof ASTRuleDeclaration })
		bl = RuleBlock()
	|
		bl = Block()
	)
	{ return bl; }
}

ASTMethodDeclaration MethodDeclaration(ASTModifiers modifiers) :
{ Token t; }
{
	{
		ASTMethodDeclaration n = new ASTMethodDeclaration();
		n.modifiers = modifiers;
	}
	ClazzArguments(n)
	n.rettype = Type()
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		[
			modifiers = Modifiers()
			n.params += mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				n.params += mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ n.setVarArgs(true); }
			]
		]
	")"
	(	t=<OPERATOR_LRBRACKETS> { n.rettype = new TypeExpr(n.rettype,t); } )*
	(
		n.aliases += Alias()
	)*
	[	n.throwns = Throws()	]
	(
		n.conditions += RequareDeclaration()
	|	n.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD("{")
		{ presc = n; }
		n.body = MaybeSkipBlock() [ ";" ]
	|	[ "default" n.annotation_default = AnnotationValueAny() ] ";"
	)
	{ return n; }
}

ASTMethodDeclaration ConstructorDeclaration(ASTModifiers modifiers) :
{ Token t; }
{
	{
		ASTMethodDeclaration n = new ASTMethodDeclaration();
		n.modifiers = modifiers;
	}
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		[
			modifiers = Modifiers()
			n.params += mmFormalParameter(modifiers)
			(
				LOOKAHEAD(2) ","
				modifiers = Modifiers()
				n.params += mmFormalParameter(modifiers)
			)*
			[	LOOKAHEAD(2, [","] "...", {Kiev.enabled(Ext.VarArgs)})
				[","]
				"..."
				{ n.setVarArgs(true); }
			]
		]
	")"
	(
		n.aliases += Alias()
	)*
	[	n.throwns = Throws()	]
	(
		n.conditions += RequareDeclaration()
	|	n.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD("{")
		{ presc = n; }
		n.body = MaybeSkipBlock() [ ";" ]
	|	";"
	)
	{ return n; }
}

ASTRequareDeclaration RequareDeclaration() :
{}
{
	{
		ASTRequareDeclaration n = new ASTRequareDeclaration();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondRequire;
	}
	"require"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" n.name = Name() "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		n.name = Name()
		n.body = CondBlock()
	|
		n.body = CondBlock()
	)
	{ return n; }
}


ASTEnsureDeclaration EnsureDeclaration() :
{}
{
	{
		ASTEnsureDeclaration n = new ASTEnsureDeclaration();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondEnsure;
	}
	"ensure"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" n.name = Name() "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		n.name = Name()
		n.body = CondBlock()
	|
		n.body = CondBlock()
	)
	{ return n; }
}

ASTInvariantDeclaration InvariantDeclaration(ASTModifiers modifiers) :
{}
{
	{
		ASTInvariantDeclaration n = new ASTInvariantDeclaration();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondInvariant;
	}
	"invariant"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" n.name = Name() "]"
		n.body = CondBlock()
	|	LOOKAHEAD(<IDENTIFIER> "{")
		n.name = Name()
		n.body = CondBlock()
	)
	{ return n; }
	
}

ASTRuleDeclaration RuleDeclaration(ASTModifiers modifiers) :
{ ASTBlock bl; }
{
	{
		ASTRuleDeclaration n = new ASTRuleDeclaration();
		n.modifiers = modifiers;
	}
	"rule"
	n.ident = Name() { n.pos = n.ident.pos; }
	"("
		[
			modifiers = Modifiers()
			n.params += FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				n.params += FormalParameter(modifiers)
			)*
		]
	")"
	(
		n.aliases += Alias()
	)*
	(
		modifiers = Modifiers()
		n.localvars += VarDecls(modifiers)
	)*
	(
		n.conditions += RequareDeclaration()
	|	n.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD("{")
		{ presc = n; }
		n.body = MaybeSkipBlock() [ ";" ]
	|	";"
	)
	{ return n; }
}

ASTInitializer Initializer(ASTModifiers modifiers) :
{ ASTInitializer n = new ASTInitializer(); ASTBlock bl; }
{
	{
		n.setFlags(modifiers.getFlags());
		/*{
		foreach (Meta m; modifiers.annotations)
			n.meta.set(m);
		}*/
	}
	{ presc = n; }
	bl = MaybeSkipBlock()
	{	if (bl != null) n.stats += bl;	}
	[ ";" ]
	
	{ return n; }
}



/*
 * Type, name and expression syntax follows.
 */


TypeRef Type() :
{ TypeRef res; }
{
	(
		res = TypeExpr()
	|
		LOOKAHEAD({Kiev.enabled(Ext.With)})
		res = ClosureType()
	)
	{ return res; }
}

TypeRef TypeExpr() :
{ TypeRef res; Token t; }
{
	(
		res = PrimitiveType()
	|	res = TypeWithArgs()
	)
	(
		(	t = TypeOperatorChar()
		|	t = <OPERATOR_LRBRACKETS>
		)
		{ res = new TypeExpr(res,t); }
	)*
	{ return res; }
}

TypeRef TypeWithArgs() :
{ ASTIdentifier id; TypeRef res; TypeRef arg; TypeWithArgsRef tra; }
{
	id = QName() { res = new TypeNameRef(id); }
	[	LOOKAHEAD(1, "<", {Kiev.enabled(Ext.Generics)})
		"<"
			{ res = tra = new TypeWithArgsRef(res); }
			tra.args += Type()
			( "," tra.args += Type() )*
		">"
	]
	{ return res; }
}

TypeRef NArrType() :
{ TypeRef res; Token t; }
{
	(
		res = PrimitiveType()
	|	res = TypeWithArgs()
	)
	(	LOOKAHEAD(2)
		(
			t = TypeOperatorChar()			{ res = new TypeExpr(res,t); }
		|
			t = <OPERATOR_LRBRACKETS>		{ res = new TypeExpr(res,t); }
			t = TypeOperatorChar()			{ res = new TypeExpr(res,t); }
		)
		{ res = new TypeExpr(res,t); }
	)*
	{ return res; }
}

/*
TypeRef Type() :
{ TypeRef res; Token t; }
{
	(
		res = SimpleType()
		(
			t=TypeOperatorChar()
			{ res = new TypeExpr(res,t); }
		)*
	|
		LOOKAHEAD({Kiev.enabled(Ext.With)})
		res = ClosureType()
	)
	{ return res; }
}

TypeRef SimpleType() :
{ TypeRef tp; }
{
	(
		tp = PrimitiveType()
	|	tp = NonArrayType()
	)
	{ return tp; }
}

TypeRef NonArrayType() :
{ Token t; ASTIdentifier id; TypeRef res; TypeRef arg; TypeWithArgsRef tra; }
{
	id = QName() { res = new TypeNameRef(id); }
	[	LOOKAHEAD(1, "<", {Kiev.enabled(Ext.Generics)})
		"<"
			{ res = tra = new TypeWithArgsRef(res); }
			tra.args += Type()
			( "," tra.args += Type() )*
		">"
	]
	(
		t=TypeOperatorChar()
		{ res = new TypeExpr(res, t); }
	)*
	{ return res; }
}
*/

TypeRef ClosureType() :
{ Token t; ASTClosureType n = new ASTClosureType(); }
{
	t="(" { n.setPos(t.getPos()); }
	[
		n.types += Type()
		( "," n.types += Type() )*
	]
	")" "->" n.types += Type()
	{ return n; }
}

TypeRef PrimitiveType() :
{ Token t; TypeRef tp = new TypeRef(); }
{
	(
	  t="boolean"	{ tp.lnk = Type.tpBoolean; }
	| t="char"		{ tp.lnk = Type.tpChar; }
	| t="byte"		{ tp.lnk = Type.tpByte; }
	| t="short"		{ tp.lnk = Type.tpShort; }
	| t="int"		{ tp.lnk = Type.tpInt; }
	| t="long"		{ tp.lnk = Type.tpLong; }
	| t="float"		{ tp.lnk = Type.tpFloat; }
	| t="double"	{ tp.lnk = Type.tpDouble; }
	| t="void"		{ tp.lnk = Type.tpVoid; }
	| t="rule"		{ tp.lnk = Type.tpRule; }
	)
	{ tp.pos = t.getPos(); return tp; }
}

ASTIdentifier Name() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		ASTIdentifier id = new ASTIdentifier();
		id.set(t);
		return id;
	}
}

ASTIdentifier QName() :
{ ASTIdentifier id; ASTIdentifier id2; }
{
	id = Name()
	(
		LOOKAHEAD(2)
		"."
		id2 = Name()
		{
			id.name = new KStringBuffer(id.name.len+1+id2.name.len)
				.append_fast(id.name)
				.append_fast((byte)'.')
				.append_fast(id2.name)
				.toKString();
		}
	)*
	{ return id; }
}

/*
 * Expression syntax follows.
 */

Expr CommaExpression() :
{ Expr e; ASTCommaExpression ce = null; }
{
	e = Expression()
	(
		","
		{ if (ce==null) ce = new ASTCommaExpression(e); }
		ce.exprs += Expression()
	)*
	{ return ce == null ? e : ce; }
}

ASTRuleNode RuleOrExpression() :
{ ASTRuleNode e; ASTRuleOrExpression r = null; }
{
	e = RuleAndExpression()
	(
		";"
		{ if (r==null) r = new ASTRuleOrExpression(e); }
		r.exprs += RuleAndExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleAndExpression() :
{ ASTRuleNode e; ASTRuleAndExpression r = null; }
{
	e = RuleExpression()
	(
		","
		{ if (r==null) r = new ASTRuleAndExpression(e); }
		r.exprs += RuleExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleExpression() :
{ ASTRuleNode r; }
{
	(
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_THE
		})
		r = RuleIstheExpression()
	|
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_ONE_OF
		})
		r = RuleIsoneofExpression()
	|
		LOOKAHEAD({getToken(1).kind == PCUT})
		r = RuleCutExpression()
	|
		LOOKAHEAD({getToken(1).kind == LBRACE})
		"{" r = RuleOrExpression() "}"
	|
		LOOKAHEAD({getToken(1).kind == WHILE})
		"while"
		{ r = new ASTRuleExpression(); r.while_mode = true; }
		r.expr = Expression() 
		[
			":"
			r.bt_expr = ExpressionNT(noColonTokenSet)
		]
	|
		LOOKAHEAD(0)
		{ r = new ASTRuleExpression(); }
		r.expr = ExpressionNT(noColonTokenSet)
		[
			":"
			r.bt_expr = ExpressionNT(noColonTokenSet)
		]
	)
	{ return r; }
}

ASTRuleIstheExpression RuleIstheExpression() :
{ ASTRuleIstheExpression r = new ASTRuleIstheExpression(); }
{
	r.name = Name()
	"?="
	r.expr = AccessExpression()
	{ return r; }
}

ASTRuleIsoneofExpression RuleIsoneofExpression() :
{ ASTRuleIsoneofExpression r = new ASTRuleIsoneofExpression(); }
{
	r.names += Name() "@=" r.exprs += AccessExpression()
	(
		LOOKAHEAD({
			getToken(1).image.equals("&")
		 && getToken(2).kind == IDENTIFIER
		 && getToken(3).kind == IS_ONE_OF
		})
		"&" r.names += Name() "@=" r.exprs += AccessExpression()
	)*
	{ return r; }
}

ASTRuleCutExpression RuleCutExpression() :
{ Token t; ASTRuleCutExpression r = new ASTRuleCutExpression(); }
{
	t="$cut"
	{
		r.setPos(t.getPos());
		return r;
	}
}

Token TypeOperatorChar() :
{ Token t; }
{
	(
		t=<QUESTION>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar() :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<ASSIGN2>
	|	t=<LT>
	|	t=<GT>
	|	t=<COLON>
	|	t=<QUESTION>
	|	t=<ARROW>
	|	t=<BANG>
	|	t=<TILDE>
	|	t=<EQ>
	|	t=<LE>
	|	t=<GE>
	|	t=<NE>
	|	t=<SC_OR>
	|	t=<SC_AND>
	|	t=<INCR>
	|	t=<DECR>
	|	t=<PLUS>
	|	t=<MINUS>
	|	t=<STAR>
	|	t=<SLASH>
	|	t=<BIT_AND>
	|	t=<BIT_OR>
	|	t=<XOR>
	|	t=<REM>
	|	t=<LSHIFT>
	|	t=<PLUSASSIGN>
	|	t=<MINUSASSIGN>
	|	t=<STARASSIGN>
	|	t=<SLASHASSIGN>
	|	t=<ANDASSIGN>
	|	t=<ORASSIGN>
	|	t=<XORASSIGN>
	|	t=<REMASSIGN>
	|	t=<LSHIFTASSIGN>
	|	t=<RSIGNEDSHIFTASSIGN>
	|	t=<RUNSIGNEDSHIFTASSIGN>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR>
	)
	{ return t; }
}

ASTOperator Operator() :
{ Token t; String image; ASTOperator op = new ASTOperator(); }
{
	(
		t=OperatorChar()
		{ image = t.image; }
		(
			LOOKAHEAD({ !Kiev.javaMode && operatorLA(1) && checkNoSpace(getToken(0),getToken(1)) })
			t=OperatorChar()
			{ image = image+t.image; }
		|
			LOOKAHEAD({ Kiev.javaMode && getToken(1).kind==GT && checkNoSpace(getToken(0),getToken(1)) })
			t=<GT>
			{ image = image+t.image; }
		)*
	|	LOOKAHEAD({ !Kiev.javaMode })
		"operator" t=<IDENTIFIER>
		{ image = t.image; }
	)
	{
		op.setPos(t.getPos());
		op.image = KString.from(image);
		return op;
	}
}

void CastOperatorLA() :
{}
{
	"("
	(
		<CAST>
	|	<REINTERP>
	|	PrimitiveType()
	|	LOOKAHEAD(0,{ castLA_Start() }) Type() ")"
		(
			<IDENTIFIER>
		|	"("
		|	ConstExpression()
		|	"new"
		|	Operator()
		|	ReparseExpression()
		|	"fun"
		)
	)
}

ASTNode CastOperator() :
{ Token t; ASTCastOperator op = new ASTCastOperator(); }
{
	t="("
	{ op.setPos(t.getPos()); }
	[ <CAST> | <REINTERP> {op.reinterp=true;} ]
	op.type = Type()
	")"
	{ return op; }
}

Expr ExpressionNT(int[] nt_new) :
{ int[] nt_old = no_tokens; no_tokens = nt_new; Expr e; }
{
	try {
		e = Expression()
	} finally { no_tokens = nt_old; }
	{ return e; }
}

Expr Expression() :
{ ASTExpression e = new ASTExpression(); }
{
	(
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("instanceof") })
		e.nodes += Name()
		e.nodes += Type()
	|	LOOKAHEAD({ operatorLA(1) })
		e.nodes += Operator()
	|	LOOKAHEAD( CastOperatorLA() )
		e.nodes += CastOperator()
	|	LOOKAHEAD(2)
		e.nodes += AccessExpression()
	)+
	{ return e; }
}

Expr ReparseExpression() :
{ Token t; ASTReparseExpression e = new ASTReparseExpression(); }
{
	t=<REPARSE_EXPRESSION>
	{
		e.set(t);
		return e;
	}
}

Expr CallExpression() :
{ ASTCallExpression e = new ASTCallExpression(); }
{
	e.func = Name()
	"("
	[	e.args += ExpressionNT(null)
		(	","  e.args += ExpressionNT(null)	)*
	]
	")"
	{ return e; }
}

Expr CallAccessExpression(Expr obj) :
{ ASTCallAccessExpression e = new ASTCallAccessExpression(); e.obj = obj; }
{
	e.func = Name()
	"("
	[	e.args += ExpressionNT(null)
		(	","  e.args += ExpressionNT(null)	)*
	]
	")"
	{ return e; }
}

Expr TypeClassExpression() :
{ ASTTypeClassExpression e = new ASTTypeClassExpression(); }
{
	e.type = Type() "." "class"
	{ return e; }
}

Expr AccessExpression() :
{ Token t; Expr e = null; }
{
	(
		LOOKAHEAD( Type() "." "class" )
		e = TypeClassExpression()
	|
		LOOKAHEAD(2)
		e = ConstExpression()
	|
		LOOKAHEAD(2)
		e = CallExpression()
	|
		LOOKAHEAD(2)
		e = Name()
	|
		LOOKAHEAD("new" NArrType() (<OPERATOR_LRBRACKETS>)+ "{" )
		e = NewInitializedArrayExpression()
	|
		LOOKAHEAD("new" NArrType() "[" )
		e = NewArrayExpression()
	|
		LOOKAHEAD("new" NArrType() ( "(" ) )
		e = NewExpression()
	|
		e = ReparseExpression()
	|
		"("
		e = ExpressionNT(null)
		")"
	|   LOOKAHEAD("fun" "(")
		e = AnonymouseClosure()
	)
	(
		LOOKAHEAD(3)
		"."
		e = CallAccessExpression(e)
	|
		LOOKAHEAD(3)
		t="."
		{ ASTAccessExpression ae = new ASTAccessExpression(); ae.obj = e; ae.setPos(t.getPos()); }
		ae.ident = Name()
        { e = ae; }
	|	LOOKAHEAD(2)
		t="["
		{ ASTArrayElementAccessExpression ae = new ASTArrayElementAccessExpression(); ae.obj = e; ae.setPos(t.getPos()); }
		ae.index = ExpressionNT(null)
		"]"
        { e = ae; }
	|
		LOOKAHEAD("." "new" NArrType() ( "(" ) )
		t="."
		{ ASTNewAccessExpression ae = new ASTNewAccessExpression(); ae.obj = e; ae.setPos(t.getPos()); }
		e = NewExpression()
        {
			ae.type = ((ASTNewExpression)e).type;
			/*{ foreach (Expr a; ((ASTNewExpression)e).args) ae.args += a; }*/
			if (((ASTNewExpression)e).clazz != null)
				throw new ParseException();
			e = ae;
		}
	)*
	{ return e; }
}

ASTAnonymouseClosure AnonymouseClosure() :
{ Token t; ASTModifiers modifiers; ASTAnonymouseClosure ac = new ASTAnonymouseClosure(); }
{
	t="fun" "("
	[
		modifiers = Modifiers()
		ac.params += FormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			ac.params += FormalParameter(modifiers)
		)*
	]
	")" "->"
    { ac.setPos(t.getPos()); }
    (
		LOOKAHEAD( { getToken(1).kind == RULE } )
		ac.rettype = Type()
		ac.body = RuleBlock()
	|
		ac.rettype = Type()
		ac.body = Block()
	)
	{ return ac; }
}

ConstExpr ConstExpression() :
{ ConstExpr ce; }
{
	(
		ce = BooleanConstExpression()
	|	ce = IntConstExpression()
	|	ce = LongConstExpression()
	|	ce = FloatConstExpression()
	|	ce = DoubleConstExpression()
	|	ce = CharConstExpression()
	|	ce = NullConstExpression()
	|	ce = StringConstExpression()
	)
	{ return ce; }
}

ConstBoolExpr BooleanConstExpression() :
{ Token t; }
{
	(
		t="true"
	|	t="false"
	)
	{ return (ConstBoolExpr)ConstExpr.fromSource(t); }
}

ConstIntExpr IntConstExpression() :
{ Token t; }
{
 	t=<INTEGER_LITERAL>
	{ return (ConstIntExpr)ConstExpr.fromSource(t); }
}

ConstLongExpr LongConstExpression() :
{ Token t; }
{
	t=<LONG_INTEGER_LITERAL>
	{ return (ConstLongExpr)ConstExpr.fromSource(t); }
}

ConstFloatExpr FloatConstExpression() :
{ Token t; }
{
	t=<FLOATING_POINT_LITERAL>
	{ return (ConstFloatExpr)ConstExpr.fromSource(t); }
}

ConstDoubleExpr DoubleConstExpression() :
{ Token t; }
{
	t=<DOUBLE_POINT_LITERAL>
	{ return (ConstDoubleExpr)ConstExpr.fromSource(t); }
}

ConstCharExpr CharConstExpression() :
{ Token t; }
{
	t=<CHARACTER_LITERAL>
	{ return (ConstCharExpr)ConstExpr.fromSource(t); }
}

ConstNullExpr NullConstExpression() :
{ Token t; }
{
	t="null"
	{ return (ConstNullExpr)ConstExpr.fromSource(t); }
}

ConstStringExpr StringConstExpression() :
{ Token t, t1; }
{
	t=<STRING_LITERAL>
	(
		LOOKAHEAD({
			getToken(1).kind==PLUS
		 && getToken(2).kind==STRING_LITERAL
		})
		"+" t1=<STRING_LITERAL>
		{
			t.image = t.image.substring(0,t.image.length()-1)+t1.image.substring(1);
			t.endLine = t1.endLine;
			t.endColumn = t1.endColumn;
		}
	)*
	{ return (ConstStringExpr)ConstExpr.fromSource(t); }
}

ASTNewExpression NewExpression() :
{
	Token t;
	boolean old_mode;
	Struct clazz;
	ASTNewExpression ne = new ASTNewExpression();
}
{
	t="new" { ne.setPos(t.getPos()); }
    ne.type = NArrType() "("
	[	ne.args += ExpressionNT(null)
		(	"," ne.args += ExpressionNT(null)	)*
	]
	")"
	[
		LOOKAHEAD("{")
		{
			old_mode = interface_only;
			interface_only = false;
			ne.clazz = clazz = mkStruct(null, 0, new ASTModifiers(), ne);
			PassInfo.push(clazz);
		}
		try {
			TypeBodyDeclaration(clazz)
		} finally {
			interface_only = old_mode; PassInfo.pop(clazz);
		}
	]
	{ return ne; }
}

ASTNewArrayExpression NewArrayExpression() :
{ Token t; int dim=0; ASTNewArrayExpression ne = new ASTNewArrayExpression(); }
{
	t="new"
	{
		ne.setPos(t.getPos());
		t = null;
	}
	ne.type = NArrType()
	(
		LOOKAHEAD(2)
		"["
		ne.args += ExpressionNT(null)
		"]"
		{ dim += 1; }
	)+
	(
		<OPERATOR_LRBRACKETS>
		{ dim += 1; }
	)*
	{
		ne.dim = dim;
		return ne;
	}
}

ASTNewInitializedArrayExpression NewInitializedArrayExpression() :
{ Token t; int dim=0; ASTNewInitializedArrayExpression ne = new ASTNewInitializedArrayExpression(); }
{
	t="new"
	{
		ne.setPos(t.getPos());
		t = null;
	}
	ne.type = NArrType()
	(
		<OPERATOR_LRBRACKETS> 
		{ dim += 1; }
	)+
	"{"
	[
		ne.args += VariableInitializer()
		(	LOOKAHEAD(2)
			","
			ne.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{
		ne.dim = dim;
		return ne;
	}
}


/*
 * Statement syntax follows.
 */

Statement Statement() :
{ Statement st; }
{
	(
	  LOOKAHEAD({labledStatementLA()})
	  st = LabeledStatement()
	| st = Block()
	| st = EmptyStatement()
	| st = SwitchStatement()
	| st = IfStatement()
	| st = WhileStatement()
	| st = DoStatement()
	| st = ForStatement()
	| st = ForEachStatement()
	| st = BreakStatement()
	| st = ContinueStatement()
	| st = ReturnStatement()
	| st = ThrowStatement()
	| st = SynchronizedStatement()
	| st = WithStatement()
	| st = TryStatement()
	| st = GotoStatement()
	| st = ReparseStatement()
	| st = StatementExpression()
	)
	{ return st; }
}

Statement ReparseStatement() :
{ Token t; }
{
	t=<REPARSE_STATEMENT>
	{
		ASTReparseStatement st = new ASTReparseStatement();
		st.set(t);
		return st;
	}
}

Statement LabeledStatement() :
{ ASTLabeledStatement st = new ASTLabeledStatement(); }
{
	st.name = Name()
	":"
	st.stat = Statement()
	{ return st; }
}


ASTBlock PrescannedBlock(PrescannedBody b) :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=Block()
	{ return bl; }
}

ASTBlock Block() :
{ boolean old_declMode; }
{
	"{"
	{
		ASTBlock bl = new ASTBlock();
		bl.setPos(getToken(1).getPos());
		PassInfo.push(bl);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	(
			bl.stats += BlockStatement(bl)
		)*
	} finally { declMode = old_declMode; PassInfo.pop(bl); }
    "}"
	{ return bl; }
}

ASTBlock PrescannedRuleBlock(PrescannedBody b) :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=RuleBlock()
	{ return bl; }
}

ASTRuleBlock RuleBlock() :
{ boolean old_declMode; }
{
	"{"
	{
		ASTRuleBlock bl = new ASTRuleBlock();
		bl.setPos(getToken(1).getPos());
		PassInfo.push(bl);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		bl.expr = RuleOrExpression()
	} finally {
		declMode = old_declMode;
		PassInfo.pop(bl);
	}
	"}"
	{ return bl; }
}

ASTBlock CondBlock() :
{}
{
	{
		ASTBlock bl = new ASTBlock();
		bl.setPos(getToken(1).getPos());
		PassInfo.push(bl);
	}
	try {
		(
			"{"
				(
					bl.stats += CondStatement()
				)+
			"}"
		|
			bl.stats += CondStatement()
		)
	} finally { {PassInfo.pop(bl); } }
	{ return bl; }
}

ASTNode BlockStatement(ASTNode parent) :
{ boolean old_declMode; ASTModifiers modifiers; ASTNode st; }
{
	(
		LOOKAHEAD( Modifiers() ("class" | "interface" | "@" "interface") )
		{
			old_declMode = declMode;
			declMode = true;
		}
		try {
			modifiers = Modifiers()
			st = TypeDeclaration(modifiers, parent)
			[ ";" ]
		} finally {
			declMode = old_declMode;
		}
	|	LOOKAHEAD( Modifiers() Type() Name() )
		modifiers = Modifiers()
		st = VarDecls(modifiers)
	|	LOOKAHEAD(0)
		st = Statement()
	)
	{ return st; }
}

ASTCondStatement CondStatement() :
{ Token t = getToken(1); ASTCondStatement st = new ASTCondStatement(); }
{
	st.cond = ExpressionNT(noColonTokenSet)
	[
		":"
		{ t = null; }
		st.message = Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ConstStringExpr e = new ConstStringExpr(KString.from(sb.toString()));
			e.pos = pos;
			st.message = e;
		}
	}
	";"
	{ return st; }
}

Statement EmptyStatement() :
{ Token t; ASTEmptyStatement st = new ASTEmptyStatement(); }
{
	t=";"
	{
		st.setPos(t.getPos());
		return st;
	}
}

Statement StatementExpression() :
{ ASTStatementExpression st = new ASTStatementExpression(); }
{
	st.expr = ExpressionNT(null)
	";"
	{ return st; }
}

ASTSwitchStatement SwitchStatement() :
{ Token t; ASTSwitchStatement st = new ASTSwitchStatement(); }
{
	t="switch"
	{ st.setPos(t.getPos()); }
	"(" st.sel = ExpressionNT(null) ")"
	"{"
	(	st.cases += CaseStatements()	)+
	"}"
	{ return st; }
}

ASTNode CaseStatements() :
{ ASTNode st; }
{
	(
		LOOKAHEAD("case" QName() "(" )
		st = PizzaCase()
	|
		st = NormalCase()
	)
	{ return st; }
}

ASTNormalCase NormalCase() :
{ Token t; ASTNormalCase c = new ASTNormalCase(); }
{
	(
		t="case"
		c.val = ExpressionNT(noColonTokenSet)
		":"
	|
		t="default"
		":"
	)
    { c.setPos(t.getPos()); }
	(
		c.stats += BlockStatement(c)
	)*
	{ return c; }
}

ASTPizzaCase PizzaCase() :
{ Token t; ASTModifiers modifiers; ASTPizzaCase c = new ASTPizzaCase(); }
{
	t="case"
	{ c.setPos(t.getPos()); }
    c.val = QName()
	"("
		[
			modifiers = Modifiers()
			c.params += FormalParameter(modifiers)
			(
				","
				modifiers = Modifiers()
				c.params += FormalParameter(modifiers)
			)*
		]
	")" ":"
	(
		c.stats += BlockStatement(c)
	)*
	{ return c; }
}

ASTIfStatement IfStatement() :
{ Token t; ASTIfStatement st = new ASTIfStatement(); }
{
	t="if"
	{ st.setPos(t.getPos()); }
	[ "!" { st.not = true; } ]
    "(" st.cond = ExpressionNT(null) ")"
	st.thenSt = Statement()
	[	LOOKAHEAD(1)
		"else"
		st.elseSt = Statement()
	]
	{ return st; }
}

ASTWhileStatement WhileStatement() :
{ Token t; ASTWhileStatement st = new ASTWhileStatement(); }
{
	t="while"
	{ st.setPos(t.getPos()); }
	[ "!" { st.not = true; } ]
    "(" st.cond = ExpressionNT(null) ")"
    st.body = Statement()
	{ return st; }
}

ASTDoStatement DoStatement() :
{ Token t; ASTDoStatement st = new ASTDoStatement(); }
{
	t="do"
	{ st.setPos(t.getPos()); }
    st.body = Statement()
    "while"
	[ "!" { st.not = true; } ]
    "(" st.cond = ExpressionNT(null) ")" ";"
	{ return st; }
}

ASTForStatement ForStatement() :
{ Token t; ASTForStatement st = new ASTForStatement(); }
{
	t="for"
	{ st.setPos(t.getPos()); }
	"("
		st.init = ForInit()
	/*";"*/
	[
		st.cond = ExpressionNT(null)
	]
	";"
	[
		st.iter = CommaExpression()
	]
	")"
	st.body = Statement()
	{ return st; }
}

ASTForEachStatement ForEachStatement() :
{ Token t; ASTModifiers modifiers; ASTForEachStatement st = new ASTForEachStatement(); }
{
	t="foreach"
	{ st.setPos(t.getPos()); }
	"("
	[	LOOKAHEAD( Modifiers() FormalParameter() )
		modifiers = Modifiers()
		st.var = FormalParameter(modifiers)
		";"
	]
	st.container = ExpressionNT(null)
	[
	";"
	[ st.cond = ExpressionNT(null) ]
	]
	")"
	st.body = Statement()
	{ return st; }
}

ASTNode ForInit() :
{ ASTModifiers modifiers; ASTNode n; }
{
	(
		LOOKAHEAD( Modifiers() Type() QName() (<OPERATOR_LRBRACKETS>)* ("=" | ":=" | "," | ";") )
		modifiers = Modifiers()
		n = VarDecls(modifiers)
	|
		n = CommaExpression() ";"
	|
		n = EmptyStatement()
 	)
	{ return n; }
}

ASTGotoStatement GotoStatement() :
{ Token t; ASTGotoStatement st = new ASTGotoStatement(); }
{
	t="goto"
	{ st.setPos(t.getPos()); }
	(
		"case"
		{ st.casemode = true; }
		st.expr = ExpressionNT(null)
	|
		"default"
		{ st.casemode = true; }
	|
    	st.expr = Name()
    )
    ";"
	{ return st; }
}

ASTBreakStatement BreakStatement() :
{ Token t; ASTBreakStatement st = new ASTBreakStatement(); }
{
	t="break"
	{ st.setPos(t.getPos()); }
    [ st.ident = Name() ] ";"
	{ return st; }
}

ASTContinueStatement ContinueStatement() :
{ Token t; ASTContinueStatement st = new ASTContinueStatement(); }
{
	t="continue"
	{ st.setPos(t.getPos()); }
    [ st.ident = Name() ] ";"
	{ return st; }
}

ASTReturnStatement ReturnStatement() :
{ Token t; ASTReturnStatement st = new ASTReturnStatement(); }
{
	t="return"
	{ st.setPos(t.getPos()); }
    [ st.expr = ExpressionNT(null) ] ";"
	{ return st; }
}

ASTThrowStatement ThrowStatement() :
{ Token t; ASTThrowStatement st = new ASTThrowStatement(); }
{
	t="throw"
	{ st.setPos(t.getPos()); }
    st.expr = ExpressionNT(null) ";"
	{ return st; }
}

ASTSynchronizedStatement SynchronizedStatement() :
{ Token t; ASTSynchronizedStatement st = new ASTSynchronizedStatement(); }
{
	t="synchronized"
	{ st.setPos(t.getPos()); }
	"(" st.arg = ExpressionNT(null) ")"
	st.body = Block()
	{ return st; }
}

ASTWithStatement WithStatement() :
{ Token t; ASTWithStatement st = new ASTWithStatement(); }
{
	t="with"
	{ st.setPos(t.getPos()); }
	"(" st.arg = ExpressionNT(null) ")"
	st.body = Block()
	{ return st; }
}

ASTTryStatement TryStatement() :
{ Token t; ASTModifiers modifiers; ASTTryStatement st = new ASTTryStatement(); }
{
	t="try"
	{ st.setPos(t.getPos()); }
    st.body = Block()
	(
		st.catchers += CatchInfo()
	)*
	[
		st.finally_catcher = FinallyInfo()
	]
	{ return st; }
}

ASTCatchInfo CatchInfo() :
{ Token t; ASTModifiers modifiers; ASTCatchInfo st = new ASTCatchInfo(); }
{
	t="catch"
	{ st.setPos(t.getPos()); }
	"("
		modifiers = Modifiers()
		st.par = FormalParameter(modifiers)
	")"
	st.body = Block()
	{ return st; }
}

ASTFinallyInfo FinallyInfo() :
{ Token t; ASTFinallyInfo st = new ASTFinallyInfo(); }
{
	t="finally"
	{ st.setPos(t.getPos()); }
	st.body = Block()
	{ return st; }
}



