/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. kiev.jj */
/*@egen*//*
 Copyright (C) 1997-1998, Forestro, http://forestro.com

 This file is part of the Kiev compiler.

 The Kiev compiler is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation.

 The Kiev compiler is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with the Kiev compiler; see the file License.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
*/

options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = true;                                                
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev020)

package kiev.parser;

import kiev.Kiev;
import kiev.vlang.*;

/**
 * $Header: /home/CVSROOT/forestro/kiev/kiev/parser/kiev.jjt,v 1.3.2.1.2.3 1999/05/29 21:03:06 max Exp $
 * @author Maxim Kizub
 * @version $Revision: 1.3.2.1.2.3 $
 *
 */

public class kiev020/*@bgen(jjtree)*/implements kiev020TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTkiev020State jjtree = new JJTkiev020State();

/*@egen*/

	public static boolean	interface_only = false;
	public static boolean	reparse_body = false;
	public static int		reparse_pos = 0;
	public static PreScanneable		presc = null;

	public static boolean	declMode = true;

	static JJTkiev020State getJJTree() { return jjtree; }

    /** Report Parser Error (Exception) */
	public static void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, msg+"\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, msg);
		}
	}

    /** Report other Error (Exception) */
	public static void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(pos, "Internal error:\n"+e);
		} else {
			kiev.Kiev.reportParserError(pos, "Internal error");
		}
		throw e;
	}

	public void reset() {
		jjtree.reset();
	}
/*
	public static void ReInit(byte[] buffer, int begLine, int begCol, int offs) {
		ReInit((CharStream)null);
		CharStream.ReInit(buffer,begLine,begCol,offs);
	}
*/
	private static boolean checkNoSpace(Token t1, Token t2) {
//		System.out.println("Check space between "+t1+" and "+t2+" => "+t1.endLine+"/"+t2.beginLine+":"+
//			t1.endColumn+"/"+t2.beginColumn+" => "+
//			(t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn)
//		);
		return t1.endLine == t2.beginLine && t1.endColumn+1 == t2.beginColumn;
	}

	public static final int[] noColonTokenSet = new int[]{COLON};

	public static int[] no_tokens;

	private static boolean notAToken(Token t) {
		if( no_tokens == null ) return true;
		for(int i=0; i < no_tokens.length; i++) {
			if( t.kind == no_tokens[i] ) return false;
		}
		return true;
	}

	private static boolean operatorLA() {
		switch( getToken(1).kind ) {
		case ASSIGN:
		case ASSIGN2:
		case LT:
		case GT:
		case COLON:
		case QUESTION:
		case ARROW:
		case BANG:
		case TILDE:
		case EQ:
		case LE:
		case GE:
		case NE:
		case SC_OR:
		case SC_AND:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
		case STAR:
		case SLASH:
		case BIT_AND:
		case BIT_OR:
		case XOR:
		case REM:
		case LSHIFT:
//		case RSIGNEDSHIFT:
//		case RUNSIGNEDSHIFT:
		case PLUSASSIGN:
		case MINUSASSIGN:
		case STARASSIGN:
		case SLASHASSIGN:
		case ANDASSIGN:
		case ORASSIGN:
		case XORASSIGN:
		case REMASSIGN:
		case LSHIFTASSIGN:
		case RSIGNEDSHIFTASSIGN:
		case RUNSIGNEDSHIFTASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR:
			return notAToken(getToken(1));
		case OPERATOR_ID:
			return true;
		}
		return false;
	}

//	private static Token	castLAStartToken;
	private static boolean castLA_Start() {
		int i = 1;
		Token t = getToken(i);
		if (t.kind == IDENTIFIER) {
			String qname = t.image;
			while( getToken(i+1).kind == DOT && getToken(i+2).kind == IDENTIFIER) {
				i += 2;
				qname = qname + "." + getToken(i).image;
			}
			switch (getToken(i+1).kind) {
			case RPAREN:
			case LT:
			case LT1:
			case LBRACKET:
				break;
			default:
				return false;
			}
			try {
				if( PassInfo.checkClassName(KString.from(qname)) ) {
//					System.out.println("castLA: "+qname+" is a class/package/interface");
					return true;
				}
			} catch( Exception e ) {}
		}
		return false;
	}

	private static boolean castLA() {
		if( getToken(1).kind != LPAREN ) return false;
		if( getToken(2).kind == CAST ) return true;
		if( getToken(2).kind == REINTERP ) return true;
		return castLA(1,LPAREN,RPAREN);
	}

	private static boolean castLA(int offs, int exp_kind1, int exp_kind2) {
//		System.out.println("castLA "+offs+" "+tokenImage[exp_kind1]+" "+tokenImage[exp_kind2]+" from "+getToken(offs));
		if( getToken(offs).kind != exp_kind1 ) return false;
		switch( getToken(offs+1).kind ) {
		case BOOLEAN: case CHAR: case BYTE:
		case SHORT: case INT: case LONG: case FLOAT:
		case DOUBLE: case VOID:
//			System.out.println("castLA: "+getToken(offs+1)+" is a primitive type");
			return true;
		case IDENTIFIER:
			break;
		case LPAREN:
			// Skip until matched ')' and check for "->"
			{
				int i = offs+2;
				int depth = 1;
				while( depth != 0 ) {
					switch(getToken(i++).kind) {
					case LPAREN: depth++; break;
					case RPAREN: depth--; break;
					}
				}
				if( getToken(i).kind==ARROW ) {
//					System.out.println("castLA: "+getToken(offs+1)+getToken(i-1)+getToken(i)+" is a (...)-> type");
					return true;
				} else {
//					System.out.println("castLA: "+getToken(offs+1)+getToken(i-1)+getToken(i)+" is not a (...)-> type");
					return false;
				}
			}
		default:
			// TODO closure type
			return false;
		}
		// Qualified name resolving to be a class name
		String qname = getToken(offs+1).image;
	scan_qname:
		for(int i=offs+2; ; i+=2) {
			if( getToken(i).kind == DOT && getToken(i+1).kind == IDENTIFIER )
				qname = qname+"."+getToken(i+1).image;
			else {
				switch( getToken(i).kind ) {
				case RPAREN:
					if( exp_kind2 == RPAREN )  break scan_qname;
					else return false;
				case GT:
					if( exp_kind2 == GT ) break scan_qname;
					else return false;
				case GT1:
					if( exp_kind2 == GT1 ) break scan_qname;
					else return false;
				case LT:
					if( castLA(i,LT,GT) ) break scan_qname;
					else return false;
				case LT1:
					if( castLA(i,LT1,GT1) ) break scan_qname;
					else return false;
				case LBRACKET:
					if( getToken(i+1).kind == RBRACKET ) {
//						System.out.println("castLA: "+getToken(i)+getToken(i+1)+" is a []");
						return true;
					}
					else return false;
				case COMMA:
					if( exp_kind1 == LT || exp_kind1 == LT1 ) break scan_qname;
					else return false;
				default:
					return false;
				}
			}
		}
		try {
			if( PassInfo.checkClassName(KString.from(qname)) ) {
//				System.out.println("castLA: "+qname+" is a class/package/interface");
				return true;
			}
		} catch( Exception e ) {}
		return false;
	}

}

PARSER_END(kiev020)


TOKEN_MGR_DECLS :
{
  static int skip_depth = 0;
}

<DEFAULT,IN_CONSTRAINT>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT,IN_CONSTRAINT>
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  <"/**" ([" ","\t","\n","\r"])* "require" [" ","\t","\n","\r"]> { input_stream.backup(8); } : IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "ensure" [" ","\t","\n","\r"]> { input_stream.backup(7); }: IN_CONSTRAINT
|
  <"/**" ([" ","\t","\n","\r"])* "invariant" [" ","\t","\n","\r"]> { input_stream.backup(10); } : IN_CONSTRAINT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<IN_CONSTRAINT>
TOKEN :
{
  < END_CONSTRAINT: "**/" > : DEFAULT
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
//| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
// | < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
// | < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < UNDERSCORE: "_" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ARROW: "->" >
| < FUNCTION: "fun" >
| < EXPORT_CPP: "$export_cpp" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
//| < MULTIMETHOD: "multimethod" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < VIRTUAL: "virtual" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < VARARGS: "..." >
| < FORWARD: "forward" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < RULE: "rule" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < PVAR: "pvar" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < PCUT: "$cut" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < CAST: "$cast" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < REINTERP: "$reinterp" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < ALIAS: "alias" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < OPERATOR_ID: "operator" > { if(Kiev.javaMode) matchedToken.kind=IDENTIFIER; }
| < TYPEDEF: "typedef" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENUM: "enum" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < REQUIRE: "require" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < ENSURE: "ensure" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < INVARIANT: "invariant" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < GENERATE: "$generate" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

| < PACKED: "packed" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
| < WRAPPER: "$wrapper" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< ACCESS: "access:" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; } : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY: "ro" | "r" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < WRITE_ONLY: "wo" | "w"> { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < READ_WRITE: "rw" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < NO_READ_WRITE: "n" | "no" > { if(Kiev.javaMode || !kiev020.declMode) matchedToken.kind=IDENTIFIER; }
 | < COMMA1: "," >
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < REPARSE_EXPRESSION:
      "#" ["E","e"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
|
  < REPARSE_STATEMENT:
      "#" ["S","s"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
       ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON: ":" >
| < QUESTION: "?" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < LT1: "/*<" >
| < GT: ">" >
| < GT1: ">*/" >
}

<DEFAULT,IN_CONSTRAINT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < ASSIGN2: ":=" >
//| < GT: ">" >
//| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
//| < HOOK: "?" >
//| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//| < RSIGNEDSHIFT: ">>" >
//| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP:	"#" >
| < OPERATOR:	    ["\u2200"-"\u22f1"] >

}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTFileUnit FileUnit(String filename) :
{/*@bgen(jjtree) FileUnit */
  ASTFileUnit jjtn000 = new ASTFileUnit(JJTFILEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FileUnit */
        try {
/*@egen*/
	{
		Kiev.curASTFileUnit = jjtn000;
		jjtn000.setFileName(filename);
		jjtn000.setPos(0);
		declMode = true;
	}
	[
		LOOKAHEAD("package" QName() ";")
		Package()
	]
	(	Import()	)*
	(	Typedef()	)*
	[
		LOOKAHEAD("package" "{")
		PackageDeclaration()
	]
	(
		try {
			LOOKAHEAD( (Modifier())* ("class" | "interface") )
			TypeDeclaration() [ ";" ]
	|
			LOOKAHEAD( (Modifier())* "enum" )
			EnumDeclaration() [ ";" ]
		}
		catch(ParseError e) { rpe("Bad class declaration",e); }
		catch(Throwable e) { rperr(e); }
	)*
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		declMode = true;
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Package() :
{/*@bgen(jjtree) Package */
  ASTPackage jjtn000 = new ASTPackage(JJTPACKAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Package */
        try {
/*@egen*/
	try {
		"package" QName() ";"
	}
	catch(ParseError e) { rpe("Bad package declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Import() :
{/*@bgen(jjtree) Import */
  ASTImport jjtn000 = new ASTImport(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Import */
        try {
/*@egen*/
	try {
		"import"
		(	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
			<IDENTIFIER>{ jjtn000.mode = ASTImport.IMPORT_SYNTAX; }
			[ QName() ]
		|	"package"	{ jjtn000.mode = ASTImport.IMPORT_PACKAGE; }
			[ QName() ]
		|	"static"	{ jjtn000.mode = ASTImport.IMPORT_STATIC; }
			QName()
			[	"." "*" { jjtn000.star = true; }
			|	"("		{ jjtn000.args = ASTType.emptyArray; }
				Type() ("," Type())*
				")"
			]
		|	QName()
			[	"." "*" { jjtn000.star = true; }
			|	"("		{ jjtn000.args = ASTType.emptyArray; }
				Type() ("," Type())*
				")"
			]
		)
		";"
	}
	catch(ParseError e) { rpe("Bad import declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Typedef() :
{/*@bgen(jjtree) Typedef */
  ASTTypedef jjtn000 = new ASTTypedef(JJTTYPEDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Typedef */
        try {
/*@egen*/
	try {
		"typedef" Type() Identifier() ";"
	}
	catch(ParseError e) { rpe("Bad typedef declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Repackage() :
{/*@bgen(jjtree) Repackage */
  ASTRepackage jjtn000 = new ASTRepackage(JJTREPACKAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Repackage */
        try {
/*@egen*/
	try {
		"#repackage" QName() "->" QName() ";"
	}
	catch(ParseError e) { rpe("Bad repackage declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PackageDeclaration() :
{/*@bgen(jjtree) PackageDeclaration */
  ASTPackageDeclaration jjtn000 = new ASTPackageDeclaration(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PackageDeclaration */
        try {
/*@egen*/
	try {
		"package"
	}
	catch(ParseError e) { rpe("Bad start of package declaration",e); }
	catch(Throwable e) { rperr(e); }
	"{"
	(
		Typedef()
	|	Import()
	|	Repackage()
	)*
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeDeclaration() :
{/*@bgen(jjtree) TypeDeclaration */
  ASTTypeDeclaration jjtn000 = new ASTTypeDeclaration(JJTTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) TypeDeclaration */
        try {
/*@egen*/
	try {
		( Modifier() )*
		(
			t="class"
		|	t="interface"
		)
	}
	catch(ParseError e) { rpe("Bad start of class declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtn000.set(t); t = null; }
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("Class's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[	Extends()			]
	[	Implements()		]
	[	Generate()			]
	TypeBodyDeclaration()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeBodyDeclaration()       :
{}
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		(
			LOOKAHEAD( ( Modifier() )* "{" )
			Initializer()
		|
			LOOKAHEAD( ( Modifier() )* "invariant" )
			InvariantDeclaration() [ ";" ]
		|
			LOOKAHEAD( ( Modifier() | Access() )* ("class" | "interface") )
			TypeDeclaration() [ ";" ]
		|
			LOOKAHEAD( ( Modifier() | Access() )* "enum" )
			EnumDeclaration() [ ";" ]
		|
			LOOKAHEAD( ( Modifier() | Access() )* "case" )
			CaseTypeDeclaration()
		|
			LOOKAHEAD( ( Modifier() | Access() )* "rule" ( Modifier() )*  <IDENTIFIER> "(")
			RuleDeclaration()
//		|
//			LOOKAHEAD( ( Modifier() )* "production" ( Modifier() )* Type() <IDENTIFIER> "(")
//			ProductionDeclaration()
		|
			LOOKAHEAD( ( Modifier() | Access() )* [ Type() ] [ <IDENTIFIER> ] "(" )
			MethodDeclaration()
		|
			LOOKAHEAD( ( Modifier() | Pack() | Access() )* Type() <IDENTIFIER> ("[" "]")* ("=" | ":=" | "," | ";") )
			FieldDecl()
		|
			Import()

//		| OptionSpec()
//		| TokenDeclaration()
		)*
	}
	catch(ParseError e) { rpe("Field, method or class declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void EnumDeclaration() :
{/*@bgen(jjtree) EnumDeclaration */
  ASTEnumDeclaration jjtn000 = new ASTEnumDeclaration(JJTENUMDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumDeclaration */
        try {
/*@egen*/
	try {
		( Modifier() | Access() )*
		"enum"
	}
	catch(ParseError e) { rpe("Bad start of enum declaration",e); }
	catch(Throwable e) { rperr(e); }
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("enum's name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	Extends()			]
	EnumBodyDeclaration()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EnumBodyDeclaration()       :
{}
{
	try {
		"{"
	}
	catch(ParseError e) { rpe("'{' expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		Identifier() ["=" DecimalConstExpression()] [":"  StringConstExpression()]
		(	LOOKAHEAD(2)
			"," Identifier() ["=" DecimalConstExpression()] [":"  StringConstExpression()]
		)*
		[ "," ]
	}
	catch(ParseError e) { rpe("Enumeration values are expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		"}"
	}
	catch(ParseError e) { rpe("'}' expected",e); }
	catch(Throwable e) { rperr(e); }
}

void CaseTypeDeclaration() :
{/*@bgen(jjtree) CaseTypeDeclaration */
  ASTCaseTypeDeclaration jjtn000 = new ASTCaseTypeDeclaration(JJTCASETYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; ASTBlock bl; }
{/*@bgen(jjtree) CaseTypeDeclaration */
        try {
/*@egen*/
	try {
		( Modifier() | Access() )*
		t="case"
	}
	catch(ParseError e) { rpe("Bad start of class declaration",e); }
	catch(Throwable e) { rperr(e); }
	{ jjtn000.set(t); }
	try {
		Identifier()
	}
	catch(ParseError e) { rpe("Class's case name expected",e); }
	catch(Throwable e) { rperr(e); }
	[	ClazzArguments()	]
	[
		"("
			try {
			[
				FormalParameter()
				(	","	FormalParameter()	)*
			]
			}
			catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
			catch(Throwable e) { rperr(e); }
		")"
	]
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Class's case constructor body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void ClazzArguments()       :
{}
{
	("<" | "/*<")
		try {
			ArgumentDeclaration()
			(	","
				ArgumentDeclaration()
			)*
		}
		catch(ParseError e) { rpe("Class's argument expected",e); }
		catch(Throwable e) { rperr(e); }
	(">" | ">*/")
}

void Extends() :
{/*@bgen(jjtree) Extends */
  ASTExtends jjtn000 = new ASTExtends(JJTEXTENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Extends */
        try {
/*@egen*/
	t="extends" { jjtn000.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Super class name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Implements() :
{/*@bgen(jjtree) Implements */
  ASTImplements jjtn000 = new ASTImplements(JJTIMPLEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Implements */
        try {
/*@egen*/
	t="implements" { jjtn000.setPos(t.getPos()); }
	try {
	    NonArrayType()
		( "," NonArrayType() )*
	}
	catch(ParseError e) { rpe("Interface name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Generate() :
{/*@bgen(jjtree) Generate */
  ASTGenerate jjtn000 = new ASTGenerate(JJTGENERATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int i=0; }
{/*@bgen(jjtree) Generate */
        try {
/*@egen*/
	"$generate"
	try {
		"<"
			(PrimitiveType() | Identifier()) { i++; }
			( "," (PrimitiveType() | Identifier()) { i++; } )*
		">"
//		{
//		if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//			throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//		}
		(
			"," { i = 0; }
			"<"
				(PrimitiveType() | Identifier()) { i++; }
				( "," (PrimitiveType() | Identifier()) { i++; } )*
			">"
//			{
//			if( i != ((ASTTypeDeclaration)jjtThis.jjtGetParent()).argument.length )
//				throw new ParseException("Number of arguments of type and in '$generate' missmatch");
//			}
		)*
	}
	catch(ParseError e) { rpe("Bad $generate directive",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArgumentDeclaration() :
{/*@bgen(jjtree) ArgumentDeclaration */
  ASTArgumentDeclaration jjtn000 = new ASTArgumentDeclaration(JJTARGUMENTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentDeclaration */
        try {
/*@egen*/
	Identifier()
	[
		"extends" NonArrayType()
	|	"implements" NonArrayType()
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Modifier() :
{/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) Modifier */
        try {
/*@egen*/
	(
	  t="public"
	| t="protected"
	| t="private"
	| t="static"
	| t="abstract"
	| t="final"
	| t="native"
	| t="synchronized"
	| t="transient"
	| t="volatile"
	//| t="multimethod"
	| t="virtual"
	| t="forward"
	| t="pvar"

	| t="$wrapper"

//	| t="grammar"
	| t="$export_cpp"
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ModifierConst()           :
{/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t=null; }
{/*@bgen(jjtree) Modifier */
        try {
/*@egen*/
	t="const"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
/*
void OptionSpec() :
{}
{
	"options"
	"{"
	(
		OptionBinding() ";"
	)*
	"}"
}

void OptionBinding() :
{ Token t = null; }
{
	(
		t="errorreporting" "=" StringConstExpression()
	|	t="ignorecase" "=" BooleanConstExpression()
	|	t="lookahead" "=" DecimalConstExpression()
	|	t="scannername" "=" QName()
	)
	{ jjtThis.set(t); }
}

void TokenDeclaration() :
{}
{
	[ LexicalStateList() ]
	RegularExpressionKind()
	[ "[" "ignorecase" "]" ]
	"{"
		RegularExpressionSpec()
		(
			"|"
			RegularExpressionSpec()
		)*
	"}"
}

void LexicalStateList() :
{}
{
	"<"
	(
		"*"
	|	Identifier()
		( "," Identifier() )*
	)
	">"
}

void RegularExpressionKind() :
{ Token t=null; }
{
	(
		t="token"
	|	t="specialtoken"
	|	t="skip"
	|	t="more"
	)
	{ jjtThis.set(t); }
}

void RegularExpressionSpec() :
{}
{
	RegularExpression()
	[ Block() ]
	[ ":" Identifier() ]
}

void RegularExpression() #void :
{}
{
	(
		LOOKAHEAD(3)
		SimpleRegularExpression()
	|	ComplexRegularExpression()
	)
}

void SimpleRegularExpression() :
{}
{
		StringConstExpression()
	|	"<"
		(
			Identifier()
		|	"eof"
		)
		">"
}

void ComplexRegularExpression() :
{ Token t = null;}
{
	"<"
		[
			[
				t="#"
			]
			Identifier()
			{
				if( t!=null) {
					ASTIdentifier id = (ASTIdentifier)jjtree.peekNode();
					id.name = KString.from(token.image+id.name);
					t = null;
				}
			}
			":"
		]
		ComplexRegularExpressionChoices()
	">"
}

void ComplexRegularExpressionChoices() :
{}
{
	ComplexRegularExpressionUnits()
	(
		"|"
		ComplexRegularExpressionUnits()
	)*
}

void ComplexRegularExpressionUnits() :
{}
{
	( ComplexRegularExpressionUnit() )*
}

void ComplexRegularExpressionUnit() :
{ Token t=null; }
{
		StringConstExpression()
	|	"<" Identifier() ">"
	|	CharacterList()
	|	"(" ComplexRegularExpressionChoices() ")"
		[
			t="+"
		|
			t="*"
		|
			t="?"
		|	"{" Expression() [ "," Expression() ] "}" ]
	{ jjtThis.set(t); }
}

void CharacterList() :
{}
{
	[
		"~"
		{ jjtThis.setNot(); }
	]
	"["
		[
		CharacterDescriptor()
		( "," CharacterDescriptor() )*
		]
	"]"
}

void CharacterDescriptor() :
{ Token t = null; }
{
	t=<CHARACTER_LITERAL>
	{ jjtThis.set(t); }
	[
		"-"
		t=<CHARACTER_LITERAL>
		{ jjtThis.set(t); }
	]
}
*/
void Pack() :
{/*@bgen(jjtree) Pack */
  ASTPack jjtn000 = new ASTPack(JJTPACK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int size=-1; int offset=-1; String packer=null; }
{/*@bgen(jjtree) Pack */
        try {
/*@egen*/
	"packed"
	[
		":"
		t=<INTEGER_LITERAL> { size = Integer.parseInt(t.image); t = null; }
		[
		","
		t=<IDENTIFIER> { packer = t.image; t = null; }
		","
		t=<INTEGER_LITERAL> { offset = Integer.parseInt(t.image); t = null; }
		]
	]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(size,packer,offset); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Access() :
{/*@bgen(jjtree) Access */
  ASTAccess jjtn000 = new ASTAccess(JJTACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ int acc; }
{/*@bgen(jjtree) Access */
        try {
/*@egen*/
	"access:"
	acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	[ <COMMA1> acc = AccessSpec() { jjtn000.set(acc); }
	]]]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

int AccessSpec()       :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

void FieldDecl() :
{/*@bgen(jjtree) FieldDecl */
  ASTFieldDecl jjtn000 = new ASTFieldDecl(JJTFIELDDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) FieldDecl */
        try {
/*@egen*/
	( Modifier() | Pack() | Access() )*
	try {
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	{ old_declMode = declMode; declMode = false; }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Field declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	finally { declMode = old_declMode; }
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VarDecls() :
{/*@bgen(jjtree) VarDecls */
  ASTVarDecls jjtn000 = new ASTVarDecls(JJTVARDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecls */
        try {
/*@egen*/
	try {
		( Modifier() )*
		Type()
	}
	catch(ParseError e) { rpe("Type expected",e); }
	catch(Throwable e) { rperr(e); }
	try {
		VarDecl()
		(	","	VarDecl() )*
	}
	catch(ParseError e) { rpe("Variable declaration expected",e); }
	catch(Throwable e) { rperr(e); }
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VarDecl() :
{/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
        try {
/*@egen*/
	Identifier()
	( "[" "]" { jjtn000.dim++; } )*
	[ ("=" | ":=" { jjtn000.of_wrapper=true; }) VariableInitializer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableInitializer()       :
{}
{
	(
		ArrayInitializer()
	|
		Expression()
	)
}

void ArrayInitializer()                                :
{/*@bgen(jjtree) NewInitializedArrayExpression */
  ASTNewInitializedArrayExpression jjtn000 = new ASTNewInitializedArrayExpression(JJTNEWINITIALIZEDARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NewInitializedArrayExpression */
        try {
/*@egen*/
	t="{"
	[	LOOKAHEAD(2)
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTFormalParameter FormalParameter() :
{/*@bgen(jjtree) FormalParameter */
  ASTFormalParameter jjtn000 = new ASTFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FormalParameter */
        try {
/*@egen*/
	(
		( Modifier() )*
		[ ModifierConst() ]
		Type()
		Identifier()
		( "[" "]" { jjtn000.dim++; } )*
	|
		t="_" { jjtn000.set(t); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTFormalParameter mmFormalParameter()                  :
{/*@bgen(jjtree) FormalParameter */
  ASTFormalParameter jjtn000 = new ASTFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FormalParameter */
        try {
/*@egen*/
	(
		( Modifier() )*
		Type()
		(
			LOOKAHEAD({ !Kiev.javaMode && (getToken(1).image.equals(":")) })
			(":") Type()
		)?
		Identifier()
		( "[" "]" { jjtn000.dim++; } )*
	|
		t="_" { jjtn000.set(t); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Throws() :
{/*@bgen(jjtree) Throws */
  ASTThrows jjtn000 = new ASTThrows(JJTTHROWS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Throws */
        try {
/*@egen*/
	t="throws" { jjtn000.setPos(t.getPos()); }
	try {
		NonArrayType()
		(	"," NonArrayType()	)*
	}
	catch(ParseError e) { rpe("Throwable class name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Alias()       :
{ Token t; }
{
	"alias"
	(
		IdentifierAlias()
|		OperatorAlias()
	)
}

void IdentifierAlias() :
{/*@bgen(jjtree) IdentifierAlias */
  ASTIdentifierAlias jjtn000 = new ASTIdentifierAlias(JJTIDENTIFIERALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IdentifierAlias */
        try {
/*@egen*/
	Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void OperatorAlias() :
{/*@bgen(jjtree) OperatorAlias */
  ASTOperatorAlias jjtn000 = new ASTOperatorAlias(JJTOPERATORALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OperatorAlias */
        try {
/*@egen*/
	"operator"
	"("
	DecimalConstExpression()	","
	Identifier()		","
	(
		Operator()
	|	Identifier()
	|	"[" "]"	{ jjtn000.image = kiev.vlang.Constants.nameArrayOp; }
	|	"new"	{ jjtn000.image = kiev.vlang.Constants.nameNewOp; }
	|	"$cast"	{ jjtn000.image = kiev.vlang.Constants.nameCastOp; }
	)
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MaybeSkipBlock()       :
{ boolean old_declMode; }
{
	(
		LOOKAHEAD({ interface_only })
//		{ old_declMode = declMode; declMode = false; }
//		try {
			"{"
			{
			Token tk = getToken(0);
			PrescannedBody pbody = new PrescannedBody(tk.beginLine,tk.beginColumn);
			Kiev.curASTFileUnit.addPrescannedBody(pbody);
			int depth = 1;
			do {
				tk = getNextToken();
				if( tk.kind == LBRACE ) depth++;
				else if( tk.kind == RBRACE ) depth--;
			} while( depth > 0 );
			presc.pbody = pbody;
			if( presc instanceof ASTCondDeclaration )
				pbody.mode = PrescannedBody.CondBlockMode;
			else if( presc instanceof ASTRuleDeclaration )
				pbody.mode = PrescannedBody.RuleBlockMode;
			else
				pbody.mode = PrescannedBody.BlockMode;
			}
//		} finally { declMode = old_declMode; }
	|	LOOKAHEAD({ presc instanceof ASTCondDeclaration })
		CondBlock()
	|	LOOKAHEAD({ presc instanceof ASTRuleDeclaration })
		RuleBlock()
	|	Block()
	)
}

void MethodDeclaration() :
{/*@bgen(jjtree) MethodDeclaration */
  ASTMethodDeclaration jjtn000 = new ASTMethodDeclaration(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MethodDeclaration */
        try {
/*@egen*/
	( Modifier() | Access() )*
	[
		LOOKAHEAD( Type() <IDENTIFIER> )
		Type()
	]
	Identifier()
	"("
		try {
		[
			mmFormalParameter()
			(LOOKAHEAD(2)	","	mmFormalParameter()	)*
			[ [","] "..." { jjtn000.setVarArgs(true); } ]
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	( "[" "]" { jjtn000.dim++; } )*
	[ ModifierConst() ]
	(
		Alias()
	)*
	[	Throws()	]
	try {
		(
			RequareDeclaration()
		|	EnsureDeclaration()
		)*
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RequareDeclaration() :
{/*@bgen(jjtree) RequareDeclaration */
  ASTRequareDeclaration jjtn000 = new ASTRequareDeclaration(JJTREQUAREDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RequareDeclaration */
        try {
/*@egen*/
	"require"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
			CondBlock()
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
			CondBlock()
		|	CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'require' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EnsureDeclaration() :
{/*@bgen(jjtree) EnsureDeclaration */
  ASTEnsureDeclaration jjtn000 = new ASTEnsureDeclaration(JJTENSUREDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnsureDeclaration */
        try {
/*@egen*/
	"ensure"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
			CondBlock()
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
			CondBlock()
		|	CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'ensure' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InvariantDeclaration() :
{/*@bgen(jjtree) InvariantDeclaration */
  ASTInvariantDeclaration jjtn000 = new ASTInvariantDeclaration(JJTINVARIANTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InvariantDeclaration */
        try {
/*@egen*/
	( Modifier() )*
	"invariant"
	try {
		(
			LOOKAHEAD("[" <IDENTIFIER> "]" )
			"[" Identifier() "]"
			CondBlock()
		|	LOOKAHEAD(<IDENTIFIER> "{")
			Identifier()
			CondBlock()
		|	CondBlock()
		)
	}
	catch(ParseError e) { rpe("Bad 'invariant' declaration",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleDeclaration() :
{/*@bgen(jjtree) RuleDeclaration */
  ASTRuleDeclaration jjtn000 = new ASTRuleDeclaration(JJTRULEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ ASTBlock bl; ASTFormalParameter lv; }
{/*@bgen(jjtree) RuleDeclaration */
        try {
/*@egen*/
	[ LOOKAHEAD(2) "rule" ]
	( Modifier() | Access() )*
	[ "rule" ]
	Identifier()
	"("
		try {
		[
			FormalParameter()
			(LOOKAHEAD(2)	","	FormalParameter()	)*
		]
		}
		catch(ParseError e) { rpe("Formal parameter(s) expected",e); }
		catch(Throwable e) { rperr(e); }
	")"
	(
		Alias()
	)*
	(
		lv=FormalParameter() { lv.setLocalPrologVar(true); lv = null; }
		";"
	)*
	try {
		(
			LOOKAHEAD("{")
			{ presc = jjtn000; }
			MaybeSkipBlock() [ ";" ]
		|	";"
		)
	}
	catch(ParseError e) { rpe("Method's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Initializer() :
{/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initializer */
        try {
/*@egen*/
	( Modifier() )*
	try {
		{ presc = jjtn000; }
		MaybeSkipBlock() [ ";" ]
	}
	catch(ParseError e) { rpe("Initializer's body expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/*
 * Type, name and expression syntax follows.
 */

void Type() :
{/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	(	NonArrayType()
		(	LOOKAHEAD(2)
			"[" "]" { jjtn000.dim++; }
		)*
	|	ClosureType()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClosureType() :
{/*@bgen(jjtree) ClosureType */
  ASTClosureType jjtn000 = new ASTClosureType(JJTCLOSURETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ClosureType */
        try {
/*@egen*/
	t="(" { jjtn000.setPos(t.getPos()); }
	[
		Type()
		( "," Type() )*
	]
	")" "->" Type()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void NonArrayType() :
{/*@bgen(jjtree) NonArrayType */
  ASTNonArrayType jjtn000 = new ASTNonArrayType(JJTNONARRAYTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NonArrayType */
        try {
/*@egen*/
	try {
	(
		PrimitiveType()
	|	QName()
		[
			LOOKAHEAD(2)
			("<" | "/*<")
				Type()
				( "," Type() )*
			(">" | ">*/")
		]
	)
	[
		"@" {jjtn000.isPrologVar = true; }
	|	"&" {jjtn000.isRefProxy = true; }
	]
	}
	catch(ParseError e) { rpe("Bad type specification",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PrimitiveType() :
{/*@bgen(jjtree) PrimitiveType */
  ASTPrimitiveType jjtn000 = new ASTPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PrimitiveType */
         try {
/*@egen*/
	 (
	  t="boolean"
	| t="char"
	| t="byte"
	| t="short"
	| t="int"
	| t="long"
	| t="float"
	| t="double"
	| t="void"
	| t="rule"
	  )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void QName() :
{/*@bgen(jjtree) QName */
  ASTQName jjtn000 = new ASTQName(JJTQNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QName */
        try {
/*@egen*/
	try {
		Identifier()
		( LOOKAHEAD(2) "." Identifier() )*
	}
	catch(ParseError e) { rpe("Qualified name expected",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Expression syntax follows.
 */

void CommaExpression()                      :
{/*@bgen(jjtree) #CommaExpression(> 1) */
  ASTCommaExpression jjtn000 = new ASTCommaExpression(JJTCOMMAEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CommaExpression(> 1) */
        try {
/*@egen*/
	Expression()
	( "," Expression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleOrExpression()                       :
{/*@bgen(jjtree) #RuleOrExpression(> 1) */
  ASTRuleOrExpression jjtn000 = new ASTRuleOrExpression(JJTRULEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RuleOrExpression(> 1) */
        try {
/*@egen*/
	RuleAndExpression()
	( ";" RuleAndExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleAndExpression()                        :
{/*@bgen(jjtree) #RuleAndExpression(> 1) */
  ASTRuleAndExpression jjtn000 = new ASTRuleAndExpression(JJTRULEANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RuleAndExpression(> 1) */
        try {
/*@egen*/
	RuleExpression()
	( "," RuleExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RuleExpression()       :
{ Token t = null; }
{
	(
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_THE
	})
	RuleIstheExpression()
|
	LOOKAHEAD( {
		getToken(1).kind == IDENTIFIER
	 && getToken(2).kind == IS_ONE_OF
	})
	RuleIsoneofExpression()
|
	LOOKAHEAD("$cut")
	RuleCutExpression()
|
	LOOKAHEAD("{")
	"{" RuleOrExpression() "}"
|
	LOOKAHEAD(3)
	[t="while"] Expression()/*@bgen(jjtree) #RuleExpression( 1) */
                                 {
                                   ASTRuleExpression jjtn001 = new ASTRuleExpression(JJTRULEEXPRESSION);
                                   boolean jjtc001 = true;
                                   jjtree.openNodeScope(jjtn001);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn001,  1);
                                   jjtc001 = false;
                                 }
/*@egen*/ { if( t!= null ) { jjtn001.while_mode=true; t=null; } }/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc001) {
                                     jjtree.closeNodeScope(jjtn001,  1);
                                   }
                                 }
/*@egen*/
	)
}

void RuleIstheExpression() :
{/*@bgen(jjtree) RuleIstheExpression */
  ASTRuleIstheExpression jjtn000 = new ASTRuleIstheExpression(JJTRULEISTHEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleIstheExpression */
        try {
/*@egen*/
	Identifier() "?=" AccessExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleIsoneofExpression() :
{/*@bgen(jjtree) RuleIsoneofExpression */
  ASTRuleIsoneofExpression jjtn000 = new ASTRuleIsoneofExpression(JJTRULEISONEOFEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleIsoneofExpression */
        try {
/*@egen*/
	Identifier() "@=" AccessExpression()
	(
		LOOKAHEAD({
			getToken(1).image.equals("&")
		 && getToken(2).kind == IDENTIFIER
		 && getToken(3).kind == IS_ONE_OF
		})
		"&" Identifier() "@=" AccessExpression()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RuleCutExpression() :
{/*@bgen(jjtree) RuleCutExpression */
  ASTRuleCutExpression jjtn000 = new ASTRuleCutExpression(JJTRULECUTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RuleCutExpression */
        try {
/*@egen*/
	t="$cut"/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.setPos(t.getPos()); t = null; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Operator() :
{/*@bgen(jjtree) Operator */
  ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String image; }
{/*@bgen(jjtree) Operator */
        try {
/*@egen*/
	(
		(
			t=<ASSIGN>
		|	t=<ASSIGN2>
		|	t=<LT>
		|	t=<GT>
		|	t=<COLON>
		|	t=<QUESTION>
		|	t=<ARROW>
		|	t=<BANG>
		|	t=<TILDE>
		|	t=<EQ>
		|	t=<LE>
		|	t=<GE>
		|	t=<NE>
		|	t=<SC_OR>
		|	t=<SC_AND>
		|	t=<INCR>
		|	t=<DECR>
		|	t=<PLUS>
		|	t=<MINUS>
		|	t=<STAR>
		|	t=<SLASH>
		|	t=<BIT_AND>
		|	t=<BIT_OR>
		|	t=<XOR>
		|	t=<REM>
		|	t=<LSHIFT>
//		|	t=<RSIGNEDSHIFT>
//		|	t=<RUNSIGNEDSHIFT>
		|	t=<PLUSASSIGN>
		|	t=<MINUSASSIGN>
		|	t=<STARASSIGN>
		|	t=<SLASHASSIGN>
		|	t=<ANDASSIGN>
		|	t=<ORASSIGN>
		|	t=<XORASSIGN>
		|	t=<REMASSIGN>
		|	t=<LSHIFTASSIGN>
		|	t=<RSIGNEDSHIFTASSIGN>
		|	t=<RUNSIGNEDSHIFTASSIGN>
		|	t=<OPERATOR_AT>
		|	t=<OPERATOR_SHARP>
		|	t=<OPERATOR>
		)
		{ image = t.image; }
		(
			LOOKAHEAD({ !Kiev.javaMode && operatorLA() && checkNoSpace(getToken(0),getToken(1)) })
			(
				t=<ASSIGN>
			|	t=<ASSIGN2>
			|	t=<LT>
			|	t=<GT>
			|	t=<COLON>
			|	t=<QUESTION>
			|	t=<ARROW>
			|	t=<BANG>
			|	t=<TILDE>
			|	t=<EQ>
			|	t=<LE>
			|	t=<GE>
			|	t=<NE>
			|	t=<SC_OR>
			|	t=<SC_AND>
			|	t=<INCR>
			|	t=<DECR>
			|	t=<PLUS>
			|	t=<MINUS>
			|	t=<STAR>
			|	t=<SLASH>
			|	t=<BIT_AND>
			|	t=<BIT_OR>
			|	t=<XOR>
			|	t=<REM>
			|	t=<LSHIFT>
//			|	t=<RSIGNEDSHIFT>
//			|	t=<RUNSIGNEDSHIFT>
			|	t=<PLUSASSIGN>
			|	t=<MINUSASSIGN>
			|	t=<STARASSIGN>
			|	t=<SLASHASSIGN>
			|	t=<ANDASSIGN>
			|	t=<ORASSIGN>
			|	t=<XORASSIGN>
			|	t=<REMASSIGN>
			|	t=<LSHIFTASSIGN>
			|	t=<RSIGNEDSHIFTASSIGN>
			|	t=<RUNSIGNEDSHIFTASSIGN>
			|	t=<OPERATOR_AT>
			|	t=<OPERATOR_SHARP>
			|	t=<OPERATOR>
			)
			{ image = image+t.image; }
		|
			LOOKAHEAD({ Kiev.javaMode && getToken(1).kind==GT && checkNoSpace(getToken(0),getToken(1)) })
			t=<GT>
			{ image = image+t.image; }
		)*
	|	LOOKAHEAD({ !Kiev.javaMode })
		"operator" t=<IDENTIFIER>
		{ image = t.image; }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setPos(t.getPos());
		jjtn000.image = KString.from(image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CastOperatorLA()       :
{}
{
	"("
	(
		<CAST>
	|	<REINTERP>
	|	PrimitiveType()
	|	LOOKAHEAD(0,{ castLA_Start() }) Type() ")"
		(
			<IDENTIFIER>
		|	"("
		|	ConstExpression()
		|	"new"
		|	Operator()
		|	ReparseExpression()
		|	"fun"
		)
	)
}

void CastOperator() :
{/*@bgen(jjtree) CastOperator */
  ASTCastOperator jjtn000 = new ASTCastOperator(JJTCASTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) CastOperator */
        try {
/*@egen*/
	t="(" { jjtn000.setPos(t.getPos()); } [ <CAST> | <REINTERP> {jjtn000.reinterp=true;} ] Type() ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionNT(int[] nt_new)       :
{ int[] nt_old = no_tokens; no_tokens = nt_new; }
{
	try {
		Expression()
	} finally { no_tokens = nt_old; }
}

void Expression() :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	try {
		(
			LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("instanceof") })
			Identifier() Type()
		|	LOOKAHEAD({ operatorLA() })
			Operator()
//		|	LOOKAHEAD({ castLA() })
		|	LOOKAHEAD( CastOperatorLA() )
			CastOperator()
		|	LOOKAHEAD(2)
			AccessExpression()
		)+
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReparseExpression() :
{/*@bgen(jjtree) ReparseExpression */
  ASTReparseExpression jjtn000 = new ASTReparseExpression(JJTREPARSEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReparseExpression */
        try {
/*@egen*/
	try {
		t=<REPARSE_EXPRESSION> { jjtn000.set(t); }
	}
	catch(ParseError e) { rpe("Bad expression",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CallExpression() :
{/*@bgen(jjtree) CallExpression */
  ASTCallExpression jjtn000 = new ASTCallExpression(JJTCALLEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CallExpression */
                try {
/*@egen*/
		Identifier() "("
		[	ExpressionNT(null)
			(	"," ExpressionNT(null)	)*
		]
		")"/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void AccessExpression()       :
{ Token t; }
{
	(
		LOOKAHEAD( Type() "." "class" )
		Type() "."/*@bgen(jjtree) #TypeClassExpression( 1) */
                           {
                             ASTTypeClassExpression jjtn001 = new ASTTypeClassExpression(JJTTYPECLASSEXPRESSION);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ "class"/*@bgen(jjtree)*/
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  1);
                             }
                           }
/*@egen*/
	|
		LOOKAHEAD(2)
		ConstExpression()
	|
		LOOKAHEAD(2)
		CallExpression()
	|
		LOOKAHEAD(2)
		Identifier()
	|
		LOOKAHEAD("new" NonArrayType() ("[" "]")+ "{" )
		NewInitializedArrayExpression()
	|
		LOOKAHEAD("new" NonArrayType() "[" )
		NewArrayExpression()
	|
		LOOKAHEAD("new" QName() ( "(" | "<" | "/*<" ) )
		NewExpression()
	|
		ReparseExpression()
	|
		"(" ExpressionNT(null) ")"
	|   LOOKAHEAD("fun" "(")
		AnonymouseClosure()
	)
	(
		LOOKAHEAD(3)
		"."/*@bgen(jjtree) #CallAccessExpression( 2) */
                    {
                      ASTCallAccessExpression jjtn002 = new ASTCallAccessExpression(JJTCALLACCESSEXPRESSION);
                      boolean jjtc002 = true;
                      jjtree.openNodeScope(jjtn002);
                    }
                    try {
/*@egen*/ CallExpression()/*@bgen(jjtree)*/
                    } catch (Throwable jjte002) {
                      if (jjtc002) {
                        jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte002 instanceof RuntimeException) {
                        throw (RuntimeException)jjte002;
                      }
                      if (jjte002 instanceof ParseException) {
                        throw (ParseException)jjte002;
                      }
                      throw (Error)jjte002;
                    } finally {
                      if (jjtc002) {
                        jjtree.closeNodeScope(jjtn002,  2);
                      }
                    }
/*@egen*/
	|
		LOOKAHEAD(3)
		"->" CallExpression()/*@bgen(jjtree) #CallAccessExpression( 2) */
                {
                  ASTCallAccessExpression jjtn003 = new ASTCallAccessExpression(JJTCALLACCESSEXPRESSION);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn003,  2);
                  jjtc003 = false;
                }
/*@egen*/
		{ jjtn003.in_wrapper=true; }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003,  2);
                  }
                }
/*@egen*/
	|
		LOOKAHEAD(3)
		t="." Identifier()/*@bgen(jjtree) #AccessExpression( 2) */
        {
          ASTAccessExpression jjtn004 = new ASTAccessExpression(JJTACCESSEXPRESSION);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004,  2);
          jjtc004 = false;
        }
/*@egen*/
        { jjtn004.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  2);
          }
        }
/*@egen*/
	|
		LOOKAHEAD(3)
		t="->" Identifier()/*@bgen(jjtree) #AccessExpression( 2) */
        {
          ASTAccessExpression jjtn005 = new ASTAccessExpression(JJTACCESSEXPRESSION);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn005,  2);
          jjtc005 = false;
        }
/*@egen*/
        { jjtn005.setPos(t.getPos()); jjtn005.in_wrapper=true; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005,  2);
          }
        }
/*@egen*/
	|	LOOKAHEAD(2)
		t="[" ExpressionNT(null) "]"/*@bgen(jjtree) #ArrayElementAccessExpression( 2) */
        {
          ASTArrayElementAccessExpression jjtn006 = new ASTArrayElementAccessExpression(JJTARRAYELEMENTACCESSEXPRESSION);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006,  2);
          jjtc006 = false;
        }
/*@egen*/
        { jjtn006.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006,  2);
          }
        }
/*@egen*/
	|
		LOOKAHEAD("." "new" QName() ( "(" | "<" | "/*<") )
		"."/*@bgen(jjtree) #NewAccessExpression( 2) */
                {
                  ASTNewAccessExpression jjtn007 = new ASTNewAccessExpression(JJTNEWACCESSEXPRESSION);
                  boolean jjtc007 = true;
                  jjtree.openNodeScope(jjtn007);
                }
                try {
/*@egen*/
		NewExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte007) {
                  if (jjtc007) {
                    jjtree.clearNodeScope(jjtn007);
                    jjtc007 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte007 instanceof RuntimeException) {
                    throw (RuntimeException)jjte007;
                  }
                  if (jjte007 instanceof ParseException) {
                    throw (ParseException)jjte007;
                  }
                  throw (Error)jjte007;
                } finally {
                  if (jjtc007) {
                    jjtree.closeNodeScope(jjtn007,  2);
                  }
                }
/*@egen*/
	)*
}

void AnonymouseClosure() :
{/*@bgen(jjtree) AnonymouseClosure */
  ASTAnonymouseClosure jjtn000 = new ASTAnonymouseClosure(JJTANONYMOUSECLOSURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AnonymouseClosure */
        try {
/*@egen*/
	t="fun" "("
	[
		FormalParameter()
		( "," FormalParameter() )*
	]
	")" "->"
    { jjtn000.setPos(t.getPos()); }
    (
		LOOKAHEAD( { getToken(1).kind == RULE } )
		Type() RuleBlock()
	|	Type() Block()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstExpression()       :
{}
{
	(
		BooleanConstExpression()
	|	DecimalConstExpression()
	|	FloatConstExpression()
	|	CharConstExpression()
	|	NullConstExpression()
	|	StringConstExpression()
	)
}

void BooleanConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
		t="true"
	|	t="false"
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DecimalConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
	 	t=<INTEGER_LITERAL>
	|	t=<LONG_INTEGER_LITERAL>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FloatConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	(
		t=<FLOATING_POINT_LITERAL>
	|	t=<DOUBLE_POINT_LITERAL>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CharConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t=<CHARACTER_LITERAL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NullConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t="null"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StringConstExpression()                  :
{/*@bgen(jjtree) ConstExpression */
  ASTConstExpression jjtn000 = new ASTConstExpression(JJTCONSTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t, t1; }
{/*@bgen(jjtree) ConstExpression */
        try {
/*@egen*/
	t=<STRING_LITERAL>
	(
		LOOKAHEAD({
			getToken(1).kind==PLUS
		 && getToken(2).kind==STRING_LITERAL
		})
		"+" t1=<STRING_LITERAL>
		{
			t.image = t.image.substring(0,t.image.length()-1)+t1.image.substring(1);
			t.endLine = t1.endLine;
			t.endColumn = t1.endColumn;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.set(t); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewExpression() :
{/*@bgen(jjtree) NewExpression */
        ASTNewExpression jjtn000 = new ASTNewExpression(JJTNEWEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	boolean old_mode;
}
{/*@bgen(jjtree) NewExpression */
        try {
/*@egen*/
	t="new" { jjtn000.setPos(t.getPos()); }
    NonArrayType() "("
	[	ExpressionNT(null)
		(	"," ExpressionNT(null)	)*
	]
	")"
	[
		LOOKAHEAD("{")
		{ old_mode = interface_only; interface_only = false; jjtn000.anonymouse = true; }
		try {
			TypeBodyDeclaration()
		} finally {
		{ interface_only = old_mode; }
		}
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewArrayExpression() :
{/*@bgen(jjtree) NewArrayExpression */
  ASTNewArrayExpression jjtn000 = new ASTNewArrayExpression(JJTNEWARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int dim=0; }
{/*@bgen(jjtree) NewArrayExpression */
        try {
/*@egen*/
	t="new" NonArrayType()
	( LOOKAHEAD(2) "[" ExpressionNT(null) "]" { dim++; } )+
	( LOOKAHEAD(2) "[" "]" { dim++; } )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { jjtn000.dim = dim; jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NewInitializedArrayExpression() :
{/*@bgen(jjtree) NewInitializedArrayExpression */
  ASTNewInitializedArrayExpression jjtn000 = new ASTNewInitializedArrayExpression(JJTNEWINITIALIZEDARRAYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; int dim=0; }
{/*@bgen(jjtree) NewInitializedArrayExpression */
        try {
/*@egen*/
	t="new" NonArrayType()
	( "[" "]" { dim++; } )+
	"{"
	[
		VariableInitializer()
		(	LOOKAHEAD(2)
			","
			VariableInitializer()
		)*
		[ "," ]
	]
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { jjtn000.dim = dim; jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/*
 * Statement syntax follows.
 */

void Statement()       :
{}
{
	try {
	(
	  LOOKAHEAD(2)
	  LabeledStatement()
	| Block()
	| EmptyStatement()
	| StatementExpression()
	| SwitchStatement()
	| IfStatement()
	| WhileStatement()
	| DoStatement()
	| ForStatement()
	| ForEachStatement()
	| BreakStatement()
	| ContinueStatement()
	| ReturnStatement()
	| ThrowStatement()
	| SynchronizedStatement()
	| TryStatement()
	| GotoStatement()
	| ReparseStatement()
	)
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }
}

void ReparseStatement() :
{/*@bgen(jjtree) ReparseStatement */
  ASTReparseStatement jjtn000 = new ASTReparseStatement(JJTREPARSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReparseStatement */
        try {
/*@egen*/
	try {
		t=<REPARSE_STATEMENT> { jjtn000.set(t); }
	}
	catch(ParseError e) { rpe("Bad statement",e); }
	catch(Throwable e) { rperr(e); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LabeledStatement() :
{/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
	LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(2).kind == COLON } )
	Identifier() ":" Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


ASTBlock PrescannedBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=Block()
	{ return bl; }
}

ASTBlock Block() :
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
	"{"
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	( BlockStatement() )*
	} finally { declMode = old_declMode; PassInfo.pop(jjtn000); }
    "}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTBlock PrescannedRuleBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=RuleBlock()
	{ return bl; }
}

ASTBlock RuleBlock() :
{/*@bgen(jjtree) RuleBlock */
  ASTRuleBlock jjtn000 = new ASTRuleBlock(JJTRULEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; }
{/*@bgen(jjtree) RuleBlock */
        try {
/*@egen*/
	"{"
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
		old_declMode = declMode;
		declMode = false;
	}
	try {
		RuleOrExpression()
	}
	catch(ParseError e) { rpe("Bad rule",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		declMode = old_declMode;
		PassInfo.pop(jjtn000);
	}
	"}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTBlock PrescannedCondBlock(PrescannedBody b)       :
{
	Token t;
	// Skip to the start of prescanned body
	Token tk;
	for(;;) {
		tk = getToken(1);
		if( tk.beginLine==b.lineno && tk.beginColumn==b.columnno )
			break;
		if( tk.kind == EOF ) {
			throw new CompilerException(
				(b.lineno <<11) | (b.columnno & 0x3FF),
				"Expected to find start of block after scanning. Have you changed the file?"
			);
		}
		getNextToken();
	}
	ASTBlock bl;
}
{
	bl=CondBlock()
	{ return bl; }
}

ASTBlock CondBlock() :
{/*@bgen(jjtree) CondBlock */
  ASTCondBlock jjtn000 = new ASTCondBlock(JJTCONDBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ boolean old_declMode; boolean rbrace_req = false; }
{/*@bgen(jjtree) CondBlock */
        try {
/*@egen*/
	[ "{" { rbrace_req=true; } ]
	{
		jjtn000.setPos(getToken(1).getPos());
		PassInfo.push(jjtn000);
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	( CondStatement() )+
	} finally {
		declMode = old_declMode;
		PassInfo.pop(jjtn000);
	}
	(
		LOOKAHEAD(0,{rbrace_req})
		"}" [ <END_CONSTRAINT> ]
	|	<END_CONSTRAINT>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BlockStatement()       :
{ boolean old_declMode; }
{
	(
		LOOKAHEAD( ( Modifier() )* Type() QName() ("[" "]")* ("=" | ":=" | "," | ";") )
		VarDecls() //#DeclStatement
	|	LOOKAHEAD( ( Modifier() )* ("class" | "interface") )
		{ old_declMode = declMode; declMode = false; }
		try {
			TypeDeclaration()
		} finally {
			declMode = old_declMode;
		}
	|
		Statement()
	)
}

void CondStatement() :
{/*@bgen(jjtree) CondStatement */
  ASTCondStatement jjtn000 = new ASTCondStatement(JJTCONDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = getToken(1); }
{/*@bgen(jjtree) CondStatement */
        try {
/*@egen*/
	ExpressionNT(noColonTokenSet)
	[
		":"
		{ t = null; }
		Expression()
	]
	{
		if( t != null ) {
			int pos = t.pos;
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ASTConstExpression e = new ASTConstExpression(0);
			e.pos = pos;
			e.val = KString.from(sb.toString());
			jjtn000.jjtAddChild(e,1);
		}
	}
	";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EmptyStatement() :
{/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) EmptyStatement */
        try {
/*@egen*/
	t=";"/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementExpression() :
{/*@bgen(jjtree) StatementExpression */
  ASTStatementExpression jjtn000 = new ASTStatementExpression(JJTSTATEMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementExpression */
        try {
/*@egen*/
	ExpressionNT(null) ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SwitchStatement() :
{/*@bgen(jjtree) SwitchStatement */
  ASTSwitchStatement jjtn000 = new ASTSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SwitchStatement */
        try {
/*@egen*/
	t="switch" { jjtn000.setPos(t.getPos()); }
	"(" ExpressionNT(null) ")"
	"{"
	(	CaseStatements()	)+
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseStatements()       :
{}
{
	(
		LOOKAHEAD("case" QName() "(" )
		PizzaCase()
	|
		NormalCase()
	)
}

void NormalCase() :
{/*@bgen(jjtree) NormalCase */
  ASTNormalCase jjtn000 = new ASTNormalCase(JJTNORMALCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NormalCase */
        try {
/*@egen*/
	(
		t="case" ExpressionNT(noColonTokenSet) ":"
	|	t="default" ":"
	)
    { jjtn000.setPos(t.getPos()); }
	(
		BlockStatement()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PizzaCase() :
{/*@bgen(jjtree) PizzaCase */
  ASTPizzaCase jjtn000 = new ASTPizzaCase(JJTPIZZACASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PizzaCase */
        try {
/*@egen*/
	t="case" { jjtn000.setPos(t.getPos()); }
    QName()
	"("
		[	FormalParameter()
			( "," FormalParameter() )*
		]
	")" ":"
	(
		BlockStatement()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IfStatement() :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/
	t="if" { jjtn000.setPos(t.getPos()); }
    "(" ExpressionNT(null) ")"
	Statement()
	[	LOOKAHEAD(1)
		"else"
		Statement()
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/
	t="while" { jjtn000.setPos(t.getPos()); }
    "(" ExpressionNT(null) ")" Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DoStatement() :
{/*@bgen(jjtree) DoStatement */
  ASTDoStatement jjtn000 = new ASTDoStatement(JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DoStatement */
        try {
/*@egen*/
	t="do" { jjtn000.setPos(t.getPos()); }
    Statement() "while" "(" ExpressionNT(null) ")" ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForStatement() :
{/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ForStatement */
        try {
/*@egen*/
	t="for" { jjtn000.setPos(t.getPos()); }
	"("
		ForInit() { jjtn000.init = jjtree.popNode(); }
	/*";"*/
	[
		ExpressionNT(null) { jjtn000.cond = (Expr)jjtree.popNode(); }
	]
	";"
	[
		CommaExpression() { jjtn000.iter = (Expr)jjtree.popNode(); }
	]
	")"
	Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForEachStatement() :
{/*@bgen(jjtree) ForEachStatement */
  ASTForEachStatement jjtn000 = new ASTForEachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ForEachStatement */
        try {
/*@egen*/
	t="foreach" { jjtn000.setPos(t.getPos()); }
	"("
	[	LOOKAHEAD( FormalParameter() )
		FormalParameter()
		";"
	]
	ExpressionNT(null)
	[
	";"
	[ ExpressionNT(null) ]
	]
	")"
	Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForInit()      :
{}
{
	(
	LOOKAHEAD( ( Modifier() )* Type() QName() ("[" "]")* ("=" | ":=" | "," | ";") )
	VarDecls()
|	CommaExpression() ";"
|	EmptyStatement()
 	)
}

void GotoStatement() :
{/*@bgen(jjtree) GotoStatement */
  ASTGotoStatement jjtn000 = new ASTGotoStatement(JJTGOTOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) GotoStatement */
        try {
/*@egen*/
	t="goto" { jjtn000.setPos(t.getPos()); }
	(
		"case" ExpressionNT(null) { jjtn000.casemode = true; }
	|
		"default" { jjtn000.casemode = true; }
	|
    	Identifier()
    )
    ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BreakStatement() :
{/*@bgen(jjtree) BreakStatement */
  ASTBreakStatement jjtn000 = new ASTBreakStatement(JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BreakStatement */
        try {
/*@egen*/
	t="break" { jjtn000.setPos(t.getPos()); }
    [ Identifier() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ContinueStatement() :
{/*@bgen(jjtree) ContinueStatement */
  ASTContinueStatement jjtn000 = new ASTContinueStatement(JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ContinueStatement */
        try {
/*@egen*/
	t="continue" { jjtn000.setPos(t.getPos()); }
    [ Identifier() ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReturnStatement() :
{/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReturnStatement */
        try {
/*@egen*/
	t="return" { jjtn000.setPos(t.getPos()); }
    [ ExpressionNT(null) ] ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ThrowStatement() :
{/*@bgen(jjtree) ThrowStatement */
  ASTThrowStatement jjtn000 = new ASTThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ThrowStatement */
        try {
/*@egen*/
	t="throw" { jjtn000.setPos(t.getPos()); }
    ExpressionNT(null) ";"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SynchronizedStatement() :
{/*@bgen(jjtree) SynchronizedStatement */
  ASTSynchronizedStatement jjtn000 = new ASTSynchronizedStatement(JJTSYNCHRONIZEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SynchronizedStatement */
        try {
/*@egen*/
	t="synchronized" { jjtn000.setPos(t.getPos()); }
  "(" ExpressionNT(null) ")" Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TryStatement() :
{/*@bgen(jjtree) TryStatement */
  ASTTryStatement jjtn000 = new ASTTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) TryStatement */
        try {
/*@egen*/
	t="try" { jjtn000.setPos(t.getPos()); }
    Block()
	(	t="catch" "(" FormalParameter() ")" Block()/*@bgen(jjtree) #CatchInfo( 2) */
        {
          ASTCatchInfo jjtn001 = new ASTCatchInfo(JJTCATCHINFO);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
        }
/*@egen*/
    	{ jjtn001.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
	)*
	[	t="finally" Block()/*@bgen(jjtree) #FinallyInfo( 1) */
        {
          ASTFinallyInfo jjtn002 = new ASTFinallyInfo(JJTFINALLYINFO);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002,  1);
          jjtc002 = false;
        }
/*@egen*/
    	{ jjtn002.setPos(t.getPos()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  1);
          }
        }
/*@egen*/
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

