/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.parser;

import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 *
 */

/**
 * Base class to represent unresolved, temporary created expressions.
 */
@ThisIsANode(lang=void)
public abstract class UnresExpr extends ENode {

	public UnresExpr() {}

	public int getPriority(Env env) {
		return 255;
	}

	public void callbackChanged(NodeChangeInfo info) {
		if (info.tree_change) {
			throw new Error("Internal error: "+this.getClass()+" attached/detached to "+info.parent+" to slot "+info.slot.name);
		}
		super.callbackChanged(info);
	}

	static void processArguments(ENode ret, COpArgument[] args, ANode[] exprs) {
		assert (args.length == exprs.length);
		for (int i=0; i < args.length; i++) {
			COpArgument arg = args[i];
			if (arg instanceof COpArgLIST) {
				ASTNode[] stats = ((BlockRewr)exprs[i]).stats.delToArray();
				SpacePtr sptr = Env.getSpacePtr(ret,arg.attr_name);
				foreach (ASTNode st; stats)
					sptr.add(st);
			}
			else if (arg instanceof COpArgEXPR) {
				Env.getScalarPtr(ret,arg.attr_name).set(exprs[i]);
			}
			else if (arg instanceof COpArgTYPE) {
				Env.getScalarPtr(ret,arg.attr_name).set((TypeRef)exprs[i]);
			}
			else if (arg instanceof COpArgIDNT) {
				if (arg.attr_name == null)
					ret.ident = ((ASTToken)exprs[i]).getTokenText();
				else
					Env.getScalarPtr(ret,arg.attr_name).set(((ASTToken)exprs[i]).getTokenText());
			}
			else if (arg instanceof COpArgOPER) {
				if (arg.attr_name != null) {
					if (arg.clazz != null) {
						ANode e;
						if (exprs[i] instanceof ASTToken)
							e = (ANode)arg.clazz.newInstance();
						else
							e = exprs[i];
						foreach (AttrSlot slot; ret.values(); slot.name == arg.attr_name) {
							if (slot instanceof ScalarAttrSlot)
								ret.setVal(slot, e);
							else
								ret.addVal(slot, e);
							break;
						}
					} else {
						ScalarPtr pattr = Env.getScalarPtr(ret,arg.attr_name);
						Class clazz = pattr.slot.typeinfo.clazz;
						if (clazz == Boolean.TYPE || clazz == Boolean.class)
							pattr.set(Boolean.valueOf(arg.text));
						else
							pattr.set(arg.text);
					}
				}
			}
			else if (arg instanceof COpArgNODE) {
				Env.getScalarPtr(ret,arg.attr_name).set(exprs[i]);
			}
		}
	}

}

/**
 * Represents unresolved, temporary created prefix/postfix/infix expression.
 *
 * 'expr' field is @nodeData to not change the owner of the expression.
 * The owner will be changed when concrete, resolved unary expression is created.
 */
@ThisIsANode(lang=void)
public final class UnresOpExpr extends UnresExpr {

	@nodeData public COpdef				opd;
	@nodeData public ANode∅				exprs;

	public UnresOpExpr() {}

	public UnresOpExpr(long pos, COpdef opd, ANode[] exprs) {
		this.pos = pos;
		this.opd = opd;
		this.exprs.addAll(exprs);
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		foreach (ANode e; exprs)
			sb.append(e).append(' ');
		return sb.toString();
	}

	public int getPriority(Env env) {
		if (isPrimaryExpr() || opd == null)
			return 255;
		return opd.prior;
	}

	public ENode closeBuild() {
		ENode ret;
		ANode[] exprs = (ANode[])this.exprs.clone();
		for (int i=0; i < exprs.length; i++) {
			ANode e = exprs[i];
			if (e instanceof ENode)
				e = e.closeBuild();
			exprs[i] = e.detach();
		}
		if (opd.as_node != null) {
			Class clazz = Class.forName(opd.as_node);
			ret = (ENode)clazz.newInstance();
			ret.pos = this.pos;
			ret.symbol = opd.source.symbol;
			UnresExpr.processArguments(ret, opd.args, exprs);
			if (isAutoGenerated())
				ret.setAutoGenerated(true);
			return ret.closeBuild();
		}
		else if (exprs.length == 2 && (exprs[0] instanceof ENode && exprs[1] instanceof ASTToken) || (exprs[0] instanceof ASTToken && exprs[1] instanceof ENode)) {
			ret = new UnaryExpr();
			ret.pos = this.pos;
			ret.symbol = opd.source.symbol;
			if (exprs[1] instanceof ASTToken)
				ret.expr = (ENode)exprs[0];
			else
				ret.expr = (ENode)exprs[1];
		}
		else if (exprs.length == 3 && exprs[0] instanceof ENode && exprs[1] instanceof ASTToken && exprs[2] instanceof ENode) {
			ret = new BinaryExpr();
			ret.pos = this.pos;
			ret.symbol = opd.source.symbol;
			ret.expr1 = (ENode)exprs[0];
			ret.expr2 = (ENode)exprs[2];
		}
		else
			throw new CompilerException(this,"Cannot build expression "+this);
		if (isAutoGenerated())
			ret.setAutoGenerated(true);
		return ret;
	}
}

/**
 * Represents unresolved, temporary created expression in parenthethis ( Z ).
 */
@ThisIsANode(lang=void)
public final class UnresParenthExpr extends UnresExpr {

	@nodeData public ENode expr;

	public ENode closeBuild() {
		ENode ret = expr.closeBuild().detach();
		ret.setPrimaryExpr(true);
		if (isAutoGenerated())
			ret.setAutoGenerated(true);
		return ret;
	}
}

/**
 * Represents unresolved, temporary created reinterpret (cast) expression.
 */
@ThisIsANode(lang=void)
public final class UnresReinterpExpr extends UnresExpr {

	@nodeData public TypeRef tr;
	@nodeData public ENode expr;

	public UnresReinterpExpr(long pos, TypeRef tr, ENode expr) {
		this.pos = pos;
		this.tr = tr;
		this.expr = expr;
	}

	public int getPriority(Env env) { return opCastPriority; }

	public ENode closeBuild() {
		ReinterpExpr ret = new ReinterpExpr(pos, tr.detach(), expr.closeBuild().detach());
		if (isAutoGenerated())
			ret.setAutoGenerated(true);
		return ret;
	}
}

/**
 * Represents unresolved, temporary created list of expression.
 */
@ThisIsANode(lang=void)
public final class UnresSeqs extends UnresExpr {

	@nodeData public COpArgument		seq;
	@nodeData public ANode∅				exprs;

	public UnresSeqs() {}

	public UnresSeqs(COpArgument seq, ANode[] exprs) {
		this.seq = seq;
		this.exprs.addAll(exprs);
	}

	public String toString() {
		COpArgument seq = this.seq;
		StringBuffer sb = new StringBuffer();
		boolean add_sep = false;
		foreach (ENode e; exprs) {
			if (add_sep) {
				if (seq instanceof COpArgLIST && seq.sep != null)
					sb.append(' ').append(seq.sep.text).append(' ');
				else
					sb.append(' ');
			}
			sb.append(e);
			add_sep = true;
		}
		return sb.toString();
	}

	public ENode closeBuild() {
		COpArgument seq = this.seq;
		BlockRewr bl = new BlockRewr();
		if (seq instanceof COpArgSEQS) {
			for (int i=0; i < seq.args.length; i++) {
				COpArgument arg = seq.args[i];
				ANode e = exprs[i];
				if (e instanceof ENode)
					e = e.closeBuild();
				if !(e instanceof ASTNode)
					continue;
				if (arg instanceof COpArgEXPR) {
					bl.stats.append((ASTNode)e.detach());
				}
				else if (arg instanceof COpArgTYPE) {
					bl.stats.append((ASTNode)e.detach());
				}
				else if (arg instanceof COpArgNODE) {
					bl.stats.append((ASTNode)e.detach());
				}
			}
		} else {
			for (int i=0; i < exprs.length; i++) {
				ANode e = exprs[i];
				if (e instanceof ENode)
					e = e.closeBuild();
				if !(e instanceof ASTNode)
					continue;
				bl.stats.append(((ASTNode)e).detach());
			}
		}
		return bl;
	}
}

/**
 * Represents unresolved, temporary created call expression.
 *
 * 'exprs' field is @nodeData to not change the owner of the expressions.
 * The owner will be changed when concrete, resolved multi-expression is created.
 */
@ThisIsANode(lang=void)
public final class UnresCallExpr extends UnresExpr {

	@nodeData public ENode			obj;
	@nodeData public Symbol			func;
	@nodeData public TypeRef∅		targs;
	@nodeData public ENode∅			args;

	public UnresCallExpr() {}

	public UnresCallExpr(long pos, ENode obj, Symbol func, TypeRef[] targs, ENode[] args, boolean super_flag) {
		this.pos = pos;
		this.obj = obj;
		this.func = func;
		this.targs.addAll(targs);
		this.args.addAll(args);
		//this.setSuperExpr(super_flag);
	}

	public int getPriority(Env env) { return opCastPriority; }

	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(obj).append('.').append(func);
		sb.append('(');
		for (int i=0; i < args.length; i++) {
			sb.append(args[i]);
			if (i < args.length)
				sb.append(',');
		}
		sb.append(')');
		return sb.toString();
	}

	public ENode closeBuild() {
		ENode obj = this.obj.closeBuild().detach();
		for (int i=0; i < targs.length; i++)
			targs[i].detach();
		for (int i=0; i < args.length; i++)
			args[i] = args[i].closeBuild().detach();
		if (obj instanceof TypeRef) {
			if (func.dnode instanceof Method) {
				CallExpr ce = new CallExpr(pos, obj, func, targs, args);
				ce.setCastCall(this.isCastCall());
				return ce;
			} else {
				Field f = (Field)func.dnode;
				return new ClosureCallExpr(pos, new SFldExpr(pos, f), args);
			}
		} else {
			if (func.dnode instanceof Method) {
				CallExpr ce = new CallExpr(pos, obj, func, targs, args);
				//if (isSuperExpr())
				//	ce.setSuperExpr(true);
				ce.setCastCall(this.isCastCall());
				return ce;
			} else {
				return new ClosureCallExpr(pos, obj, args);
			}
		}
	}
}


/**
 * Represents unresolved, temporary created access expression.
 */
@ThisIsANode(lang=void)
public final class AccFldExpr extends UnresExpr {

	@nodeData public ENode				obj;
	@nodeData public Field				fld;

	public AccFldExpr() {}

	public AccFldExpr(long pos, ENode obj, Field fld) {
		this.pos = pos;
		this.obj = obj;
		this.fld = fld;
		assert (obj != null || fld.isStatic());
	}

	public int getPriority(Env env) { return opAccessPriority; }

	public String toString() {
		if (fld.isStatic())
			return fld.parent()+ "."+fld.sname;
		else
			return obj+ "."+fld.sname;
	}

	public ENode closeBuild() {
		ENode ret;
		if (fld.isStatic()) {
			if (obj instanceof TypeRef)
				ret = new SFldExpr(pos,(TypeRef)obj.detach(),fld);
			else
				ret = new SFldExpr(pos,null,fld);
		} else {
			ret = new IFldExpr(pos,obj.closeBuild().detach(),fld);
		}
		if (isAutoGenerated())
			ret.setAutoGenerated(true);
		return ret;
	}
}


/**
 * Base class to represent unresolved, temporary created type reference.
 */
/**
 * Base class to represent unresolved, temporary created type reference.
 */
@ThisIsANode(lang=void)
public class UnresTypeRef extends TypeRef {

	public UnresTypeRef() {}

	public int getPriority(Env env) {
		return 255;
	}

	public void callbackChanged(NodeChangeInfo info) {
		if (info.tree_change) {
			throw new Error("Internal error: "+this.getClass()+" attached/detached to "+info.parent+" to slot "+info.slot.name);
		}
		super.callbackChanged(info);
	}
}

@ThisIsANode(lang=void)
public class UnresOpTypeRef extends UnresTypeRef {

	@nodeData public COpdef				opd;
	@nodeData public ANode∅				exprs;

	public UnresOpTypeRef() {}

	public UnresOpTypeRef(long pos, COpdef opd, ANode[] exprs) {
		this.pos = pos;
		this.opd = opd;
		this.exprs.addAll(exprs);
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		foreach (ANode e; exprs)
			sb.append(e).append(' ');
		return sb.toString();
	}

	public int getPriority(Env env) {
		if (isPrimaryExpr() || opd == null)
			return 255;
		return opd.prior;
	}

	public TypeRef closeBuild() {
		TypeRef ret;
		ANode[] exprs = (ANode[])this.exprs.clone();
		for (int i=0; i < exprs.length; i++) {
			ANode e = exprs[i];
			if (e instanceof ENode)
				e = e.closeBuild();
			exprs[i] = e.detach();
		}
		if (opd.as_node != null) {
			Class clazz = Class.forName(opd.as_node);
			ret = (TypeRef)clazz.newInstance();
			ret.pos = this.pos;
			ret.symbol = opd.source.symbol;
			UnresExpr.processArguments(ret, opd.args, exprs);
			ret = ret.closeBuild();
		}
		else if (exprs.length == 2 && exprs[0] instanceof TypeRef && exprs[1] instanceof ASTToken) {
			ret = new TypeExpr();
			ret.arg = (TypeRef)exprs[0];
			ret.op_name = opd.source.symbol.sname;
			ret.pos = pos;
		}
		else
			throw new CompilerException(this,"Cannot build expression "+this);
		if (isAutoGenerated())
			ret.setAutoGenerated(true);
		return ret;
	}
}

@ThisIsANode(lang=void)
public class UnresTypeWithArgs extends UnresTypeRef {

	@nodeData public TypeRef		base;
	@nodeData public TypeRef∅		args;

	public UnresTypeWithArgs() {}

	public UnresTypeWithArgs(long pos, TypeRef base, TypeRef[] args) {
		this.pos = pos;
		this.base = base;
		this.args.addAll(args);
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(base);
		sb.append('<');
		foreach (TypeRef tr; args)
			sb.append(tr).append(",");
		sb.append('<');
		return sb.toString();
	}

	public TypeRef closeBuild() {
		TypeRef base = this.base.closeBuild().detach();
		TypeRef[] args = (TypeRef[])this.args.clone();
		for (int i=0; i < args.length; i++)
			args[i] = args[i].closeBuild().detach();
		if (base instanceof TypeInnerNameRef) {
			base.args.addAll(args);
			return base;
		}
		else if (base instanceof TypeNameRef) {
			TypeRef ret = new TypeNameArgsRef(base.pos,base.ident,base.getTypeDecl(Env.getEnv()));
			ret.args.addAll(args);
			return ret;
		}
		throw new CompilerException("Cannot add type arguments to type "+base);
	}
}

@ThisIsANode(lang=void)
public class UnresTypeAccessExpr extends UnresTypeRef {

	@nodeData public TypeRef		base;

	public UnresTypeAccessExpr() {}

	public UnresTypeAccessExpr(long pos, TypeRef base, String ident) {
		this.pos = pos;
		this.base = base;
		this.ident = ident;
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(base);
		sb.append('.');
		sb.append(ident);
		return sb.toString();
	}

	public TypeRef closeBuild() {
		TypeRef ret = this.base.closeBuild().detach();
		//if (ret instanceof TypeNameRef)
		//	ret = new TypeNameRef(ret.ident+"·"+ident);
		//else
			ret = new TypeInnerNameRef(ret,ident);
		ret.pos = this.pos;
		return ret;
	}
}


