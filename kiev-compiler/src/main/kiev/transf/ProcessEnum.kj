/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.transf;

import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 *
 */

public final class EnumPlugin implements PluginFactory {
	public PluginDescr getPluginDescr(String name) {
		PluginDescr pd = null;
		if (name.equals("enum")) {
			pd = new PluginDescr("enum").depends("kiev");
			pd.proc(new ProcessorDescr("gen-members", "fe", 0, EnumFE_GenMembers.class).after("kiev:fe:pass3").before("kiev:fe:pre-resolve"));
		}
		return pd;
	}
}

public final class EnumFE_GenMembers extends TransfProcessor {
	public EnumFE_GenMembers(Env env, int id) { super(env,id,KievExt.Enum); }
	public String getDescr() { "Enum members generation" }

	public void process(ASTNode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"EnumFE_GenMembers");
			try {
				doProcess(node);
			} finally { tr.leave(); }
		}
	}
	
	public void doProcess(ASTNode:ASTNode node) {
		return;
	}
	
	public void doProcess(SyntaxScope:ASTNode ss) {
		foreach (ASTNode dn; ss.members)
			this.doProcess(dn);
	}
	
	public void doProcess(Struct:ASTNode clazz) {
		if !( clazz.isEnum() ) {
			foreach (Struct dn; clazz.members)
				this.doProcess(dn);
			return;
		}
		
		if (clazz.isInterfaceOnly() || clazz.resolveField(env, nameEnumValuesFld, false) != null)
			return;
		
		StdTypes tenv = this.env.getTypeEnv();
		
		Field[] eflds = ((JavaEnum)clazz).getEnumFields();
		int pos = clazz.pos;
		
		{
			if (!clazz.instanceOf(tenv.tpEnum.tdecl))
				clazz.super_types.insert(0, new TypeRef(tenv.tpEnum));
			Field vals = clazz.addField(new Field(nameEnumValuesFld,
				new ArrayType(clazz.getType(env)), ACC_SYNTHETIC|ACC_PRIVATE|ACC_STATIC|ACC_FINAL));
			vals.init = new NewInitializedArrayExpr(pos, new TypeExpr(clazz.getType(env),Operator.PostTypeArray,new ArrayType(clazz.getType(env))), ENode.emptyArray);
			for(int i=0; i < eflds.length; i++) {
				ENode e = new SFldExpr(eflds[i].pos,eflds[i]);
				((NewInitializedArrayExpr)vals.init).args.append(e);
			}
		}
		
		foreach (Field f; eflds; f.init == null) {
			f.init = new NewEnumExpr();
			f.init.setAutoGenerated(true);
		}
		eflds = ((JavaEnum)clazz).getEnumFields();

		// Generate enum's methods
		
		// values()[]
		{
			Method mvals = new MethodImpl(nameEnumValues,new ArrayType(clazz.getType(env)),ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC);
			mvals.pos = pos;
			mvals.body = new Block(pos);
			mvals.block.stats.add(
				new ReturnStat(pos,
					new SFldExpr(pos,clazz.resolveField(env,nameEnumValuesFld)) ) );
			foreach (Method m; clazz.members; m.sname == mvals.sname) {
				m.replaceWithNode(mvals,clazz,Struct.nodeattr$members);
				break;
			}
			if (!mvals.isAttached())
				clazz.addMethod(mvals);
		}
		
		// Cast from int
		{
			Method tome = new MethodImpl("fromInt",clazz.getType(env),ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC);
			tome.aliases += new OperatorAlias(nameCastOp, tome);
			tome.pos = pos;
			tome.params.append(new LVar(pos,nameEnumOrdinal,tenv.tpInt, Var.VAR_LOCAL,0));
			tome.body = new Block(pos);
			SwitchStat sw = new SwitchStat(pos,new LVarExpr(pos,tome.params[0]));
			//EnumAttr ea = (EnumAttr)clazz.getAttr(attrEnum);
			//if( ea == null )
			//	throw new RuntimeException("enum structure "+clazz+" without "+attrEnum+" attribute");
			for(int i=0; i < eflds.length; i++) {
				sw.stats.add(new CaseLabel(pos, new ConstIntExpr(i)));
				sw.stats.add(new ReturnStat(pos,new SFldExpr(pos,eflds[i])));
			}
			sw.stats.add(new CaseLabel(pos,null));
			sw.stats.add(new ThrowStat(pos,new NewExpr(pos,tenv.tpCastException,ENode.emptyArray)));
			tome.block.stats.add(sw);
			foreach (Method m; clazz.members; m.sname == tome.sname) {
				m.replaceWithNode(tome,clazz,Struct.nodeattr$members);
				break;
			}
			if (!tome.isAttached())
				clazz.addMethod(tome);
		}

		// toString
		{
			Method tostr = new MethodImpl("toString",tenv.tpString,ACC_PUBLIC | ACC_SYNTHETIC);
			tostr.aliases += new OperatorAlias(nameCastOp, tostr);
			tostr.pos = pos;
			tostr.body = new Block(pos);
			SwitchStat sw = new SwitchStat(pos,
				new CallExpr(pos,	new ThisExpr(),
					tenv.tpEnum.tdecl.resolveMethod(env, nameEnumOrdinal, tenv.tpInt),
					ENode.emptyArray));
			for(int i=0; i < eflds.length; i++) {
				Field f = eflds[i];
				ConstStringExpr alt_id = f.alt_enum_id;
				String str = (alt_id != null) ? alt_id.value : f.sname;
				sw.stats.add(new CaseLabel(pos,new ConstIntExpr(i)));
				sw.stats.add(new ReturnStat(pos,new ConstStringExpr(str)));
			}
			sw.stats.add(new CaseLabel(pos,null));
			sw.stats.add(new ThrowStat(pos,new NewExpr(pos,tenv.tpRuntimeException,ENode.emptyArray)));
			tostr.block.stats.add(sw);
			foreach (Method m; clazz.members; m.sname == tostr.sname) {
				m.replaceWithNode(tostr,clazz,Struct.nodeattr$members);
				break;
			}
			if (!tostr.isAttached())
				clazz.addMethod(tostr);
		}

		// fromString
		{
			Method fromstr = new MethodImpl("valueOf",clazz.getType(env),ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC);
			fromstr.aliases += new OperatorAlias(nameCastOp, fromstr);
			fromstr.aliases += new Alias("fromString", fromstr);
			fromstr.pos = pos;
			fromstr.params.add(new LVar(pos,"val",tenv.tpString, Var.VAR_LOCAL,0));
			fromstr.body = new Block(pos);
			AssignExpr ae = new AssignExpr(pos,
				new LVarExpr(pos,fromstr.params[0]),
				new CallExpr(pos,
					new LVarExpr(pos,fromstr.params[0]),
					tenv.tpString.tdecl.resolveMethod(env,"intern",tenv.tpString),
					ENode.emptyArray
				));
			fromstr.block.stats.add(new ExprStat(pos,ae));
			for(int i=0; i < eflds.length; i++) {
				Field f = eflds[i];
				String str = f.sname;
				IfElseStat ifst = new IfElseStat(pos,
					new BinaryBoolExpr(pos,env.coreFuncs.fObjectBoolEQ,
						new LVarExpr(pos,fromstr.params[0]),
						new ConstStringExpr(str)),
					new ReturnStat(pos,new SFldExpr(pos,f)),
					null
					);
				fromstr.block.stats.add(ifst);
				ConstStringExpr alt_id = f.alt_enum_id;
				if (alt_id != null) {
					str = alt_id.value;
					if (str != f.sname) {
						ifst = new IfElseStat(pos,
							new BinaryBoolExpr(pos,env.coreFuncs.fObjectBoolEQ,
								new LVarExpr(pos,fromstr.params[0]),
								new ConstStringExpr(str)),
								new ReturnStat(pos,new SFldExpr(pos,f)),
								null
								);
						fromstr.block.stats.add(ifst);
					}
				}
			}
			fromstr.block.stats.add(
				new ThrowStat(pos,new NewExpr(pos,tenv.tpRuntimeException,ENode.emptyArray))
				);
			foreach (Method m; clazz.members; m.sname == fromstr.sname) {
				m.replaceWithNode(fromstr,clazz,Struct.nodeattr$members);
				break;
			}
			if (!fromstr.isAttached())
				clazz.addMethod(fromstr);
		}
	}

}
