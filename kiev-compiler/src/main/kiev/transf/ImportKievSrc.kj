/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.transf;
import syntax kiev.Syntax;

import kiev.ir.java15.RNode;

import kiev.dump.DumpFactory;
import kiev.dump.XMLDumpFilter;
import kiev.dump.BinDumpFilter;
import kiev.fmt.common.TextPrinter;
import kiev.fmt.common.DefaultTextProcessor;

import java.io.*;

/**
 * @author Maxim Kizub
 *
 */

public final class KievPlugin implements PluginFactory {
	public PluginDescr getPluginDescr(String name) {
		PluginDescr pd = null;
		if (name.equals("kiev")) {
			pd = new PluginDescr("kiev");
			pd.proc(new ProcessorDescr("pass1", "fe", 100, KievFE_Pass1.class));
			pd.proc(new ProcessorDescr("pass2", "fe", 0, KievFE_Pass2.class).after("kiev:fe:pass1"));
			pd.proc(new ProcessorDescr("meta-decls", "fe", 0, KievFE_MetaDecls.class).after("kiev:fe:pass2"));
			pd.proc(new ProcessorDescr("meta-defaults", "fe", 0, KievFE_MetaDefaults.class).after("kiev:fe:meta-decls"));
			pd.proc(new ProcessorDescr("meta-values", "fe", 0, KievFE_MetaValues.class).after("kiev:fe:meta-defaults"));
			pd.proc(new ProcessorDescr("pass3", "fe", 0, KievFE_Pass3.class).after("kiev:fe:meta-values"));
			pd.proc(new ProcessorDescr("pre-resolve", "fe", 0, KievFE_PreResolve.class).after("kiev:fe:pass3"));
			pd.proc(new ProcessorDescr("main-resolve", "fe", 0, KievFE_MainResolve.class).after("kiev:fe:pre-resolve"));
			pd.proc(new ProcessorDescr("dump-api", "me", 100, KievME_DumpAPI.class));
			pd.proc(new ProcessorDescr("pre-generate", "me", 100, KievME_PreGenartion.class).after("kiev:me:dump-api"));
			pd.proc(new ProcessorDescr("resolve", "be", 0, KievBE_Resolve.class));
			pd.proc(new ProcessorDescr("generate", "be", -100, KievBE_Generate.class).after("kiev:be:resolve"));
			pd.proc(new ProcessorDescr("cleanup", "be", -200, KievBE_Cleanup.class).after("kiev:be:generate"));
		}
		return pd;
	}
}

/////////////////////////////////////////////////////
//													//
//		   PASS 1 - process file syntax				//
//													//
/////////////////////////////////////////////////////

public final class KievFE_Pass1 extends TransfProcessor {
	public KievFE_Pass1(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Syntax" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_Pass1");
			try {
				processSyntax(node);
			} finally { tr.leave(); }
		}
	}

	public void processSyntax(ANode:ANode node) {
		return;
	}

	public void processSyntax(SyntaxScope:ANode ss) {
		ss.getPackage();
		if (ss instanceof FileUnit && ss.syntaxes.length == 0 && (ss.fname.endsWith(".java")||ss.fname.endsWith(".kj"))) {
			ImportSyntax imp = new ImportSyntax();
			imp.name.qualified = true;
			imp.name.name = "kiev·stdlib·Syntax";
			imp.setAutoGenerated(true);
			ss.syntaxes.insert(0,imp);
		}
		foreach (ImportSyntax n; ss.syntaxes) {
			try {
				processSyntax(n);
			} catch(Exception e ) { Kiev.reportError(n,e); }
		}
		foreach (ASTNode n; ss.members) {
			try {
				processSyntax(n);
			} catch(Exception e ) { Kiev.reportError(n,e); }
		}
	}

	public void processSyntax(ComplexTypeDecl:ANode node) {
		foreach (ASTNode n; node.members) {
			try {
				processSyntax(n);
			} catch(Exception e ) { Kiev.reportError(n,e); }
		}
	}

	public void processSyntax(Import:ANode astn) {
		if (!Env.needResolving(astn.name))
			return;
		if (!astn.name.qualified)
			astn.name.qualified = true;
		String name = astn.name.name.replace('.','·');
		ScopeOfNames scope = (ScopeOfNames)this.env.root;
		DNode n;
		int dot;
		do {
			dot = name.indexOf('·');
			String head;
			if (dot > 0) {
				head = name.substring(0,dot).intern();
				name = name.substring(dot+1).intern();
			} else {
				head = name;
			}
			ResInfo info = new ResInfo(env,astn,head,ResInfo.noForwards|ResInfo.noSuper|ResInfo.noSyntaxContext);
			if!(scope.resolveNameR(info)) {
				Kiev.reportError(astn,"Unresolved identifier "+head+" in "+scope);
				return;
			}
			n = info.resolvedDNode();
			if (n instanceof ScopeOfNames)
				scope = (ScopeOfNames)n;
		} while (dot > 0);
		if (astn instanceof ImportImpl && !(n instanceof TypeDecl || n instanceof KievPackage))
			Kiev.reportError(astn,"Identifier "+name+" is not a type or package");
		else if (astn instanceof ImportStatic && !(astn.star || (n instanceof Field) || (n instanceof Method)))
			Kiev.reportError(astn,"Identifier "+name+" is not a field or method");
		else if (astn instanceof ImportMethod && !(n instanceof ScopeOfMethods))
			Kiev.reportError(astn,"Identifier "+name+" is not a scope of methods");
		else if (astn instanceof ImportOperators && !(n instanceof ComplexTypeDecl))
			Kiev.reportError(astn,"Identifier "+name+" is not a scope of methods with operators");
		else {
			assert (n != null);
			astn.name.symbol = n.symbol;
		}
	}

	public void processSyntax(ImportSyntax:ANode astn) {
		if (!Env.needResolving(astn.name))
			return;
		if (!astn.name.qualified)
			astn.name.qualified = true;
		String name = astn.name.name.replace('.','·');
		ScopeOfNames scope = (ScopeOfNames)this.env.root;
		DNode n;
		int dot;
		do {
			dot = name.indexOf('·');
			String head;
			if (dot > 0) {
				head = name.substring(0,dot).intern();
				name = name.substring(dot+1).intern();
			} else {
				head = name;
			}
			ResInfo info = new ResInfo(env,astn,head,ResInfo.noForwards|ResInfo.noSuper|ResInfo.noSyntaxContext);
			if!(scope.resolveNameR(info)) {
				Kiev.reportError(astn,"Unresolved identifier "+head+" in "+scope);
				return;
			}
			n = info.resolvedDNode();
			if (n instanceof ScopeOfNames)
				scope = (ScopeOfNames)n;
		} while (dot > 0);
		if !(n instanceof KievSyntax)
			Kiev.reportError(astn,"Identifier "+name+" is not a syntax");
		else {
			assert (n != null);
			astn.name.symbol = n.symbol;
		}
	}


	public void processSyntax(Opdef:ANode astn) {
		int prior = astn.prior;
		String decl = astn.sname;
		Operator op = Operator.getOperatorByName(decl);
		if (op != null)
			astn.resolved = op;
		op = astn.makeOperator();
		if( Kiev.verbose ) System.out.println("Declared operator "+op);
		return;
	}

	public void processSyntax(KievSyntax:ANode astn) {
	next_super_syntax:
		foreach(SymbolRef sr; astn.super_syntax; Env.needResolving(sr)) {
			String name = sr.name;
			KievPackage scope = this.env.root;
			int dot = name.indexOf('·');
			while (dot > 0) {
				String head;
				head = name.substring(0,dot).intern();
				name = name.substring(dot+1).intern();
				ResInfo info = new ResInfo(env,astn,head,ResInfo.noForwards|ResInfo.noSuper|ResInfo.noSyntaxContext).match(KievPackage.class);
				if!(scope.resolveNameR(info)) {
					Kiev.reportError(sr,"Unresolved package "+head+" in "+scope);
					continue next_super_syntax;
				}
				scope = (KievPackage)info.resolvedDNode();
				dot = name.indexOf('·');
			}
			ResInfo info = new ResInfo(env,astn,name,ResInfo.noForwards|ResInfo.noSuper|ResInfo.noSyntaxContext).match(KievSyntax.class);
			if!(scope.resolveNameR(info)) {
				Kiev.reportError(sr,"Unresolved syntax "+name+" in "+scope);
				continue next_super_syntax;
			}
			sr.symbol = info.resolvedSymbol();
		}
		foreach (ASTNode n; astn.members) {
			try {
				processSyntax(n);
			} catch(Exception e ) { Kiev.reportError(n,e); }
		}
	}

	public void processSyntax(Struct:ANode astn) {
		Struct me = astn;
		if (me.parent() == null) {
			SyntaxScope ss = Env.ctxSyntaxScope(me);
			KievPackage pkg = null;
			if (ss != null)
				pkg = ss.getPackage();
			if (pkg == null)
				pkg = this.env.root;
			pkg.pkg_members += me;
		}
		if (me.isAnnotation() || me.isEnum()) {
			if( me.args.length > 0 ) {
				Kiev.reportError(me,"Type parameters are not allowed for "+me);
				me.args.delAll();
			}
			me.setTypeUnerasable(false);
		}
		else if !(me.parent() instanceof KievPackage) {
			if (me.isStructInner() && !me.isStatic() && me.isClazz()) {
				ComplexTypeDecl pkg = Env.ctxTDecl(me);
				if (pkg.sname == nameIFaceImpl)
					pkg = Env.ctxTDecl(pkg);
				int n = 0;
				for(ComplexTypeDecl p=pkg; p.isStructInner() && !p.isStatic(); p=Env.ctxTDecl(p)) n++;
				String fldName = (nameThisDollar+n).intern();
				boolean found = false;
				foreach (Field f; me.members; f.sname == fldName)
					found = true;
				if (!found) {
					TypeAssign td = new TypeAssign(new Symbol("outer$"+n+"$type"), new TypeRef(pkg.getType(env)));
					td.setSynthetic(true);
					me.members.append(td);
					me.ometa_tdef = td;
					Field f = new Field(fldName,td.getAType(env),ACC_FORWARD|ACC_FINAL|ACC_SYNTHETIC);
					f.pos = me.pos;
					me.members.append(f);
				}
			}
		}
		if (me.isTypeUnerasable()) {
			foreach (TypeDef a; me.args)
				a.setTypeUnerasable(true);
		}

		foreach (ASTNode n; me.members) {
			try {
				processSyntax(n);
			} catch(Exception e ) { Kiev.reportError(n,e); }
		}
	}
}

/////////////////////////////////////////////////////
//													//
//		   PASS 2 - create types for structures		//
//													//
/////////////////////////////////////////////////////

public final class KievFE_Pass2 extends TransfProcessor {
	public KievFE_Pass2(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Class types" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_Pass2");
			try {
				doProcess(node);
			} finally { tr.leave(); }
		}
	}

	public void doProcess(ANode:ANode node) {
		return;
	}

	public void doProcess(SyntaxScope:ANode astn) {
		foreach (ASTNode n; astn.members) {
			try {
				if (n instanceof TypeDef)
					n.getType(env);
				else if (n instanceof TypeOpDef)
					n.getType(env);
			} catch(Exception e ) {
				Kiev.reportError(n,e);
			}
		}

		foreach (ASTNode n; astn.members)
			doProcess(n);
	}

	public void doProcess(KievSyntax:ANode astn) {
		KievSyntax stx = astn;
		foreach(ImportOperators impo; stx.members) {
			DNode dn = impo.name.dnode;
			if (dn instanceof ComplexTypeDecl) {
				dn = (ComplexTypeDecl)dn.checkResolved(env);
				foreach (Method m; dn.members) {
					foreach(OperatorAlias al; m.aliases) {
						al.pass2(stx);
					}
				}
			}
		}
	}

	public void doProcess(TypeDecl:ANode astn) {
		try {
			TypeDecl tdecl = astn;
			tdecl.verifyMetas();
			if (tdecl.isTypeResolved())
				return;
			tdecl.setTypeResolved(true);
			foreach(TypeRef tr; tdecl.super_types) {
				TypeDecl td = tr.getTypeDecl(env);
				if (td instanceof ComplexTypeDecl)
					getStructType((ComplexTypeDecl)td, new Stack<TypeDecl>());
			}
			tdecl.setArgsResolved(true);
		} catch(Exception e ) { Kiev.reportError(astn,e); }
	}

	public void doProcess(ComplexTypeDecl:ANode astn) {
		try {
			ComplexTypeDecl td = astn;
			// Verify meta-data to the new structure
			td.verifyMetas();
			foreach (DNode dn; td.members)
				dn.verifyMetas();
			getStructType(td, new Stack<TypeDecl>());
			foreach (TypeDecl s; td.members)
				doProcess(s);
		} catch(Exception e ) { Kiev.reportError(astn,e); }
	}

	private Type getStructType(ComplexTypeDecl tdecl, Stack<TypeDecl> path) {
		tdecl = tdecl.checkResolved(env);
		if (tdecl.isTypeResolved())
			return tdecl.getType(env);
		path.push(tdecl);

		tdecl.setTypeResolved(true);

		for (ComplexTypeDecl p = Env.ctxTDecl(tdecl); p != null; p = Env.ctxTDecl(p))
			getStructType(p, path);

		StdTypes tenv = this.env.getTypeEnv();

		if (tdecl instanceof Struct) {
			Struct clazz = (Struct)tdecl;
			if (clazz.isAnnotation()) {
				if (clazz.super_types.length == 0) {
					clazz.super_types.insert(0, new TypeRef(tenv.tpObject));
					clazz.super_types.insert(1, new TypeRef(tenv.tpAnnotation));
				}
			}
			else if (tdecl.isEnum()) {
				if (tdecl.isStructInner())
					clazz.setStatic(true);
				if (clazz.super_types.length == 0) {
					TypeRef tr = new TypeRef(tenv.tpEnum);
					tr.setAutoGenerated(true);
					clazz.super_types.insert(0, tr);
				}
			}
			else if (clazz instanceof PizzaCase) {
				clazz.setStatic(true);
				Struct p = (Struct)Env.ctxTDecl(clazz);
				p.addCase((PizzaCase)clazz);
				getStructType(p, path);
				if (clazz.super_types.length == 0) {
					TypeNameArgsRef sup_ref = new TypeNameArgsRef(p.qname());
					sup_ref.symbol = p.symbol;
				next_case_arg:
					for(int i=0; i < p.args.length; i++) {
						for(int j=0; j < clazz.args.length; j++) {
							if (p.args[i].sname == clazz.args[j].sname) {
								sup_ref.args.add(new TypeRef(clazz.args[j].getAType(env)));
								continue next_case_arg;
							}
						}
						sup_ref.args.add(new TypeRef(tenv.tpNull));
					}
					sup_ref.setAutoGenerated(true);
					clazz.super_types.insert(0, sup_ref);
				}
			}
			else if (clazz.isInterface()) {
				if (clazz.super_types.length == 0) {
					TypeRef tr = new TypeRef(tenv.tpObject);
					tr.setAutoGenerated(true);
					clazz.super_types.insert(0, tr);
				}
				foreach(TypeRef tr; clazz.super_types) {
					Struct s = tr.getType(env).getStruct();
					if (s != null)
						getStructType(s, path);
				}
			}
			else if (clazz.isStructView() || clazz.isClazz() || clazz instanceof MetaTypeDecl) {
				if (clazz.isStructView()) {
					KievView kview = (KievView)clazz;
					if (kview.view_of != null)
						kview.view_of.getType(env);
				}
				foreach(TypeRef tr; clazz.super_types) {
					Struct s = tr.getType(env).getStruct();
					if (s != null)
						getStructType(s, path);
				}
				if (clazz.super_types.length == 0) {
					if (clazz != tenv.tpObject.tdecl) {
						TypeRef tr = new TypeRef(tenv.tpObject);
						tr.setAutoGenerated(true);
						clazz.super_types.insert(0, tr);
					}
				}
				//else if (clazz.super_types[0].getStruct().isInterface()) {
				//	TypeRef tr = new TypeRef(tenv.tpObject);
				//	tr.setAutoGenerated(true);
				//	clazz.super_types.insert(0, tr);
				//}
			}
		}
		else {
			foreach(TypeRef tr; tdecl.super_types) {
				Struct s = tr.getType(env).getStruct();
				if (s != null)
					getStructType(s, path);
			}
		}

		env.tenv.callbackTypeVersionChanged(tdecl);
		if (tdecl instanceof Struct) {
			Struct clazz = (Struct)tdecl;
			clazz.getType(env).bindings(); // update the type
			if (clazz.getType(env).isUnerasable()) {
				Struct clazz = (Struct)tdecl;
				if (!clazz.isTypeUnerasable()) {
					Kiev.reportWarning(clazz,"Type "+clazz+" must be annotated as @unerasable");
					clazz.setTypeUnerasable(true);
					foreach (TypeDef a; clazz.args)
						a.setTypeUnerasable(true);
				}
				if (!clazz.instanceOf(tenv.tpTypeInfoInterface.tdecl))
					clazz.super_types.append(new TypeRef(tenv.tpTypeInfoInterface));
			}
		}

		tdecl.setArgsResolved(true);
		path.pop();

		return tdecl.getType(env);
	}
}

////////////////////////////////////////////////////
//												   //
//	   PASS 3- struct members					   //
//												   //
////////////////////////////////////////////////////

public final class KievFE_Pass3 extends TransfProcessor {
	public KievFE_Pass3(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Class members" }

	private boolean stdTypesAreChecked;

	private void checkStdTypes() {
		if (stdTypesAreChecked)
			return;
		StdTypes tenv = this.env.getTypeEnv();
		tenv.tpAny.checkResolved();
		tenv.tpVoid.checkResolved();
		tenv.tpBoolean.checkResolved();
		tenv.tpChar.checkResolved();
		tenv.tpByte.checkResolved();
		tenv.tpShort.checkResolved();
		tenv.tpInt.checkResolved();
		tenv.tpLong.checkResolved();
		tenv.tpFloat.checkResolved();
		tenv.tpDouble.checkResolved();
		tenv.tpNull.checkResolved();
		tenv.tpRule.checkResolved();
		tenv.tpBooleanRef.checkResolved();
		tenv.tpByteRef.checkResolved();
		tenv.tpCharRef.checkResolved();
		tenv.tpNumberRef.checkResolved();
		tenv.tpShortRef.checkResolved();
		tenv.tpIntRef.checkResolved();
		tenv.tpLongRef.checkResolved();
		tenv.tpFloatRef.checkResolved();
		tenv.tpDoubleRef.checkResolved();
		tenv.tpVoidRef.checkResolved();
		tenv.tpObject.checkResolved();
		tenv.tpClass.checkResolved();
		tenv.tpDebug.checkResolved();
		tenv.tpTypeInfo.checkResolved();
		tenv.tpTypeInfoInterface.checkResolved();
		tenv.tpCloneable.checkResolved();
		tenv.tpString.checkResolved();
		tenv.tpThrowable.checkResolved();
		tenv.tpError.checkResolved();
		tenv.tpException.checkResolved();
		tenv.tpCastException.checkResolved();
		tenv.tpJavaEnumeration.checkResolved();
		tenv.tpJavaIterator.checkResolved();
		tenv.tpJavaIterable.checkResolved();
		tenv.tpArrayEnumerator.checkResolved();
		tenv.tpRuntimeException.checkResolved();
		tenv.tpAssertException.checkResolved();
		tenv.tpEnum.checkResolved();
		tenv.tpAnnotation.checkResolved();
		tenv.tpClosure.checkResolved();
		tenv.tpPrologVar.checkResolved();
		tenv.tpRefProxy.checkResolved();
		tenv.tpTypeSwitchHash.checkResolved();
		stdTypesAreChecked = true;
	}

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_Pass3");
			try {
				checkStdTypes();
				doProcess(node);
			} finally { tr.leave(); }
		}
	}

	public void doProcess(ANode:ANode astn) {
	}

	public void doProcess(SyntaxScope:ANode astn) {
		foreach (ASTNode n; astn.members)
			doProcess(n);
	}

	public void doProcess(ComplexTypeDecl:ANode astn) {
		long pos = astn.pos;
		TypeDecl me = astn;
		trace(Kiev.debug && Kiev.debugResolve,"Pass 3 for class "+me);
		// Process members
		for(int i=0; i < me.members.length; i++) {
			if( me.members[i] instanceof Initializer ) {
				Initializer init = (Initializer)me.members[i];
				// TODO: check flags for initialzer
			}
			else if( me.members[i] instanceof RuleMethod ) {
				RuleMethod m = (RuleMethod)me.members[i];
				m.pass3(env);
				if( m.isPrivate() ) m.setFinal(true);
				if( me.isClazz() && me.isFinal() ) m.setFinal(true);
				else if( me.isInterface() ) 	m.setPublic();
				MetaAccess.verifyDecl(m);
			}
			else if( me.members[i] instanceof Method ) {
				Method m = (Method)me.members[i];
				m.pass3(env);
				if( m.isPrivate() )
					m.setFinal(false);
				if( me.isClazz() && me.isFinal() ) {
					m.setFinal(true);
				}
				else if( me.isInterface() && !me.isStructView() ) {
					m.setPublic();
					m.setFinal(false);
					if (m.body == null)
						m.setAbstract(true);
				}
				if( m instanceof Constructor ) {
					m.setAbstract(false);
					m.setSynchronized(false);
					m.setFinal(false);
				}
				MetaAccess.verifyDecl(m);
			}
			else if( me.members[i] instanceof Field ) {
				Field fdecl = (Field)me.members[i];
				Field f = fdecl;
				f.verifyMetas();
				// TODO: check flags for fields
				if( me.isStructView() && !f.isStatic() && f.sname != nameImpl) {
					//f.setFinal(true);
					f.setAbstract(true);
					f.setVirtual(true);
				}
				if( me.isInterface() ) {
					if (f.isVirtual()) {
						f.setAbstract(true);
					} else {
						if (me.isMixin()) {
							if !(f.isPrivate())
								f.setVirtual(true);
						} else {
							f.setStatic(true);
							f.setFinal(true);
						}
					}
					if (!me.isMixin()) {
						f.setPublic();
					}
					else if !(f.isPublic() || f.isPrivate()) {
						Kiev.reportWarning(f,"Mixin fields must be either public or private");
						f.setPublic();
					}
				}
				MetaAccess.verifyDecl(f); // recheck access
				Type ftype = fdecl.getType(env);
				MetaPacked pack = f.getMetaPacked();
				if (pack != null) {
					if( f.isStatic() ) {
						Kiev.reportWarning(fdecl,"Packing of static field(s) ignored");
						~pack;
					}
					else if( !ftype.isIntegerInCode() ) {
						if( ftype.getStruct() != null && ftype.getStruct().isEnum() ) {
							Kiev.reportError(fdecl,"Packing of enum is not implemented yet");
						} else {
							Kiev.reportError(fdecl,"Packing of reference type is not allowed");
						}
						~pack;
					} else {
						StdTypes tenv = this.env.getTypeEnv();
						int max_pack_size = 32;
						if( ftype ≡ tenv.tpShort || ftype ≡ tenv.tpChar ) {
							max_pack_size = 16;
							if( pack.size <= 0 ) pack.size = 16;
						}
						else if( ftype ≡ tenv.tpByte ) {
							max_pack_size = 8;
							if( pack.size <= 0 ) pack.size = 8;
						}
						else if( ftype ≡ tenv.tpBoolean) {
							max_pack_size = 1;
							if( pack.size <= 0 ) pack.size = 1;
						}
						if( pack.size < 0 || pack.size > max_pack_size ) {
							Kiev.reportError(fdecl,"Bad size "+pack.size+" of packed field");
							~pack;
						}
						else if( pack.offset >= 0 && pack.size+pack.offset > 32) {
							Kiev.reportError(fdecl,"Size+offset "+(pack.size+pack.offset)+" do not fit in 32 bit boundary");
							~pack;
						}
					}
				}
				if (f.getMetaPacked() != null)
					f.setAbstract(true);
			}
			else if( me.members[i] instanceof WBCCondition ) {
				WBCCondition inv = (WBCCondition)me.members[i];
				assert(inv.cond == WBCType.CondInvariant);
				// TODO: check flags for fields
				Method m = new MethodImpl(inv.sname,this.env.getTypeEnv().tpVoid,inv.getFlags());
				m.setInvariantMethod(true);
				m.body = new Block();
				inv.replaceWithNode(m,me,Struct.nodeattr$members);
				m.conditions += inv;
			}
			// Inner classes and cases after all methods and fields, skip now
		}

		if (me.isSingleton()) {
			me.setFinal(true);
			if (me.resolveField(env, nameInstance, false) == null) {
				Field inst = new Field(nameInstance, me.getType(env), ACC_STATIC|ACC_FINAL|ACC_PUBLIC|ACC_SYNTHETIC);
				inst.pos = me.pos;
				inst.init = new NewExpr(me.pos, me.getType(env), ENode.emptyArray);
				me.members += inst;

				Method get = new MethodImpl("getInstance", me.getType(env), ACC_STATIC|ACC_PUBLIC /*|ACC_SYNTHETIC*/);
				get.pos = me.pos;
				get.body = new Block(me.pos, new ENode[]{
					new ReturnStat(me.pos, new SFldExpr(me.pos,inst))
				});
				me.members += get;
			}
		}

		// Process inner classes and cases
		foreach (TypeDecl n; me.members)
			doProcess(n);
	}
}

////////////////////////////////////////////////////
//	   PASS Meta 1 - resolve meta decls           //
////////////////////////////////////////////////////

public final class KievFE_MetaDecls extends TransfProcessor {
	public KievFE_MetaDecls(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Annotation's declaration" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_MetaDecls");
			try {
				doProcess(node);
			} finally { tr.leave(); }
		}
	}

	public void doProcess(ANode:ANode node) {
	}
	public void doProcess(SyntaxScope:ANode node) {
		foreach(ASTNode n; node.members)
			doProcess(n);
	}
	public void doProcess(Struct:ANode node) {
		foreach (Struct sub; node.members)
			doProcess(sub);
	}
	public void doProcess(JavaAnnotation:ANode clazz) {
		foreach(ASTNode n; clazz.members) {
			if( n instanceof Method ) {
				Method m = (Method)n;
				if (m.params.length != 0)
					Kiev.reportError(m, "Annotation methods may not have arguments");
				if (m.body != null && !(m.body instanceof MetaValue))
					Kiev.reportError(m, "Annotation methods may not have bodies");
				if (m.conditions.elements().hasMoreElements())
					Kiev.reportError(m, "Annotation methods may not have work-by-contruct conditions");
				m.setPublic();
				m.setAbstract(true);
				m.pass3(env);
				if (m.mtype.ret() ≡ this.env.getTypeEnv().tpVoid || m.mtype.ret() ≡ this.env.getTypeEnv().tpRule)
					Kiev.reportError(m, "Annotation methods must return a value");
			}
			else if( n instanceof Field )
				;
			else if( n instanceof Struct )
				;
			else if( n instanceof Comment )
				;
			else
				Kiev.reportError(n, "Annotations may only have methods and final fields");
		}
	}
}

////////////////////////////////////////////////////
//	   PASS Meta 2 - resolve meta defaults        //
////////////////////////////////////////////////////

public final class KievFE_MetaDefaults extends TransfProcessor {
	public KievFE_MetaDefaults(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Annotation's defaults" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_MetaDefaults");
			try {
				doProcess(node);
			} finally { tr.leave(); }
		}
	}

	public void doProcess(ANode:ANode node) {
	}

	public void doProcess(SyntaxScope:ANode fu) {
		foreach(ASTNode n; fu.members)
			doProcess(n);
	}

	public void doProcess(ComplexTypeDecl:ANode clazz) {
		if (clazz instanceof JavaAnnotation)
			clazz.resolveMetaDefaults(env);
		foreach(ASTNode n; clazz.members)
			doProcess(n);
	}
}

////////////////////////////////////////////////////
//	   PASS Meta 3 - resolve meta annotations     //
////////////////////////////////////////////////////

public final class KievFE_MetaValues extends TransfProcessor {
	public KievFE_MetaValues(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Annotation values" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievFE_MetaValues");
			try {
				node.walkTree(new TreeWalker() {
					public boolean pre_exec(ANode n) {
						if !(n instanceof ASTNode)
							return false;
						if (n instanceof MNode)
							n.resolve(env, null);
						return true;
					}
				});
			} finally { tr.leave(); }
		}
	}
}

////////////////////////////////////////////////////
//	   PASS 5 - pre-resolve                       //
////////////////////////////////////////////////////

public final class KievFE_PreResolve extends TransfProcessor {
	public KievFE_PreResolve(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Kiev pre-resolve" }

	public void process(ANode node, Transaction tr) {
		tr = Transaction.enter(tr,"KievFE_PreResolve");
		try {
			node.walkTree(node.parent(), node.pslot(), new ITreeWalker() {
				public boolean pre_exec(INode n, INode parent, AttrSlot slot) { if (n instanceof ASTNode) return n.preResolveIn(env, parent, slot); return false; }
				public void post_exec(INode n, INode parent, AttrSlot slot) { if (n instanceof ASTNode) n.preResolveOut(env, parent, slot); }
			});
		} finally { tr.leave(); }
		return;
	}
}

////////////////////////////////////////////////////
//	   PASS 5 - main-resolve                      //
////////////////////////////////////////////////////

public final class KievFE_MainResolve extends TransfProcessor {
	public KievFE_MainResolve(Env env, int id) { super(env,id,KievExt.JavaOnly); }
	public String getDescr() { "Kiev main-resolve" }

	public void process(ANode node, Transaction tr) {
		tr = Transaction.enter(tr,"KievFE_MainResolve");
		try {
			node.walkTree(node.parent(), node.pslot(), new ITreeWalker() {
				public boolean pre_exec(INode n, INode parent, AttrSlot slot) { if (n instanceof ASTNode) return n.mainResolveIn(env, parent, slot); return false; }
				public void post_exec(INode n, INode parent, AttrSlot slot) { if (n instanceof ASTNode) n.mainResolveOut(env, parent, slot); }
			});
		} finally { tr.leave(); }
		return;
	}
}

////////////////////////////////////////////////////
//	   PASS - midend dump API as XML files        //
////////////////////////////////////////////////////

public final class KievME_DumpAPI extends BackendProcessor {

	public KievME_DumpAPI(Env env, int id) { super(env,id,KievBackend.Generic); }
	public String getDescr() { "Dump API files" }

	public boolean isEnabled() {
		return Kiev.enabled(KievExt.DumpAPI);
	}

	public void process(ANode node, Transaction tr) {
		if!(node instanceof FileUnit)
			return;
		FileUnit fu = (FileUnit)node;
		if (fu.scanned_for_interface_only)
			return;
		WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
		if (wthg.setProcessorRun(fu,this))
			return;

		tr = Transaction.enter(tr,"KievME_DumpAPI");
		try {
			dumpAPI(fu);
		}
		catch (Exception rte) { Kiev.reportError(rte); }
		finally { tr.leave(); }
	}

	public void dumpAPI(FileUnit fu) {
		if (Kiev.btd_dir != null && fu.is_project_file && !fu.loded_from_binary_dump) {
			try {
				String fname = Kiev.btd_dir + "/" + fu.pname();
				int ext = fname.lastIndexOf('.');
				if (ext > 0)
					fname = fname.substring(0,ext)+".btd";
				else
					fname = fname+".btd";
				File btdf = new File(fname);
				DumpFactory.getBinDumper().dumpToBinFile(env, new BinDumpFilter(), new ANode[]{fu}, btdf);
				if( Kiev.verbose ) System.out.println("Dumped BTD of source file "+fu);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		if (Kiev.dump_src_dir != null && fu.is_project_file && (fu.fname.endsWith(".java")||fu.fname.endsWith(".kj"))) {
			try {
				String fname = Kiev.dump_src_dir + "/" + fu.pname();
				TextPrinter prt = new DefaultTextProcessor();
				prt.setProperty("class", "stx-fmt·syntax-for-java");
				prt.setProperty("current", "true");
				prt.print(new ANode[]{fu}, new File(fname), env);
				if( Kiev.verbose ) System.out.println("Dumped java source file "+fu);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		long timestamp = Long.MAX_VALUE;
		if (Kiev.fast_gen)
			timestamp = fu.source_timestamp;
		boolean run_backend = false;

		foreach (ASTNode n; fu.members) {
			if (n instanceof ComplexTypeDecl)
				run_backend |= dumpAPI((ComplexTypeDecl)n, timestamp);
			if (n instanceof KievSyntax)
				run_backend |= dumpAPI((KievSyntax)n, timestamp);
			if (n instanceof SyntaxScope)
				run_backend |= dumpAPI((SyntaxScope)n, timestamp);
			if (n instanceof LangDecl)
				run_backend |= dumpAPI((LangDecl)n, timestamp);
			if (n instanceof ExportSerialized)
				dumpAPI((ExportSerialized)n, timestamp);
			if (n instanceof ExportXMLDump)
				dumpAPI((ExportXMLDump)n, timestamp);
		}

		if (Kiev.fast_gen)
			fu.dont_run_backend = !run_backend;
		else
			fu.dont_run_backend = false;

		if( Kiev.verbose && run_backend ) System.out.println("Dumped API of source file "+fu);
	}
	public boolean dumpAPI(SyntaxScope ns, long timestamp) {
		boolean run_backend = false;
		foreach (ASTNode n; ns.members) {
			if (n instanceof ComplexTypeDecl)
				run_backend |= dumpAPI((ComplexTypeDecl)n, timestamp);
			else if (n instanceof KievSyntax)
				run_backend |= dumpAPI((KievSyntax)n, timestamp);
			else if (n instanceof SyntaxScope)
				run_backend |= dumpAPI((SyntaxScope)n, timestamp);
			else if (n instanceof ExportSerialized)
				dumpAPI((ExportSerialized)n, timestamp);
			else if (n instanceof ExportXMLDump)
				dumpAPI((ExportXMLDump)n, timestamp);
		}
		return run_backend;
	}
	public boolean dumpAPI(ComplexTypeDecl td, long timestamp) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		String out_file = td.qname().replace('·',File.separatorChar);
		boolean run_backend = timestamp > new File(output_dir,out_file+(td instanceof Struct ? ".class" : ".xml")).lastModified();
		if (td.isPrivate())
			return run_backend;
		File f = new File(output_dir,out_file+".xml");
		{
			FileUnit fu = Env.ctxFileUnit(td);
			fu.addGeneratedFile(f.getPath());
		}
		if (timestamp < f.lastModified())
			return run_backend;
		try {
			DumpFactory.getXMLDumper().dumpToXMLFile(env, new XMLDumpFilter("api"), new ANode[]{td}, f);
		} catch (IOException e) {
			Kiev.reportWarning("Create/write error while API dump: "+e);
		}
		return run_backend;
	}
	public boolean dumpAPI(KievSyntax td, long timestamp) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		try {
			String out_file = td.qname().replace('·',File.separatorChar)+".xml";
			File f = new File(output_dir,out_file);
			if (timestamp < f.lastModified())
				return false;
			DumpFactory.getXMLDumper().dumpToXMLFile(env, new XMLDumpFilter("api"), new ANode[]{td}, f);
		} catch (IOException e) {
			Kiev.reportWarning("Create/write error while API dump: "+e);
		}
		return true;
	}
	public boolean dumpAPI(LangDecl td, long timestamp) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		try {
			String out_file = td.qname().replace('·',File.separatorChar)+".xml";
			File f = new File(output_dir,out_file);
			if (timestamp < f.lastModified())
				return false;
			DumpFactory.getXMLDumper().dumpToXMLFile(env, new XMLDumpFilter("full"), new ANode[]{td}, f);
		} catch (IOException e) {
			Kiev.reportWarning("Create/write error while API dump: "+e);
		}
		return true;
	}
	public void dumpAPI(ExportSerialized stx, long timestamp) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		FileOutputStream fo = null;
		try {
			String out_file = stx.qname().replace('·',File.separatorChar)+".ser";
			File f = new File(output_dir,out_file);
			if (timestamp < f.lastModified())
				return;
			File dir = f.getParentFile();
			if (dir != null) {
				dir.mkdirs();
				if( !dir.exists() || !dir.isDirectory() ) throw new IOException("Can't create output dir "+dir);
			}
			FileOutputStream fo = new FileOutputStream(f);
			ObjectOutput so = new ObjectOutputStream(fo);
			so.writeObject(stx.getDataToSerialize());
			so.flush();
		} catch (Exception e) {
			Kiev.reportWarning("Create/write error while API dump: "+e);
		} finally {
			if (fo != null)
				fo.close();
		}
	}
	public void dumpAPI(ExportXMLDump node, long timestamp) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		try {
			String out_file = node.qname().replace('·',File.separatorChar)+".xml";
			File f = new File(output_dir,out_file);
			if (timestamp < f.lastModified())
				return;
			DumpFactory.getXMLDumper().exportToXMLFile(env,node,f);
		} catch (Exception e) {
			Kiev.reportWarning("Create/write error while exporting: "+e);
		}
	}
}

////////////////////////////////////////////////////
//	   PASS - backend pre-generation              //
////////////////////////////////////////////////////

public final class KievME_PreGenartion extends BackendProcessor {
	public KievME_PreGenartion(Env env, int id) { super(env,id,KievBackend.Java15); }
	public String getDescr() { "Kiev pre-generation" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof CompilationUnit) {
			CompilationUnit cu = (CompilationUnit)node;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(cu,this))
				return;
			tr = Transaction.enter(tr,"KievME_PreGenartion");
			try {
				node.walkTree(new TreeWalker() {
					public boolean pre_exec(ANode n) {
						if (n instanceof ASTNode) {
							ASTNode astn = (ASTNode)n;
							return ((RNode)astn).preGenerate(env);
						}
						return false;
					}
				});
			} finally { tr.leave(); }
		}
	}
}


////////////////////////////////////////////////////
//	   PASS - backend resolve                     //
////////////////////////////////////////////////////

public final class KievBE_Resolve extends BackendProcessor {
	public KievBE_Resolve(Env env, int id) { super(env,id,KievBackend.Java15); }
	public String getDescr() { "Kiev resolve" }

	public void process(ANode node, Transaction tr) {
		tr = Transaction.enter(tr,"KievBE_Resolve");
		try {
			if (node instanceof ENode)
				RNode.resolveENode(node,null,env);
			else if (node instanceof DNode)
				RNode.resolveDNode(node,env);
			else if (node instanceof SNode)
				RNode.resolveSNode(node,env);
		} finally { tr.leave(); }
	}
}

////////////////////////////////////////////////////
//	   PASS - backend generate                    //
////////////////////////////////////////////////////

public final class KievBE_Generate extends BackendProcessor {
	public KievBE_Generate(Env env, int id) { super(env,id,KievBackend.Java15); }
	public String getDescr() { "Class generation" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof FileUnit) {
			FileUnit fu = (FileUnit)node;
			if (fu.scanned_for_interface_only)
				return;
			WorkerThreadGroup wthg = (WorkerThreadGroup)Thread.currentThread().getThreadGroup();
			if (wthg.setProcessorRun(fu,this))
				return;
			tr = Transaction.enter(tr,"KievBE_Generate");
			try {
				try {
					this.env.getBackendEnv().generateFile(fu);
				} catch (Exception rte) { Kiev.reportError(rte); }
			} finally { tr.leave(); }
		}
	}
}

////////////////////////////////////////////////////
//	   PASS - backend generate                    //
////////////////////////////////////////////////////
/*
public final class ExportBE_Generate extends BackendProcessor {
	public ExportBE_Generate(Env env, int id) { super(env,id,KievBackend.VSrc); }
	public String getDescr() { "Source generation" }

	public void process(ANode node, Transaction tr) {
		if (node instanceof FileUnit) {
			FileUnit fu = (FileUnit)node;
			if (fu.scanned_for_interface_only)
				return;
			try {
				dumpSrc(fu);
			} catch (Exception rte) { Kiev.reportError(rte); }
		}
	}

	public void dumpSrc(FileUnit fu) {
		String output_dir = Kiev.output_dir;
		if( output_dir==null ) output_dir = "classes";
		if( Kiev.verbose ) System.out.println("Dumping to source file "+fu+" into '"+output_dir+"' dir");

		try {
			String out_file = fu.pname();
			File f = new File(output_dir,out_file);
			ATextSyntax stx;
			if (fu.fname.toLowerCase().endsWith(".xml"))
				stx = new XmlDumpSyntax("full");
			else
				stx = (ATextSyntax)this.env.resolveGlobalDNode("stx-fmt·syntax-for-java");
			this.env.dumpTextFile(fu, f, stx.getCompiled(env).init());
		} catch (IOException e) {
			System.out.println("Create/write error while Kiev-to-Src exporting: "+e);
		}
	}
}
*/
////////////////////////////////////////////////////
//	   PASS - cleanup after backend               //
////////////////////////////////////////////////////

public final class KievBE_Cleanup extends BackendProcessor {
	public KievBE_Cleanup(Env env, int id) { super(env,id,KievBackend.Generic); }
	public String getDescr() { "Kiev cleanup after backend" }

	public void process(ANode node, Transaction tr) {
		tr = Transaction.enter(tr,"KievBE_Cleanup");
		try {
			try {
				this.env.getBackendEnv().backendCleanup(node);
			} catch (Exception rte) { Kiev.reportError(rte); }
		} finally { tr.leave(); }
	}
}

