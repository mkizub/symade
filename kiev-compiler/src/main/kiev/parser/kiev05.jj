options {
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  BUILD_PARSER = false;
//  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
//  USER_CHAR_STREAM = true;
  STATIC = false;
  ERROR_REPORTING = false;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(kiev050)
/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.parser;

/*{

import syntax kiev.Syntax;

import kiev.Kiev;
import java.io.Reader;

import static kiev.vlang.AccessFlags.*;

typedef SymbolRef<Field>		SymbolRefFld;

}*/ 

public final class Parser extends kiev050 {
	public Parser(Reader r, Env env) {
		super(r,1,1);
		this.curEnv = env;
	}
}

public interface ParserConstants extends kiev050Constants {
}

public abstract class kiev050 {

	public Env				curEnv;
	public FileUnit			curFileUnit;
	public boolean			interface_only = false;

	public boolean			declMode = true;

	public kiev050(java.io.Reader stream, int line, int pos) {
		jj_input_stream = new SimpleCharStream(stream, line, pos);
		token_source = new kiev050TokenManager(jj_input_stream, this);
		token = new Token();
		token.next = jj_nt = token_source.getNextToken();
	}

	/** Report Parser Error (Exception) */
	private void rpe(String msg, ParseError e) {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(curFileUnit, pos, msg, e);
		} else {
			kiev.Kiev.reportParserError(curFileUnit, pos, msg);
		}
	}

    /** Report other Error (Exception) */
	private void rperr(Throwable e) throws Throwable {
		int pos;
		if( token==null ) pos = 0;
		else if( token.next==null ) pos = token.getPos();
		else pos = token.next.getPos();
		if( kiev.Kiev.debug ) {
			kiev.Kiev.reportParserError(curFileUnit, pos, "Internal parser error:\n"+e, e);
		} else {
			kiev.Kiev.reportParserError(curFileUnit, pos, "Internal parser error: "+e.getMessage());
		}
		throw e;
	}

	private boolean operatorLA() {
		Token t0 = getToken(0);
		Token t1 = getToken(1);
		if (t0.endLine != t1.beginLine || t0.endColumn+1 != t1.beginColumn)
			return false;
		switch (t1.kind) {
		case ARROW:
		case LT:
		case GT:
		case ASSIGN:
		case OPERATOR_AT:
		case OPERATOR_SHARP:
		case OPERATOR_UPPER_BOUND:
		case OPERATOR_LOWER_BOUND:
		case OPERATOR:
			return true;
		}
		return false;
	}

	private boolean ExpressionNoNoLA() {
		switch (getToken(1).kind) {
		case RPAREN:
		case RBRACE:
		case RBRACKET:
		case SEMICOLON:
		case COLON:
		case COMMA:
			return false;
		}
		return true;
	}

	/*{
	private Struct mkStruct(Symbol name, Struct variant, int flags, ASTModifiers modifiers, ASTNode parent) {
		String uuid = modifiers == null ? null : modifiers.getUUID();
		Struct clazz;
		if (parent instanceof SyntaxScope) {
			clazz = curEnv.newStruct(name.sname,parent.getPackage(),flags,variant,uuid);
		}
		else if (parent instanceof Struct) {
			clazz = curEnv.newStruct(name.sname,(Struct)parent,flags,variant,uuid);
		}
		else if (name != null) {
			clazz = curEnv.newStruct(name.sname,null,flags,variant,uuid);
		}
		else {
			clazz = curEnv.newStruct(null,null,flags,variant,uuid);
		}
		if (name != null)
			clazz.pos  = name.pos;
		else
			clazz.pos  = parent.pos;
		clazz.setTypeDeclNotLoaded(false);
		modifiers.moveToNode(clazz);
		
		return clazz;
	}

	private TypeAssign mkTypeAssign(int pos, String name, ASTModifiers modifiers, DNode parent) {
		Symbol sym = null;
		String uuid = modifiers == null ? null : modifiers.getUUID();
		if (uuid != null)
			sym = curEnv.getSymbolByUUID(uuid);
		if (sym == null && parent instanceof TypeDecl) {
			if (parent.symbol.isGlobalSymbol())
				sym = parent.symbol.makeGlobalSubSymbol(name);
		}
		if (sym == null)
			sym = new Symbol(name);
		TypeAssign arg = new TypeAssign(sym);
		arg.pos = pos;
		if (modifiers != null)
			modifiers.moveToNode(arg);
		return arg;
	}

	private TypeConstr mkTypeConstr(int pos, String name, ASTModifiers modifiers, DNode parent) {
		Symbol sym = null;
		String uuid = modifiers == null ? null : modifiers.getUUID();
		if (uuid != null)
			sym = curEnv.getSymbolByUUID(uuid);
		if (sym == null && parent instanceof TypeDecl) {
			if (parent.symbol.isGlobalSymbol())
				sym = parent.symbol.makeGlobalSubSymbol(name);
		}
		if (sym == null)
			sym = new Symbol(name);
		TypeConstr arg = new TypeConstr(sym);
		arg.pos = pos;
		if (modifiers != null)
			modifiers.moveToNode(arg);
		return arg;
	}

	private Constructor mkConstructor(Symbol id, ASTModifiers modifiers) {
		Constructor meth = new Constructor(0);
		meth.pos = id.pos;
		modifiers.moveToNode(meth);
		return meth;
	}
	
	private Method mkMethod(Symbol id, ASTModifiers modifiers, TypeRef ret) {
		Method meth;
		if (modifiers.isGetter()) {
			meth = new MethodGetter();
			meth.sname = id.sname;
			meth.type_ret = ret;
		}
		else if (modifiers.isSetter()) {
			meth = new MethodSetter();
			meth.sname = id.sname;
			meth.type_ret = ret;
		}
		else {
			meth = new MethodImpl(id.sname, ret, 0);
		}
		meth.pos = id.pos;
		modifiers.moveToNode(meth);
		return meth;
	}
	
	private RuleMethod mkRuleMethod(Symbol id, ASTModifiers modifiers, TypeRef ret) {
		RuleMethod meth = new RuleMethod(id.sname, 0);
		meth.pos = id.pos;
		modifiers.moveToNode(meth);
		return meth;
	}
	
	private Field mkField(Symbol id, ASTModifiers modifiers, TypeRef tp, ENode init) {
		if (tp == null)
			tp = new TypeDeclRef();
		Field f = new Field(id.sname, tp, 0);
		f.pos = id.pos;
		modifiers.copyToNode(f);
		f.init = init;
		return f;
	}

	private Field mkEnumField(Symbol id, ASTModifiers modifiers) {
		Field f = new Field(id.sname,new TypeDeclRef(),0);
		f.mflags_is_enum = true;
		f.pos = id.pos;
		modifiers.moveToNode(f);
		f.setPublic();
		f.setStatic(true);
		f.setFinal(true);
		return f;
	}

	private Field mkCaseField(Symbol id, ASTModifiers modifiers, TypeRef tp) {
		Field f = new Field(id.sname,tp,0|ACC_PUBLIC);
		f.pos = id.pos;
		modifiers.moveToNode(f);
		return f;
	}
	
	private LVar mkVar(Symbol id, ASTModifiers modifiers, TypeRef tp) {
		if (tp == null)
			tp = new TypeDeclRef();
		LVar v = new LVar(id.pos, id.sname, tp, Var.VAR_LOCAL, 0);
		modifiers.copyToNode(v);
		return v;
	}
	
	private LVar mkRuleVar(Symbol id, ASTModifiers modifiers, TypeRef tp, boolean first) {
		if (!first)
			tp = new Copier().copyFull(tp);
		LVar v = new LVar(id.pos, id.sname, tp, Var.VAR_LOCAL, 0);
		modifiers.copyToNode(v);
		return v;
	}
	
	private LVar mkFormPar(Symbol id, ASTModifiers modifiers, TypeRef vt, TypeRef st) {
		LVar v = new LVar(id.pos, id.sname, vt, LVar.VAR_LOCAL, 0);
		if (st != null)
			v.stype = st;
		modifiers.moveToNode(v);
		return v;
	}
	
	private LVar mkVarargPar(Symbol id, ASTModifiers modifiers, TypeRef vt) {
		LVar v = new LVar(id.pos, id.sname, vt, LVar.VAR_LOCAL, ACC_FINAL);
		modifiers.moveToNode(v);
		return v;
	}
	
	private	Initializer mkInitializer(int pos, ASTModifiers modifiers) {
		Initializer init = new Initializer();
		init.pos = pos;
		modifiers.moveToNode(init);
		return init;
	}

	
	private ENode mkNotExpr(EToken not, ENode cond) {
		cond.setPrimaryExpr(true);
		ASTExpression e = new ASTExpression();
		e.pos = cond.pos;
		e.nodes.append(not);
		e.nodes.append(~cond);
		return e;
	}
	
	private void expandExpr(ASTExpression e, ENode n) {
		if (n instanceof ASTExpression) {
			foreach (ANode x; n.nodes.delToArray())
				e.nodes += x;
		} else {
			e.nodes += n;
		}
	}

	static ConstExpr sourceToConst(Token t) throws ParseException {
		ConstExpr ce = null;
		try
		{
			switch(t.kind) {
			case ParserConstants.INTEGER_LITERAL:
			{
				String image;
				int radix;
				if( t.image.startsWith("0x") || t.image.startsWith("0X") ) { image = t.image.substring(2); radix = 16; }
				else if( t.image.startsWith("0") && t.image.length() > 1 ) { image = t.image.substring(1); radix = 8; }
				else { image = t.image; radix = 10; }
				long i = ConstExpr.parseLong(image,radix);
				ce = new ConstIntExpr((int)i);
				switch (radix) {
				case 16: ce.radix = IntRadix.RADIX_HEX; break;
				case  8: ce.radix = IntRadix.RADIX_OCT; break;
				default: ce.radix = IntRadix.RADIX_DEC; break;
				}
				break;
			}
			case ParserConstants.LONG_INTEGER_LITERAL:
			{
				String image;
				int radix;
				if( t.image.startsWith("0x") || t.image.startsWith("0X") ) { image = t.image.substring(2,t.image.length()-1); radix = 16; }
				else if( t.image.startsWith("0") && !t.image.equals("0") && !t.image.equals("0L") ) { image = t.image.substring(1,t.image.length()-1); radix = 8; }
				else { image = t.image.substring(0,t.image.length()-1); radix = 10; }
				long l = ConstExpr.parseLong(image,radix);
				ce = new ConstLongExpr(l);
				switch (radix) {
				case 16: ce.radix = IntRadix.RADIX_HEX; break;
				case  8: ce.radix = IntRadix.RADIX_OCT; break;
				default: ce.radix = IntRadix.RADIX_DEC; break;
				}
				break;
			}
			case ParserConstants.FLOATING_POINT_LITERAL:
			{
				String image;
				if( t.image.endsWith("f") || t.image.endsWith("F") ) image = t.image.substring(0,t.image.length()-1);
				else image = t.image;
				float f = Float.valueOf(image).floatValue();
				ce = new ConstFloatExpr(f);
				break;
			}
			case ParserConstants.DOUBLE_POINT_LITERAL:
			{
				String image;
				if( t.image.endsWith("d") || t.image.endsWith("D") ) image = t.image.substring(0,t.image.length()-1);
				else image = t.image;
				double d = Double.valueOf(t.image).doubleValue();
				ce = new ConstDoubleExpr(d);
				break;
			}
			case ParserConstants.CHARACTER_LITERAL:
			{
				char c;
				if( t.image.length() == 3 )
					c = t.image.charAt(1);
				else
					c = ConstExpr.source2ascii(t.image.substring(1,t.image.length()-1)).charAt(0);
				ce = new ConstCharExpr(c);
				break;
			}
			case ParserConstants.STRING_LITERAL:
				ce = new ConstStringExpr(ConstExpr.source2ascii(t.image.substring(1,t.image.length()-1)));
				break;
			//case ParserConstants.TRUE:
			//	ce = new ConstBoolExpr(true);
			//	break;
			//case ParserConstants.FALSE:
			//	ce = new ConstBoolExpr(false);
			//	break;
			//case ParserConstants.NULL:
			//	ce = new ConstNullExpr();
			//	break;
			}
		} catch( NumberFormatException e ) {
			throw new ParseException(t.image);
		}
		if (ce == null) {
			Kiev.reportParserError(null, t.getPos(), "Unknown term "+t.image);
			ce = new ConstNullExpr();
		}
		ce.pos = t.getPos();
		return ce;
	}

	private TypeRef makeTypeExpr(TypeRef arg, Token op) {
		if (op.kind == ParserConstants.OPERATOR_SHARP)
			return new TypeASTNodeRef(arg.ident, null);
		TypeExpr te = new TypeExpr();
		te.arg = arg;
		if (op.kind == ParserConstants.OPERATOR_LRBRACKETS) {
			te.op_name = "T []";
		} else {
			te.op_name = ("T "+op.image).intern();
		}
		te.pos = op.getPos();
		return te;
	}
	

	}*/

	void comments_alone(SpacePtr arr) {
		Comment[] comments = get_comments();
		if (comments == null || comments.length == 0)
			return;
		for (int i=0; i < comments.length; i++)
			arr += comments[i];
	}
	//void comments_before(ASTNode node) {
	//	Comment[] comments = get_comments();
	//	if (comments == null || comments.length == 0)
	//		return;
	//	for (int i=0; i < comments.length; i++)
	//		Comment.ATTR_COMMENT.add(node, comments[i]);
	//}

	Comment[] get_comments() {
		Token t0 = getToken(0);
		Token t1 = getToken(1);
		Token st = t1.specialToken;
		if (st == null)
			return null;
		Comment[] comments = new Comment[0];
		t1.specialToken = null;
		while (st.specialToken != null)
			st = st.specialToken;
		for (; st != null; st = st.next) {
			if (st.kind == SINGLE_LINE_COMMENT) {
				String text = st.image.substring(2);
				text = text.trim();
				if (comments.length > 0 && (comments[comments.length-1].mode == CommentMode.LINE || comments[comments.length-1].mode == CommentMode.EOLINE)) {
					Comment c = comments[comments.length-1];
					c.elems.append(new TextLine(text));
				} else {
					Comment c = new Comment();
					c.mode = CommentMode.EOLINE;
					c.elems.append(new TextLine(text));
					if (st.specialToken != null) {
						if (st.beginLine > st.specialToken.endLine)
							c.mode = CommentMode.LINE;
					} else {
						if (st.beginLine < t0.endLine)
							c.mode = CommentMode.LINE;
					}
					comments = (Comment[])Arrays.append(comments, c);
				}
			}
			else if (st.kind == FORMAL_COMMENT || st.kind == MULTI_LINE_COMMENT) {
				String text = (st.kind == FORMAL_COMMENT) ?
						st.image.substring(3, st.image.length()-5)
					:	st.image.substring(2, st.image.length()-4);
				String[] lines = text.trim().split("\n");
				for (int i=0; i < lines.length; i++) {
					String l = lines[i].trim();
					if (l.length() >= 1 && l.charAt(0) == '*') {
						l = l.substring(1);
						l = l.trim();
					}
					lines[i] = l;
				}
				boolean nl = false;
				Comment c = new Comment();
				for (int i=0; i < lines.length; i++)
					c.elems.append(new TextLine(lines[i].trim()));
				
				if (st.specialToken != null) {
					if (st.beginLine > st.specialToken.endLine)
						nl = true;
				} else {
					if (st.beginLine < t0.endLine)
						nl = true;
				}
				
				if (st.next != null) {
					if (st.endLine < st.next.beginLine)
						nl = true;
				} else {
					if (st.endLine < t1.beginLine)
						nl = true;
				}
				if (st.kind == FORMAL_COMMENT)
					c.mode = CommentMode.DOCUMENTATION;
				else if (nl)
					c.mode = CommentMode.FLOW;
				else
					c.mode = CommentMode.INLINE;
				comments = (Comment[])Arrays.append(comments, c);
			}
		}
		return comments;
	}

}

PARSER_END(kiev050)


TOKEN_MGR_DECLS :
{
	final kiev050 parser;
	public kiev050TokenManager(SimpleCharStream stream, kiev050 parser)
	{
		if (SimpleCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		this.parser = parser;
		this.input_stream = stream;
	}
}

<DEFAULT,IN_PRAGMA>
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*{"
| "}*/"
}

/* COMMENTS */

<DEFAULT>
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<DEFAULT>
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CLASS: "class" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FOR: "for" >
| < FOREACH: "foreach" >
| < GOTO: "goto" >
| < IF: "if" >
| < IF_REWR: "if#" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INTERFACE: "interface" >
| < NATIVE: "native" >
| < PACKAGE: "package">
| < RETURN: "return" >
| < STATIC: "static" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < WITH: "with" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRY: "try" >
| < VOLATILE: "volatile" >
| < VIEW: "view" >
| < WHILE: "while" >
| < VARARGS: "..." >
| < PCUT: "$cut" >
| < ALIAS: "alias" >
| < TYPE: "type" >
| < TYPEDEF: "typedef" >
| < ENUM: "enum" >

| < REQUIRE: "require" >
| < ENSURE: "ensure" >
| < INVARIANT: "invariant" >

| < META_INTERFACE:    "@interface"    >
| < META_SINGLETON:    "@singleton"    >
| < META_MIXIN:        "@mixin"        >
| < META_FORWARD:      "@forward"      >
| < META_UNERASABLE:   "@unerasable"   >
| < META_VIRTUAL:      "@virtual"      >
| < META_PACKED:       "@packed"       >
| < META_MACRO:        "@macro"        >
| < META_STATIC:       "@static"       >
| < META_ABSTRACT:     "@abstract"     >
| < META_FINAL:        "@final"        >
| < META_NATIVE:       "@native"       >
| < META_SYNCHRONIZED: "@synchronized" >
| < META_TRANSIENT:    "@transient"    >
| < META_VOLATILE:     "@volatile"     >
| < META_THROWS:       "@throws"       >
| < META_UUID:         "@uuid"         >
| < META_GETTER:       "@getter"       >
| < META_SETTER:       "@setter"       >

}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < META_ACCESS1:   "@access"    > : IN_ACCESS
| < META_PUBLIC:    "@public"    > : IN_ACCESS
| < PUBLIC:         "public"     > : IN_ACCESS
| < META_PROTECTED: "@protected" > : IN_ACCESS
| < PROTECTED:      "protected"  > : IN_ACCESS
| < META_PRIVATE:   "@private"   > : IN_ACCESS
| < PRIVATE:        "private"    > : IN_ACCESS
}

<IN_ACCESS>
TOKEN :
{
   < READ_ONLY:     "ro" | "r" >
 | < WRITE_ONLY:    "wo" | "w" >
 | < READ_WRITE:    "rw"       >
 | < NO_READ_WRITE: "no" | "n" >
 | < COMMA1: "," >
 | < COLON1: ":" >
 | < OPEN_ACCESS: "(" >
 | < CLOSE_ACCESS: ")" > : DEFAULT
}
<IN_ACCESS>
SKIP :
{
   " " : DEFAULT
 | "\t" : DEFAULT
 | "\n" : DEFAULT
 | "\r" : DEFAULT
 | "\f" : DEFAULT
}


TOKEN :
{
< PRAGMA: "pragma" > { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : IN_PRAGMA
}
<IN_PRAGMA>
TOKEN :
{
   < PRAGMA_ENABLE:  "enable" > { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
 | < PRAGMA_DISABLE: "disable"> { if(!parser.declMode) matchedToken.kind=IDENTIFIER; } : DEFAULT
}


<DEFAULT>
TOKEN : /* RESERVED WORDS FOR EXPRS */
{
  < FUNCTION: "fun" >
| < NEW: "new" >
| < OPERATOR_ID: "operator" >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_INTEGER_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["d","D"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      | (["0"-"9"])+ <EXPONENT> ["d","D"]
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

<DEFAULT>
TOKEN : /* LITERALS */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
      "\""
  >
}

<DEFAULT>
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ( <LETTER> (<LETTER>|<DIGIT>)* | "#id\"" <ID_STRING_LITERAL> "\"#"  | "`" <ID_STRING_LITERAL> "`" ) >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
 |
  < #ID_STRING_LITERAL:
      (   (~["\"","'","`","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","`","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | ["u","U"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
          )
      )*
  >
}

<DEFAULT>
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COLON: ":" >
| < DOT: "." >
| < COMMA: "," >
}

<DEFAULT>
TOKEN : /* Special Operators */
{
  < LT: "<" >
| < GT: ">" >
| < LANGLE: "<\u0335" > // <̵
| < RANGLE: ">\u0335" > // >̵
}

<DEFAULT>
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >

| < IS_THE: "?=" >
| < IS_ONE_OF: "@=" >
| < ARROW: "->" >

| < OPERATOR_AT:    "@" >
| < OPERATOR_SHARP: "#" >
| < OPERATOR_LRBRACKETS: "[" ( " " )* "]" >
| < OPERATOR_SUPERSCRIPT_PLUS: "\u207a" >
| < OPERATOR_SUPERSCRIPT_MINUS: "\u207b" >

| < OPERATOR_UPPER_BOUND:    "\u2264" > // ≤
| < OPERATOR_LOWER_BOUND:    "\u2265" > // ≥

| < OPERATOR:	    ["!","?","~","|","&","+","-","*","/","^","%","\u2190"-"\u22F1"] >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

FileUnit FileUnit(String filename) :
{ FileUnit oldFileUnit; SymbolRef pkg; }
{
	{
		oldFileUnit = curFileUnit;
		FileUnit fu = FileUnit.makeFile(filename, curEnv.proj, false);
		curFileUnit = fu;
		declMode = true;
		ASTModifiers modifiers;
	}
	try {
		(
			LOOKAHEAD({ getToken(1).kind==IMPORT && getToken(2).kind==IDENTIFIER && getToken(2).image.equals("syntax") })
			fu.syntaxes += ImportSyntax()
		|
			pkg = Package()
			{
				if (fu.srpkg.name == null) {
					fu.srpkg.symbol = pkg.symbol;
					fu.srpkg.pos = pkg.pos;
				} else
					Kiev.reportError(pkg,"Duplicate package declaration "+pkg);
			}
		)*
		TopLevelDeclarations(fu)
		{ fu.line_count = getToken(0).endLine; }
		<EOF>
	}
	catch(ParseError e) { rpe("Bad declaration",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		curFileUnit = oldFileUnit;
		declMode = true;
		return fu;
	}
}

NameSpace NameSpaceDeclaration(ASTModifiers modifiers, SyntaxScope parent) :
{ NameSpace ns = new NameSpace(); SymbolRef sr; }
{
	{ declMode = true; }
	try {
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("namespace") })
		<IDENTIFIER>	// "namespace"
		(	LOOKAHEAD({ parent.getPackage() instanceof KievRoot })
			sr = QName()		{ ns.srpkg.name = sr.name; ns.srpkg.pos = sr.pos; }
		|	sr = NameRef()		{ ns.srpkg.name = sr.name; ns.srpkg.pos = sr.pos; }
		)
		{ parent.members += ns; }
		"{"
		TopLevelDeclarations(ns)
		"}"
	}
	catch(ParseError e) { rpe("Bad declaration",e); }
	catch(Throwable e) { rperr(e); }
	finally {
		declMode = true;
		return ns;
	}
}

void TopLevelDeclarations(SyntaxScope ss) :
{ ASTModifiers modifiers; SpacePtr ss_members = Env.getSpacePtr(ss, "members"); }
{
	(	LOOKAHEAD({ getToken(1).kind != RBRACE && getToken(1).kind != EOF })
		{ comments_alone(ss_members); }
		modifiers = Modifiers()
		(
			ss.members += Import(modifiers)
		|	ss.members += Typedef(modifiers)
		|	ss.members += TypeDeclaration(modifiers, ss) [ ";" ]
		|	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("namespace") })
			NameSpaceDeclaration(modifiers, ss) [ ";" ]
		)
	)*
	{ comments_alone(ss_members); }
}

ASTModifiers Modifiers() :
{}
{	{ ASTModifiers n = new ASTModifiers(); }
	(
		SpecialAnnotation(n)
	|	Access(n)			// TODO: remove, use @access and views
	|	LOOKAHEAD({ getToken(1).kind==OPERATOR_AT })
		n += Annotation()
	)*
	{ return n; }
}

void InBlockModifiersLA() :
{}
{
		"@"

	|	"@access"
	|	"@public"
	|	"@protected"
	|	"@private"

	| "@singleton"
	| "@mixin"
	| "@forward"
	| "@unerasable"
	| "@virtual"
	| "@macro"
	| "static"
	| "@static"
	| "abstract"
	| "@abstract"
	| "final"
	| "@final"
	| "@native"
	| "@synchronized"
	| "@transient"
	| "@volatile"
	| "@packed"
	| "@throws"
	| "@uuid"
	| "@getter"
	| "@setter"
}

SymbolRef Package() :
{ SymbolRef qn; }
{
	"package"
	qn = QName()
	";"
	{
		qn.symbol = curEnv.newPackage(qn.name).symbol;
		return qn;
	}
}

ImportSyntax ImportSyntax() :
{ SymbolRef qname; }
{
	"import"
	LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("syntax") })
	<IDENTIFIER>
	qname = QName()
	";"
	{
		ImportSyntax imp = new ImportSyntax();
		imp.name.name = qname.name;
		imp.name.qualified = true;
		imp.pos = qname.pos;
		return imp;
	}
}

Import Import(ASTModifiers modifiers) :
{ Import imp = new ImportImpl(); SymbolRef name; }
{
	"import"
	[ "static"	{ imp = new ImportStatic(); } ]
	name = QName() { imp.name.name = name.name; imp.name.pos = name.pos; }
	[	LOOKAHEAD( "." <OPERATOR>, { getToken(2).image.equals("*") })
		"." <OPERATOR>
		{
			if (imp instanceof ImportImpl)
				imp.star = true;
			else if (imp instanceof ImportStatic)
				imp.star = true;
		}
	|	"("
		{
			ImportMethod im = new ImportMethod();
			int p = imp.name.name.indexOf('\u00b7');
			String nm; 
			String meth; 
			if (p < 0) {
				nm = "";
				meth = imp.name.name;
			} else {
				nm = imp.name.name.substring(0,p);
				meth = imp.name.name.substring(0,p+1);
			}
			im.name.name = nm;
			im.method.name = meth;
			im.name.pos = imp.pos;
			im.method.pos = getToken(0).getPos();
			imp = im;
		}
		[
			im.args += Type()
			(
				","
				im.args += Type()
			)*
		]
		")"
	]
	";"
	{ return imp; }
}

TypeAssign Typedef(ASTModifiers modifiers) :
{ Symbol id; TypeAssign ta; TypeRef tr; Token t; EToken et; }
{
	("typedef"|"type")
	tr = Type()
	id = Name()
	{ ta = mkTypeAssign(id.pos, id.sname, modifiers, null); ta.super_types += tr; }
	";"
	{ return ta; }
}

Struct TypeDeclaration(ASTModifiers modifiers, ASTNode parent) :
{ Struct clazz; Symbol name; TypeConstr[] args; }
{
	(
		"class"
		name = Name()
		{
			if (modifiers.isSymadeNode())
				clazz = mkStruct(name, new SymadeNode(), 0, modifiers, parent);
			else
				clazz = mkStruct(name, new JavaClass(), 0, modifiers, parent);
		}
		[
			args = ClazzArguments(clazz) { clazz.args.addAll(args); }
		]
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
		[
			"implements"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	|	"interface"
		name = Name()
		{
			if (modifiers.isSymadeNode())
				clazz = mkStruct(name, new SymadeNode(), ACC_INTERFACE, modifiers, parent);
			else
				clazz = mkStruct(name, new JavaClass(), ACC_INTERFACE, modifiers, parent);
		}
		[
			args = ClazzArguments(clazz) { clazz.args.addAll(args); }
		]
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	|	"@interface"
		(	name = Name()
		|	name = KeywordAsName()
		)
		{
			clazz = mkStruct(name, new JavaAnnotation(), ACC_INTERFACE|ACC_ANNOTATION, modifiers, parent);
		}
	|	"enum"
		name = Name()
		{
			clazz = mkStruct(name, new JavaEnum(), ACC_ENUM|ACC_STATIC, modifiers, parent);
		}
	|	"view"
		name = Name()
		{
			clazz = mkStruct(name, new KievView(), ACC_VIRTUAL, modifiers, parent);
			KievView kview = (KievView)clazz;
		}
		[
			args = ClazzArguments(clazz) { clazz.args.addAll(args); }
		]
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("of") })
		<IDENTIFIER> // "of"
		kview.view_of = NArrType()
		[
			"extends"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
		[
			"implements"
			clazz.super_types += Type()
			( "," clazz.super_types += Type()	)*
		]
	)
	TypeBodyDeclaration(clazz)
	{ return clazz; }
}

void TypeBodyDeclaration(ComplexTypeDecl clazz) :
{ ASTModifiers modifiers; SpacePtr clazz_members = Env.getSpacePtr(clazz, "members"); Struct sub_struct; }
{
	"{"
	(
		LOOKAHEAD({ clazz.isEnum() })
		{ JavaEnum enum_clazz = (JavaEnum)clazz; }
		modifiers = Modifiers()
		enum_clazz.enum_fields += EnumFieldDeclaration(modifiers)
		(	","
			modifiers = Modifiers()
			enum_clazz.enum_fields += EnumFieldDeclaration(modifiers)
		)*
		[ ";" ]
	)?
	(
		LOOKAHEAD({ getToken(1).kind != RBRACE })
		{ comments_alone(clazz_members); }
		modifiers = Modifiers()
		(	LOOKAHEAD({ getToken(1).kind == LBRACE })
			clazz.members += Initializer(modifiers)
		|	LOOKAHEAD(1)
			clazz.members += InvariantDeclaration(modifiers)
			[ ";" ]
		|	LOOKAHEAD(1)
			sub_struct     = TypeDeclaration(modifiers, clazz)
			{ if (!sub_struct.isAttached()) clazz.members += sub_struct; else assert(clazz.members.indexOf(sub_struct) >= 0); }
			[ ";" ]
		|	LOOKAHEAD(1)
			clazz.members += MemberArgDecl(modifiers,clazz)
		|	LOOKAHEAD(1)
			sub_struct     = CaseTypeDeclaration(modifiers, clazz)
			{ if (!sub_struct.isAttached()) clazz.members += sub_struct; else assert(clazz.members.indexOf(sub_struct) >= 0); }
		|
			//LOOKAHEAD( "rule" <IDENTIFIER> "(" )
			LOOKAHEAD(3, <IDENTIFIER> <IDENTIFIER> "(", { getToken(1).image.equals("rule") })
			clazz.members += RuleDeclaration(modifiers)
		|
			LOOKAHEAD(0)
			clazz.members += FieldOrMethodDecl(modifiers, clazz)
		)
	)*
	{ comments_alone(clazz_members); }
	"}"
}

DNode FieldOrMethodDecl(ASTModifiers modifiers, ComplexTypeDecl clazz) :
{ TypeConstr[] args; TypeRef dtype; DNode res = null; }
{
	(
		args = ClazzArguments(null)
		(
			LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
			res = ConstructorDeclaration(modifiers, args, clazz)
		|
			dtype = Type()
			res = MethodDeclaration(modifiers, args, dtype)
		)
	|
		LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
		res = ConstructorDeclaration(modifiers, null, clazz)
	|
		dtype = Type()
		(
			LOOKAHEAD({ getToken(1).kind == IDENTIFIER && getToken(2).kind == LPAREN }) // LOOKAHEAD (<IDENTIFIER> "(")
			res = MethodDeclaration(modifiers, null, dtype)
		|
			LOOKAHEAD(0)
			res = FieldDecl(modifiers, dtype)
		)
	)
	{ return res; }
}


Field EnumFieldDeclaration(ASTModifiers modifiers) :
{ Symbol id; Field f; NewEnumExpr ne; }
{
	id = Name()
	{ f = mkEnumField(id, modifiers); }
	(
		":"
		f.alt_enum_id = StringConstExpression()
	|
		"("
			{ ne = new NewEnumExpr(); f.init = ne; }
			[	LOOKAHEAD({ getToken(1).kind != RPAREN })
				ne.args += ExpressionColon()
				(	"," ne.args += ExpressionColon()	)*
			]
		")"
	|
		{}
	)
	{ return f; }
}

Struct CaseTypeDeclaration(ASTModifiers modifiers, ComplexTypeDecl parent) :
{ Symbol name; PizzaCase clazz; TypeConstr[] args; }
{
	"case"
	name = Name()
	{
		clazz = (PizzaCase)mkStruct(name, new PizzaCase(), ACC_STATIC|ACC_FINAL, modifiers, parent);
	}
	[
		args = ClazzArguments(clazz) { clazz.args.addAll(args); }
	]
	(
		"("
			(
				LOOKAHEAD({ getToken(1).kind != RPAREN })
				modifiers = Modifiers()
				clazz.case_fields += CaseTypeField(modifiers)
				(
					","
					modifiers = Modifiers()
					clazz.case_fields += CaseTypeField(modifiers)
				)*
			)?
		")"
		";"
	|
		";"
		{ clazz.metas.add(new MetaSingleton()); }
	)
	{ return clazz; }
}


TypeConstr[] ClazzArguments(DNode dn) :
{ TypeConstr[] args = new TypeConstr[0]; TypeConstr arg; }
{
	("<" | <LANGLE>)
		arg = ArgumentDeclaration(dn)
		{ args = (TypeConstr[])Arrays.append(args,arg); }
		(	","
			arg = ArgumentDeclaration(dn)
			{ args = (TypeConstr[])Arrays.append(args,arg); }
		)*
	(">" | <RANGLE>)
	{ return args; }
}

TypeDef MemberArgDecl(ASTModifiers modifiers, DNode dn) :
{ Symbol name; TypeDef arg; TypeRef t; }
{
	("typedef"|"type")
	(
		name      = Name()
		(
			"="
			{ arg = mkTypeAssign(name.pos,name.sname,modifiers,dn); }
			t = Type() { arg.super_types += t; }
			";"
		|
			{ arg = mkTypeConstr(name.pos,name.sname,modifiers,dn); }
			(
				<OPERATOR_UPPER_BOUND> t = Type() { arg.super_types.add(t);}
			|	<OPERATOR_LOWER_BOUND> t = Type() { arg.lower_bound.add(t);}
			)+
			";"
		)
	)
	{ return arg; }
}

TypeConstr ArgumentDeclaration(DNode dn) :
{ ASTModifiers modifiers; Symbol name; TypeConstr arg; TypeRef tr; TypeVariance variance = null; }
{
	modifiers = Modifiers()
	(
		LOOKAHEAD( <OPERATOR> /*, { getToken(1).image.equals("+") || getToken(1).image.equals("-") || getToken(1).image.equals("*") } */)
		//"+" | "-" | "*"
		<OPERATOR>
		{
			String img = getToken(0).image;
			if (img.equals("+"))
				variance = TypeVariance.CO_VARIANT;
			else if (img.equals("-"))
				variance = TypeVariance.CONTRA_VARIANT;
			else if (img.equals("*"))
				variance = TypeVariance.IN_VARIANT;
		}
	)?
	name      = Name()
	{
		arg = mkTypeConstr(name.pos,name.sname,modifiers,dn); arg.setAbstract(true);
		if (variance != null)
			arg.variance = variance;
	}
	[
		"extends"
		tr = Type() { arg.super_types.add(tr); }
		(	LOOKAHEAD( <OPERATOR>, { getToken(1).image.equals("&") })
			<OPERATOR>
			tr = Type() { arg.super_types.add(tr); }
		)*
	]
	[
		LOOKAHEAD({ getToken(1).kind==IDENTIFIER && getToken(1).image.equals("super") }) //"super"
		<IDENTIFIER>
		tr = Type() { arg.lower_bound.add(tr); }
		(	LOOKAHEAD( <OPERATOR>, { getToken(1).image.equals("&") })
			<OPERATOR>
			tr = Type() { arg.lower_bound.add(tr); }
		)*
	]
	(
		<OPERATOR_UPPER_BOUND> tr = Type() { arg.super_types.add(tr);}
	|	<OPERATOR_LOWER_BOUND> tr = Type() { arg.lower_bound.add(tr);}
	)*
	{ return arg; }
}

void Access(ASTModifiers modifiers) :
{ int acc; 	int accflags = 0; int offset = 6; MetaAccess ma; }
{
	(
		"@access"		{ ma = new MetaAccess(); }
	|	"@public"		{ ma = new MetaAccess("public"); }
	|	"public"		{ ma = new MetaAccess("public"); }
	|	"@protected"	{ ma = new MetaAccess("protected"); }
	|	"protected"		{ ma = new MetaAccess("protected"); }
	|	"@private"		{ ma = new MetaAccess("private"); }
	|	"private"		{ ma = new MetaAccess("private"); }
	)
	(
		<COLON1> // ":"
		acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		]]]
		{ ma.flags = accflags; }
	|	<OPEN_ACCESS> // "("
		acc = AccessSpec()            { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		[ <COMMA1> acc = AccessSpec() { for(int i=offset; i >= 0; i-=2) { accflags &= ~(3 << i); accflags |= acc << i; } offset -= 2; }
		]]]
		<CLOSE_ACCESS> // ")"
		{ ma.flags = accflags; }
	)?
	{
		if (ma.flags != -1)
			modifiers += ma;
		else if (ma.simple == "public")
			modifiers += new MetaPublic();
		else if (ma.simple == "protected")
			modifiers += new MetaProtected();
		else if (ma.simple == "private")
			modifiers += new MetaPrivate();
	}
}

int AccessSpec() :
{}
{
	<READ_ONLY>		{ return 2; }
|	<WRITE_ONLY>	{ return 1; }
|	<READ_WRITE>	{ return 3; }
|	<NO_READ_WRITE>	{ return 0; }
}

void SpecialAnnotation(ASTModifiers modifiers) :
{ MetaPacked mp; MetaThrows mthr; MetaUUID muuid; TypeNameRef thr; ConstIntExpr ice; ConstStringExpr cs; SymbolRef nr; }
{
	  "@singleton"		{ modifiers += new MetaSingleton(); }
	| "@mixin"			{ modifiers += new MetaMixin(); }

	| "@forward"		{ modifiers += new MetaForward(); }
	| "@unerasable"		{ modifiers += new MetaUnerasable(); }
	| "@virtual"		{ modifiers += new MetaVirtual(); }
	| "@macro"			{ modifiers += new MetaMacro(); }
	
	| "static"			{ modifiers += new MetaStatic(); }
	| "@static"			{ modifiers += new MetaStatic(); }
	
	| "abstract"		{ modifiers += new MetaAbstract(); }
	| "@abstract"		{ modifiers += new MetaAbstract(); }

	| "final"			{ modifiers += new MetaFinal(); }
	| "@final"			{ modifiers += new MetaFinal(); }
	
	| "native"			{ modifiers += new MetaNative(); }
	| "@native"			{ modifiers += new MetaNative(); }
	
	| "synchronized"	{ modifiers += new MetaSynchronized(); }
	| "@synchronized"	{ modifiers += new MetaSynchronized(); }

	| "transient"		{ modifiers += new MetaTransient(); }
	| "@transient"		{ modifiers += new MetaTransient(); }

	| "volatile"		{ modifiers += new MetaVolatile(); }
	| "@volatile"		{ modifiers += new MetaVolatile(); }
	
	| "@packed"
		{ mp = new MetaPacked(); }
		(
			"("
						ice = IntConstExpression() { mp.size = ice.value; }
			[	","		nr  = NameRef() { mp.fld = (SymbolRefFld)nr; }
				","		ice = IntConstExpression() { mp.offset = ice.value; }
			]
			")"
		|
			":" 	ice = IntConstExpression() { mp.size = ice.value; }
			[
			","		nr  = NameRef() { mp.fld = (SymbolRefFld)nr; }
			","		ice = IntConstExpression() { mp.offset = ice.value; }
			]
		|
			{}
		)
		{ modifiers += mp; }

	| "@throws"
		{ mthr = new MetaThrows(); }
		(
			thr = TypeQName() { mthr.add(thr); }
			( "," thr = TypeQName() { mthr.add(thr); } )*
		|
			"(" [ LOOKAHEAD(2) <IDENTIFIER> "="] ["{"]
			thr = TypeQName() { mthr.add(thr); }
			( "," thr = TypeQName() { mthr.add(thr); } )*
			 ["}"] ")"
		)
		{ modifiers += mthr; }

	| "@uuid"
		{ muuid = new MetaUUID(); }
		"("
		cs = StringConstExpression()
		")"
		{ muuid.value = cs.value; modifiers += muuid; }
	| "@getter"		{ modifiers += new MetaGetter(); }
	| "@setter"		{ modifiers += new MetaSetter(); }
}

SymbolRef KeywordAsNameRef() :
{ Token t; SymbolRef id; }
{
	(
		t="alias"
	|	t="throws"
	)
	{
		id = new SymbolRef();
		id.pos = t.getPos();
		if (t.image.startsWith("#id\""))
			id.name = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
		else if (t.image.startsWith("`"))
			id.name = ConstExpr.source2ascii(t.image.substring(1,t.image.length()-1));
		else
			id.name = t.image;
		return id;
	}
}

Symbol KeywordAsName() :
{ Token t; Symbol id; }
{
	(
		t="alias"
	|	t="throws"
	)
	{
		id = new Symbol();
		id.pos = t.getPos();
		if (t.image.startsWith("#id\""))
			id.sname = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
		else
			id.sname = t.image;
		return id;
	}
}

UserMeta Annotation() :
{ SymbolRef id; MetaValue v; }
{
	{ UserMeta n = new UserMeta(); }
	"@"
	(
		id = QName()
	|	id = KeywordAsNameRef()
	)
	{	n.pos = id.pos;	 n.decl.name = id.name; }
	[	LOOKAHEAD({ getToken(1).kind == LPAREN })
		"("
		[	LOOKAHEAD({ getToken(1).kind != RPAREN })
			(
				LOOKAHEAD( <IDENTIFIER> "=" )
				AnnotationValues(n)
			|
				LOOKAHEAD( 0 )
				v = AnnotationValueAny(new SymbolRef("value")) { n.set(v); }
			)
		]
		")"
	]
	{ return n; }
}

void AnnotationValues(UserMeta m) :
{ SymbolRef id; MetaValue v; }
{
	id = NameRef()
	"="
	v = AnnotationValueAny(id)
	{ m.set(v); }
	(
		","
		id = NameRef()
		"="
		v = AnnotationValueAny(id)
		{ v.ident = id.name; v.pos = id.pos; m.set(v); }
	)*
}

MetaValue AnnotationValueAny(SymbolRef id) :
{ ASTNode n; MetaValue v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	|
		v = AnnotationValueValueArrayInitializer(id)
	|
		LOOKAHEAD( 0 )
		n = Expression()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueScalar AnnotationValueScalar(SymbolRef id) :
{ ASTNode n; MetaValueScalar v; }
{
	(
		LOOKAHEAD( "@" <IDENTIFIER> )
		n = Annotation()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	|
		LOOKAHEAD( 0 )
		n = Expression()
		{ v = new MetaValueScalar(id); ((MetaValueScalar)v).value = n; }
	)
	{ return v; }
}

MetaValueArray AnnotationValueValueArrayInitializer(SymbolRef id) :
{ MetaValueScalar n; MetaValueArray v; }
{
	{ v = new MetaValueArray(id); }
	"{"
	[	LOOKAHEAD({ getToken(1).kind != RBRACE })
		n = AnnotationValueScalar(null) { v.values.add(~n.value); }
		(	","
			n = AnnotationValueScalar(null) { v.values.add(~n.value); }
		)*
	]
	"}"
	{ return v; }
}


Field FieldDecl(ASTModifiers modifiers, TypeRef dtype) :
{ boolean old_declMode; Symbol id; ENode init; Field fld; }
{
	{
		old_declMode = declMode;
		declMode = false;
		init = null;
	}
	try {
		id = Name()
		[	"="	init = VariableInitializer()	]
		{
			fld = mkField(id, modifiers, dtype, init);
		}
		";"
		{	return fld;	}
	} finally { declMode = old_declMode; }
}

void LocalVarDecls(ASTModifiers modifiers, RuleMethod meth) :
{ TypeRef dtype; }
{
	dtype = Type()
	meth.localvars += RuleVarDecl(modifiers, dtype, true)
	(	","
		meth.localvars += RuleVarDecl(modifiers, dtype, false)
	)*
	";"
}

LVar RuleVarDecl(ASTModifiers modifiers, TypeRef dtype, boolean first) :
{ Token t; Symbol id; LVar lv; }
{
	id = Name()
	{ lv = mkRuleVar(id, modifiers, dtype, first); }
	[
		"="
		lv.init = VariableInitializer()
	]
	{ return lv; }
}

void VarDecls(ASTModifiers modifiers, SpacePtr stats) :
{ boolean old_declMode; TypeRef dtype; Symbol id; ENode init; Var var; }
{
	{
		old_declMode = declMode;
		declMode = false;
		init = null;
		var = null;
	}
	try {
		dtype = Type()
		id = Name()
		[	"="	init = VariableInitializer()	]
		{
			var = mkVar(id, new ASTModifiers(), dtype);
			modifiers.copyToNode(var);
			var.init = init;
			stats += var;
		}
		(
			","
			{ init = null; }
			id = Name()
			[	"="	init = VariableInitializer()	]
			{
				var = mkVar(id, new ASTModifiers(), new Copier().copyFull(dtype));
				modifiers.copyToNode(var);
				var.init = init;
				stats += var;
			}
		)*
	} finally { declMode = old_declMode; }
}

ENode VariableInitializer() :
{ ENode e; }
{
	(
		e = ArrayInitializer()
	|
		LOOKAHEAD( 0 )
		e = ExpressionColon()
	)
	{ return e; }
}

ENode ArrayInitializer() :
{ NewInitializedArrayExpr e = new NewInitializedArrayExpr(); e.pos = getToken(1).getPos(); }
{
	"{"
	[	LOOKAHEAD(2)
		e.args += VariableInitializer()
		(	LOOKAHEAD(2)
			","
			e.args += VariableInitializer()
		)*
		[ "," ]
	]
	"}"
	{ return e; }
}

Field CaseTypeField(ASTModifiers modifiers) :
{ Token t; TypeRef tp; Symbol id; }
{
	tp = Type()
	id = Name()
	{
		return mkCaseField(id, modifiers, tp);
	}
}

Var PizzaCaseFormalParameter(ASTModifiers modifiers) :
{ Token t; TypeRef tp; Symbol id; }
{
	(
		LOOKAHEAD({ getToken(1).image.equals("_") })
		id = Name() { tp = new TypeRef(curEnv.tenv.tpVoid); tp.pos = id.pos; }
	|
		tp = Type()
		id = Name()
	)
	{ return mkVar(id, modifiers, tp); }
}

LVar MethodFormalParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; TypeRef st=null; Symbol id; }
{
	[
		":"
		st = Type()
	]
	id = Name()
	{ return mkFormPar(id, modifiers, tp, st); }
}

LVar MethodVarargsParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; Symbol id = null; }
{
	t = "..."
	[ id = Name() ]
	{
		if (tp == null)
			tp = makeTypeExpr(new TypeRef(curEnv.tenv.tpObject), t);
		else
			tp = makeTypeExpr(tp, t);
		tp.pos = t.getPos();
		if (id == null) {
			id = new Symbol(t.getPos(), Constants.nameVarArgs);
		}
		return mkVarargPar(id, modifiers, tp);
	}
}

LVar FormalParameter(ASTModifiers modifiers, TypeRef tp) :
{ Token t; Symbol id; }
{
	id = Name()
	{ return mkFormPar(id, modifiers, tp, null); }
}

MetaThrows Throws() :
{ MetaThrows n = new MetaThrows(); TypeNameRef thr; }
{
	"throws"
	thr = TypeQName() { n.add(thr); }
	(
		","
		thr = TypeQName() { n.add(thr); }
	)*
	{ return n; }
}


Alias MethodAlias(Method m) :
{ Alias a; Symbol s; SymbolRef id; EToken op; ConstIntExpr ce; ConstStringExpr cs; }
{
	(
		"alias"
		(
			s = Name()
			{ a = new Alias(s.sname, m); a.pos = s.pos; }
		|	"operator"
			cs = StringConstExpression()
			{ a = new OperatorAlias(cs.value, m); a.pos = cs.pos; }
		)
	|	"operator"
		cs = StringConstExpression()
		{ a = new OperatorAlias(cs.value, m); a.pos = cs.pos; }
	)
	{ return a; }
}

void SkipBlock() :
{}
{
	LOOKAHEAD({ interface_only })
	"{"
	{
		Token tk = getToken(0);
		int depth = 1;
		do {
			tk = getNextToken();
			if( tk.kind == LBRACE ) depth++;
			else if( tk.kind == RBRACE ) depth--;
		} while( depth > 0 );
	}
}

Method MethodDeclaration(ASTModifiers modifiers, TypeConstr[] args, TypeRef ret) :
{ Token t; Method m; Symbol id; ConstStringExpr cor; MetaThrows thr; TypeRef ptype; }
{
	id = Name()
	{
		m = mkMethod(id,modifiers,ret);
		if (args != null)
			m.targs.addAll(args);
	}
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			(	m.params += MethodFormalParameter(modifiers,ptype)
			|	m.params += MethodVarargsParameter(modifiers,ptype)
				{ m.setVarArgs(true); }
			)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				(	m.params += MethodFormalParameter(modifiers,ptype)
				|	m.params += MethodVarargsParameter(modifiers,ptype)
					{ m.setVarArgs(true); }
				)
			)*
		)?
	")"
	(
		m.aliases += MethodAlias(m)
	)*
	[	thr = Throws()	{ m.setMeta(thr); } ]
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|	LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = Block() [ ";" ]
	|	"default" m.body = AnnotationValueAny(new SymbolRef(getToken(0).getPos(),m)) ";"
	|	";"
	)
	{ return m; }
}

Constructor ConstructorDeclaration(ASTModifiers modifiers, TypeConstr[] args, ComplexTypeDecl clazz) :
{ Token t; Constructor m; Symbol id; MetaThrows thr; TypeRef ptype; }
{
	id = Name()
	{
		if( !id.sname.equals(clazz.sname) )
			Kiev.reportError(id,"Return type missed or bad constructor name "+id);
		m = mkConstructor(id,modifiers); 
		if (args != null)
			m.targs.addAll(args);
	}
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			(	m.params += MethodFormalParameter(modifiers,ptype)
			|	m.params += MethodVarargsParameter(modifiers,ptype)
				{ m.setVarArgs(true); }
			)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				(	m.params += MethodFormalParameter(modifiers,ptype)
				|	m.params += MethodVarargsParameter(modifiers,ptype)
					{ m.setVarArgs(true); }
				)
			)*
		)?
	")"
	(
		m.aliases += MethodAlias(m)
	)*
	[	thr = Throws()	{ m.setMeta(thr); } ]
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|	LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = Block() [ ";" ]
	|	";"
	)
	{ return m; }
}

WBCCondition RequareDeclaration() :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondRequire;
	}
	"require"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	|
		LOOKAHEAD( 0 )
		n.body = CondBlock()
	)
	{ return n; }
}


WBCCondition EnsureDeclaration() :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondEnsure;
	}
	"ensure"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|
		LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	|
		LOOKAHEAD( 0 )
		n.body = CondBlock()
	)
	{ return n; }
}

WBCCondition InvariantDeclaration(ASTModifiers modifiers) :
{ Symbol id; }
{
	{
		WBCCondition n = new WBCCondition();
		//n.modifiers = modifiers;
		n.cond = WBCType.CondInvariant;
	}
	"invariant"
	(
		LOOKAHEAD("[" <IDENTIFIER> "]" )
		"[" id = Name() { n.sname = id.sname; } "]"
		n.body = CondBlock()
	|	LOOKAHEAD(<IDENTIFIER> "{")
		id     = Name() { n.sname = id.sname; }
		n.body = CondBlock()
	)
	{ return n; }
	
}

RuleMethod RuleDeclaration(ASTModifiers modifiers) :
{ RuleBlock bl; RuleMethod m; Symbol id; TypeRef ptype; }
{
	<IDENTIFIER> // "rule"
	id = Name()
	{ m = mkRuleMethod(id, modifiers, new TypeRef(curEnv.tenv.tpRule)); }
	"("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			m.params += FormalParameter(modifiers,ptype)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				m.params += FormalParameter(modifiers,ptype)
			)*
		)?
	")"
	(
		m.aliases += MethodAlias(m)
	)*
	(
		modifiers = Modifiers()
		LocalVarDecls(modifiers,m)
	)*
	(
		m.conditions += RequareDeclaration()
	|	m.conditions += EnsureDeclaration()
	)*
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|
		LOOKAHEAD({ getToken(1).kind == LBRACE })
		m.body = RuleBlock() [ ";" ]
	|
		";"
	)
	{ return m; }
}

Initializer Initializer(ASTModifiers modifiers) :
{
	Initializer n = mkInitializer(getToken(0).getPos(),modifiers);
}
{
	(
		LOOKAHEAD({ getToken(1).kind == LBRACE && interface_only })
		SkipBlock() [ ";" ]
	|
		LOOKAHEAD(0)
		n.body = Block() [ ";" ]
	)
	{ return n; }
}



/*
 * Type, name and expression syntax follows.
 */


TypeRef Type() :
{ TypeRef res; }
{
	(
		LOOKAHEAD ( (<IDENTIFIER> ".")+ "type" )
		res = PathType()
	|
		res = TypeExpr()
	|
		res = ClosureType()
	)
	{ return res; }
}

TypeRef TypeExpr() :
{ TypeRef res; Token t; }
{
	res = TypeWithArgs()
	(
		(	t = TypeOperatorChar()
		|	t = <OPERATOR_LRBRACKETS>
		)
		{ res = makeTypeExpr(res,t); }
	)*
	{ return res; }
}

PathTypeRef PathType() :
{ Token t; ENode e; }
{
	t = <IDENTIFIER>			{ e = new EToken(t,ETokenKind.MAYBE_IDENTIFIER); }
	"."
	(
		t = <IDENTIFIER>		{ e = new AccessExpr(t.getPos(),e,new EToken(t,ETokenKind.MAYBE_IDENTIFIER).ident); }
		"."
	)*
	t="type"
	{ PathTypeRef tr = new PathTypeRef(e); tr.pos = t.getPos(); return tr; }
}

TypeNameRef TypeQName() :
{ SymbolRef id; TypeNameRef res; }
{
	id = NameRef() { res = new TypeNameRef(id.name); res.pos = id.pos; }
	(	LOOKAHEAD("." <IDENTIFIER>)
		"."
		id = NameRef()  { res.ident = res.ident + '\u00b7' + id.name; }
	)*
	{ return res; }
}

TypeRef TypeWithWildcard() :
{ TypeRef res; }
{
	(
		// "?"
		LOOKAHEAD({getToken(1).kind == OPERATOR && getToken(1).image.equals("?")})
		<OPERATOR>
		(
			"extends"
			res = Type()
			{ res = new TypeExpr(res, Operator.PostTypeWildcardCoVariant, null); }
		|
			LOOKAHEAD({getToken(1).kind == IDENTIFIER && getToken(1).image.equals("super")})
			<IDENTIFIER>
			res = Type()
			{ res = new TypeExpr(res, Operator.PostTypeWildcardContraVariant, null); }
		|
			{ res = new TypeExpr(curEnv.tenv.tpObject, Operator.PostTypeWildcardCoVariant, null); res.pos = getToken(0).getPos(); }
		)
	|
		res = Type()
	)
	{ return res; }
}

TypeRef TypeWithArgs() :
{ SymbolRef qname; TypeRef res; TypeRef arg; }
{
	qname = QName()
	(	LOOKAHEAD({ getToken(1).kind == LT || getToken(1).kind == LANGLE })
		("<" | <LANGLE>)
			{ res = new TypeNameArgsRef(qname.name); }
			(
				// "?"
				LOOKAHEAD({getToken(1).kind == OPERATOR && getToken(1).image.equals("?")})
				<OPERATOR>
				(
					"extends"
					arg = Type()
					{ res.args += new TypeExpr(arg, Operator.PostTypeWildcardCoVariant, null); }
				|
					LOOKAHEAD({getToken(1).kind == IDENTIFIER && getToken(1).image.equals("super")})
					<IDENTIFIER>
					arg = Type()
					{ res.args += new TypeExpr(arg, Operator.PostTypeWildcardContraVariant, null); }
				|
					{ res.args += new TypeExpr(curEnv.tenv.tpObject, Operator.PostTypeWildcardCoVariant, null); }
				)
			|
				res.args += Type()
			)

			(	LOOKAHEAD({ getToken(1).kind == COMMA })
				","
				res.args += Type()
			)*
		(">" | <RANGLE>)
		(	LOOKAHEAD("." <IDENTIFIER>)
			"."
			qname = QName()
			{ res = new TypeInnerNameRef(res, qname.name); }
			("<" | <LANGLE>)
				res.args += Type()
				(	LOOKAHEAD({ getToken(1).kind == COMMA })
					","
					res.args += Type()
				)*
			(">" | <RANGLE>)
		)*
	|
		{ res = new TypeNameRef(qname.name); }
	)
	{ return res; }
}

TypeRef NArrType() :
{ TypeRef res; Token t; }
{
	res = TypeWithArgs()
	(	LOOKAHEAD(2)
		(
			t = TypeOperatorChar()			{ res = makeTypeExpr(res,t); }
		|
			t = <OPERATOR_LRBRACKETS>		{ res = makeTypeExpr(res,t); }
			t = TypeOperatorChar()			{ res = makeTypeExpr(res,t); }
		)
	)*
	{ return res; }
}

TypeRef ClosureType() :
{ Token t; TypeClosureRef n = new TypeClosureRef(); }
{
	t="(" { n.pos = t.getPos(); }
	[
		n.args += Type()
		( "," n.args += Type() )*
	]
	")" "->" n.ret = Type()
	{ return n; }
}

LVarExpr Var() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		LVarExpr id = new LVarExpr();
		id.pos = t.getPos();
		if (t.image.startsWith("#id\""))
			id.ident = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
		else
			id.ident = t.image;
		return id;
	}
}

Symbol Name() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		Symbol id = new Symbol();
		id.pos = t.getPos();
		if (t.image.startsWith("#id\""))
			id.sname = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
		else
			id.sname = t.image;
		return id;
	}
}

SymbolRef NameRef() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		SymbolRef id = new SymbolRef();
		id.pos = t.getPos();
		if (t.image.startsWith("#id\""))
			id.name = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
		else
			id.name = t.image;
		return id;
	}
}

SymbolRef QName() :
{ SymbolRef id; SymbolRef id2; }
{
	id = NameRef()
	(
		LOOKAHEAD(2)
		"."
		id2 = NameRef()
		{ id.name = id.name+'\u00b7'+id2.name; }
	)*
	{
		return id;
	}
}

EToken Identifier() :
{ Token t; }
{
	t=<IDENTIFIER>
	{
		return new EToken(t,ETokenKind.MAYBE_IDENTIFIER);
	}
}

/*
 * Expression syntax follows.
 */

ENode CommaExpression() :
{ ENode e; CommaExpr ce = null; }
{
	e = Expression()
	(
		","
		{ if (ce==null) ce = new CommaExpr(e); }
		ce.exprs += Expression()
	)*
	{ return ce == null ? e : ce; }
}

ASTRuleNode RuleOrExpression() :
{ ASTRuleNode e; RuleOrExpr r = null; }
{
	e = RuleAndExpression()
	(
		";"
		{ if (r==null) { r = new RuleOrExpr(e); r.pos = getToken(0).getPos();} }
		r.rules += RuleAndExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleAndExpression() :
{ ASTRuleNode e; RuleAndExpr r = null; }
{
	e = RuleExpression()
	(
		","
		{ if (r==null) { r = new RuleAndExpr(e); r.pos = getToken(0).getPos();} }
		r.rules += RuleExpression()
	)*
	{ return r == null ? e : r; }
}

ASTRuleNode RuleExpression() :
{ ASTRuleNode r; }
{
	(
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_THE
		})
		r = RuleIstheExpression()
	|
		LOOKAHEAD( {
			getToken(1).kind == IDENTIFIER
		 && getToken(2).kind == IS_ONE_OF
		})
		r = RuleIsoneofExpression()
	|
		LOOKAHEAD({getToken(1).kind == PCUT})
		r = RuleCutExpression()
	|
		LOOKAHEAD({getToken(1).kind == LBRACE})
		"{" r = RuleOrExpression() "}"
	|
		LOOKAHEAD({getToken(1).kind == WHILE})
		"while"
		{ r = new RuleWhileExpr(); }
		r.expr = Expression() 
		[
			":"
			r.bt_expr = Expression()
		]
	|
		LOOKAHEAD(0)
		{ r = new RuleExpr(); }
		r.expr = Expression()
		[
			":"
			r.bt_expr = Expression()
		]
	)
	{ return r; }
}

RuleIstheExpr RuleIstheExpression() :
{ Token t; RuleIstheExpr r = new RuleIstheExpr(); }
{
	r.var = Var()
	t = "?=" { r.pos = t.getPos(); }
	r.expr = Expression()
	{ return r; }
}

RuleIsoneofExpr RuleIsoneofExpression() :
{ Token t; RuleIsoneofExpr r = new RuleIsoneofExpr(); }
{
	r.var = Var()
	t = "@=" { r.pos = t.getPos(); }
	r.expr = Expression()
	{ return r; }
}

RuleCutExpr RuleCutExpression() :
{ RuleCutExpr r = new RuleCutExpr(); }
{
	"$cut"
	{
		r.pos = getToken(0).getPos();
		return r;
	}
}

Token TypeOperatorChar() :
{ Token t; }
{
	(
		t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR_SUPERSCRIPT_PLUS>
	|	t=<OPERATOR_SUPERSCRIPT_MINUS>
	|	t=<OPERATOR>
	)
	{ return t; }
}

Token OperatorChar() :
{ Token t; }
{
	(
		t=<ASSIGN>
	|	t=<LT>
	|	t=<GT>
	|	t=<OPERATOR_AT>
	|	t=<OPERATOR_SHARP>
	|	t=<OPERATOR_UPPER_BOUND>
	|	t=<OPERATOR_LOWER_BOUND>
	|	t=<OPERATOR>
	)
	{ return t; }
}

EToken Operator() :
{ Token t; String image; int pos; }
{
	(
		t=OperatorChar()
		{ image = t.image; pos = t.getPos(); }
		(
			LOOKAHEAD({ operatorLA() })
			t=OperatorChar()
			{ image = image+t.image; }
		)*
	|
		t="->" { image = t.image; pos = t.getPos(); }
	|
		t="?=" { image = t.image; pos = t.getPos(); }
	|
		t="@=" { image = t.image; pos = t.getPos(); }
	|
		"operator" t=<IDENTIFIER>
		{
			pos = t.getPos();
			if (t.image.startsWith("#id\""))
				image = ConstExpr.source2ascii(t.image.substring(4,t.image.length()-2));
			else
				image = t.image;
		}
	)
	{	return new EToken(pos, image, ETokenKind.EXPL_OPERATOR);		}
}

ENode ExpressionColonComma() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=":"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|
		t=","	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		//if (e.nodes.length == 1)
		//	return ~e.nodes[0];
		return e;
	}
}
ENode ExpressionColon() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=":"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		//if (e.nodes.length == 1)
		//	return ~e.nodes[0];
		return e;
	}
}
ENode ExpressionComma() :
{ ASTExpression e = new ASTExpression(); Token t; }
{
	(
		t=","	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|	LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		//if (e.nodes.length == 1)
		//	return ~e.nodes[0];
		return e;
	}
}
ENode Expression() :
{ ASTExpression e = new ASTExpression(); }
{
	(
		LOOKAHEAD({ExpressionNoNoLA()})
		ExpressionNoNo(e)
	)+
	{
		//if (e.nodes.length == 1)
		//	return ~e.nodes[0];
		return e;
	}
}

void ExpressionNoNo(ASTExpression e) :
{ Token t; ENode n; }
{
	(
		e.nodes += ConstExpression()
	|
		e.nodes += Identifier()
	|
		t="("	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		[
			n = ExpressionColonComma() { expandExpr(e,n); }
		]
		t=")"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|
		t="["	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		e.nodes += ExpressionColonComma()
		t="]"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|
		t=<LANGLE>		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		e.nodes += Type()
		(
			t=","	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); } 
			e.nodes += Type()
		)*
		t=<RANGLE>		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	|
		t=<OPERATOR_LRBRACKETS>	{ e.nodes += new EToken(t.getPos(), "[]", ETokenKind.EXPL_OPERATOR); }
	|
		t="."	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		(
			t="class"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		|
			t="new"		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
			e.nodes += Type()
		|
			t="<"		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
			e.nodes += Type()
			(
				t=","	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); } 
				e.nodes += Type()
			)*
			t=">"		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		|
			t=<LANGLE>		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
			e.nodes += Type()
			(
				t=","	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); } 
				e.nodes += Type()
			)*
			t=<RANGLE>		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		|
			{}
		)
	|
		NewAny(e)
	|
		e.nodes += AnonymouseClosure()
	|
		e.nodes += Operator()
	)
}

void NewAny(ASTExpression e) :
{ ENode n; TypeRef tp; Token t; Struct clazz; }
{
	t="new"				{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
	tp = NArrType()		{ e.nodes += tp; }
	(
		(
			t="["						{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
			n = Expression()			{ expandExpr(e,n); }
			t="]"						{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		|
			t=<OPERATOR_LRBRACKETS>		{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		)+
		(
			t="{"								{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
			[
				n = VariableInitializer()		{ e.nodes += n; }
				(	LOOKAHEAD(2)
					t=","						{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
					n = VariableInitializer()	{ e.nodes += n; }
				)*
				[ "," ]
			]
			t="}"								{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		)?
	|
		t="("	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		[
			n = ExpressionColonComma() { expandExpr(e,n); }
		]
		t=")"	{ e.nodes += new EToken(t, ETokenKind.EXPL_OPERATOR); }
		(
			LOOKAHEAD({ getToken(1).kind == LBRACE })
			{
				clazz = mkStruct(null, new JavaAnonymouseClass(), ACC_FINAL, new ASTModifiers(), e);
				e.nodes += clazz;
			}
			TypeBodyDeclaration(clazz)
		)?
	)
}

NewClosure AnonymouseClosure() :
{ ASTModifiers modifiers; TypeRef ptype; NewClosure nc = new NewClosure(getToken(1).getPos()); }
{
	"fun" "("
		(
			LOOKAHEAD({ getToken(1).kind != RPAREN })
			modifiers = Modifiers()
			ptype = Type()
			nc.params += FormalParameter(modifiers,ptype)
			(
				","
				modifiers = Modifiers()
				ptype = Type()
				nc.params += FormalParameter(modifiers,ptype)
			)*
		)?
	")" "->"
    (
		LOOKAHEAD( { getToken(1).kind == IDENTIFIER && getToken(1).image.equals("rule") } )
		nc.type_ret = Type()
		nc.body = RuleBlock()
	|
		nc.type_ret = Type()
		nc.body = Block()
	)
	{ return nc; }
}

ConstExpr ConstExpression() :
{ ConstExpr ce; }
{
	(
		ce = IntConstExpression()
	|	ce = LongConstExpression()
	|	ce = FloatConstExpression()
	|	ce = DoubleConstExpression()
	|	ce = CharConstExpression()
	|	ce = StringConstExpression()
	)
	{ return ce; }
}

ConstIntExpr IntConstExpression() :
{ Token t; }
{
 	t=<INTEGER_LITERAL>
	{ return (ConstIntExpr)sourceToConst(t); }
}

ConstLongExpr LongConstExpression() :
{ Token t; }
{
	t=<LONG_INTEGER_LITERAL>
	{ return (ConstLongExpr)sourceToConst(t); }
}

ConstFloatExpr FloatConstExpression() :
{ Token t; }
{
	t=<FLOATING_POINT_LITERAL>
	{ return (ConstFloatExpr)sourceToConst(t); }
}

ConstDoubleExpr DoubleConstExpression() :
{ Token t; }
{
	t=<DOUBLE_POINT_LITERAL>
	{ return (ConstDoubleExpr)sourceToConst(t); }
}

ConstCharExpr CharConstExpression() :
{ Token t; }
{
	t=<CHARACTER_LITERAL>
	{ return (ConstCharExpr)sourceToConst(t); }
}

ConstStringExpr StringConstExpression() :
{ Token t, t1; }
{
	t=<STRING_LITERAL>
	{ return (ConstStringExpr)sourceToConst(t); }
}

/*
 * Statement syntax follows.
 */

ENode Statement() :
{ ENode st; }
{
	(
	  LOOKAHEAD(2, <IDENTIFIER> ":")
	  st = LabeledStatement()
	| st = Block()
	| st = SwitchStatement()
	| st = IfStatement()
	| st = WhileStatement()
	| st = DoStatement()
	| st = ForStatement()
	| st = ForEachStatement()
	| st = BreakStatement()
	| st = ContinueStatement()
	| st = ReturnStatement()
	| st = ThrowStatement()
	| st = SynchronizedStatement()
	| st = WithStatement()
	| st = TryStatement()
	| st = GotoStatement()
	| LOOKAHEAD(0)
	  st = StatementExpression()
	)
	{ return st; }
}

ENode LabeledStatement() :
{ LabeledStat st = new LabeledStat(); Symbol id; }
{
	id = Name() { st.lbl.sname = id.sname; st.pos = id.pos; }
	":"
	st.stat = Statement()
	{ return st; }
}

Block Block() :
{ boolean old_declMode; }
{
	"{"
	{
		Block bl = new Block();
		bl.pos = getToken(1).getPos();
		old_declMode = declMode;
		declMode = false;
	}
	try {
    	(
			BlockStatement(Env.getSpacePtr(bl, "stats"))
		)*
	} finally { declMode = old_declMode; }
    "}"
	{ return bl; }
}

RuleBlock RuleBlock() :
{ boolean old_declMode; }
{
	"{"
	{
		RuleBlock bl = new RuleBlock();
		bl.pos = getToken(1).getPos();
		old_declMode = declMode;
		declMode = false;
	}
	try {
		bl.rnode = RuleOrExpression()
	} finally { declMode = old_declMode; }
	"}"
	{ return bl; }
}

Block CondBlock() :
{}
{
	{
		Block bl = new Block();
		bl.pos = getToken(1).getPos();
	}
	(
		"{"
			(
				bl.stats += CondStatement()
			)+
		"}"
	|
		bl.stats += CondStatement()
	)
	{ return bl; }
}

void BlockStatement(SpacePtr stats) :
{ boolean old_declMode; ASTModifiers modifiers; TypeRef tp; Var var; }
{
	{ comments_alone(stats); }
	(
		LOOKAHEAD(InBlockModifiersLA())
		(
			modifiers = Modifiers()
			(
				{ old_declMode = declMode; declMode = true; }
				try {
					stats += TypeDeclaration(modifiers, (ASTNode)stats.node)
				} finally { declMode = old_declMode; }
			|	LOOKAHEAD(0)
				VarDecls(modifiers, stats)
			)
		)
	|
		{ old_declMode = declMode; declMode = true; }
		try {
			stats += TypeDeclaration(new ASTModifiers(), (ASTNode)stats.node)
		} finally { declMode = old_declMode; }
	|
		LOOKAHEAD( Type() Name() )
		VarDecls(new ASTModifiers(), stats)
		";"
	|
		/* other statements */
		LOOKAHEAD(0)
		stats += Statement()
	)
}

CondStat CondStatement() :
{ Token t = getToken(1); CondStat st = new CondStat(); }
{
	st.cond = Expression()
	[
		":"
		{ t = null; }
		st.message = Expression()
	]
	{
		if( t != null ) {
			int pos = t.getPos();
			StringBuffer sb = new StringBuffer();
			while( t != null && t != getToken(1) ) {
				sb.append(t.image).append(' ');
				t = t.next;
			}
			ConstStringExpr e = new ConstStringExpr(sb.toString());
			e.pos = pos;
			st.message = e;
		}
	}
	";"
	{ return st; }
}

ENode StatementExpression() :
{ ENode st; }
{
	(
		";" { st = new ExprStat(getToken(0).getPos(), null); } 
	|	st = ExpressionColonComma()
		[	LOOKAHEAD({ getToken(1).kind == SEMICOLON })
			";" { st = new ExprStat(st.pos, st); }
		]
	)
	{ return st; }
}

SwitchStat SwitchStatement() :
{ SwitchStat st = new SwitchStat(); }
{
	"switch"
	{ st.pos = getToken(0).getPos(); }
	"(" st.sel = ExpressionColonComma() ")"
	"{"
	(
		LOOKAHEAD( 1, "case" | "default" )
		st.cases += CaseStatements(st)
	)+
	"}"
	{ return st; }
}

CaseLabel CaseStatements(SwitchStat sw) :
{ CaseLabel st; }
{
	(
		LOOKAHEAD("case" QName() "(" )
		st = PizzaCase(sw)
	|
		st = NormalCase(sw)
	)
	{ return st; }
}

CaseLabel NormalCase(SwitchStat sw) :
{ CaseLabel c = new CaseLabel(); sw.stats += c; }
{
	(
		"case"	{ c.pos = getToken(0).getPos(); }
		c.val = Expression()
		":"
	|
		"default"	{ c.pos = getToken(0).getPos(); }
		":"
	)
	(
		BlockStatement(Env.getSpacePtr(sw, "stats"))
	)*
	{ return c; }
}

CaseLabel PizzaCase(SwitchStat sw) :
{ Token t; ASTModifiers modifiers; CaseLabel c = new CaseLabel(); sw.stats += c; }
{
	"case"		{ c.pos = getToken(0).getPos(); }
	c.val = TypeWithArgs()
	"("
	(	LOOKAHEAD({ getToken(1).kind != RPAREN })
		modifiers = Modifiers()
		c.pattern += PizzaCaseFormalParameter(modifiers)
		(
			","
			modifiers = Modifiers()
			c.pattern += PizzaCaseFormalParameter(modifiers)
		)*
	)?
	")" ":"
	(
		BlockStatement(Env.getSpacePtr(sw, "stats"))
	)*
	{ return c; }
}

IfElseStat IfStatement() :
{ IfElseStat st = new IfElseStat(); EToken not = null; }
{
	"if"
	{ st.pos = getToken(0).getPos(); }
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")"
	st.thenSt = Statement()
	[	LOOKAHEAD(1)
		"else"
		st.elseSt = Statement()
	]
	{ return st; }
}

WhileStat WhileStatement() :
{ WhileStat st = new WhileStat(); EToken not = null; }
{
	"while"
	{ st.pos = getToken(0).getPos(); }
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")"
    st.body = Statement()
	{ return st; }
}

DoWhileStat DoStatement() :
{ DoWhileStat st = new DoWhileStat(); EToken not = null; }
{
	"do"
	{ st.pos = getToken(0).getPos(); }
    st.body = Statement()
    "while"
	[
		LOOKAHEAD(<OPERATOR>, { getToken(1).image.equals("!") })
		not = Operator()
	]
    "("
		st.cond = ExpressionColonComma()
		{ if (not != null) st.cond = mkNotExpr(not,st.cond); }
	")" ";"
	{ return st; }
}

LoopStat ForStatement() :
{ ASTModifiers modifiers; ForStat fs = new ForStat(); ForEachStat fe = null; }
{
	"for"
	{ fs.pos = getToken(0).getPos(); }
	"("
		(	LOOKAHEAD( InBlockModifiersLA())
			modifiers = Modifiers()
			VarDecls(modifiers, Env.getSpacePtr(fs, "inits"))
		|
			LOOKAHEAD( Type() Name() )
			VarDecls(new ASTModifiers(), Env.getSpacePtr(fs, "inits"))
		|
			fs.inits += Expression()
			(
				","
				fs.inits += Expression()
			)*
		)?
	(
		":"
		{
			if (fs.inits.length != 1 || !(fs.inits[0] instanceof Var))
				rpe("Bad for(:) deflaration",null);
			ForEachStat fe = new ForEachStat();
			fe.pos = fs.pos;
			fe.var = (Var)fs.inits[0].detach();
			fs = null;
		}
		fe.container = Expression()
		")"
		fe.body = Statement()
		{ return fe; }
	|
		";"
			[
				fs.cond = Expression()
			]
		";"
			[
				fs.iter = CommaExpression()
			]
		")"
		fs.body = Statement()
		{ return fs; }
	)
}

ForEachStat ForEachStatement() :
{ ASTModifiers modifiers; ForEachStat st = new ForEachStat(); }
{
	"foreach"
	{ st.pos = getToken(0).getPos(); }
	"("
		[
			LOOKAHEAD( InBlockModifiersLA() | PizzaCaseFormalParameter() )
			modifiers = Modifiers()
			st.var = PizzaCaseFormalParameter(modifiers)
			";"
		]
		st.container = Expression()
		[
			";"
			st.cond = Expression()
		]
	")"
	st.body = Statement()
	{ return st; }
}

ENode GotoStatement() :
{ ENode st; ENode expr; SymbolRef id; }
{
	"goto"
	(
		"case"
		{
			st = new GotoCaseStat();
			st.pos = getToken(0).getPos();
		}
		expr = Expression()
		{ ((GotoCaseStat)st).expr = expr; }
	|
		"default"
		{
			st = new GotoCaseStat();
			st.pos = getToken(0).getPos();
		}
	|
		{
			st = new GotoStat();
			st.pos = getToken(0).getPos();
		}
    	id = NameRef()
		{ ((GotoStat)st).ident = id.name; }
    )
    ";"
	{ return st; }
}

BreakStat BreakStatement() :
{ SymbolRef id; BreakStat st = new BreakStat(); }
{
	"break"
	{ st.pos = getToken(0).getPos(); }
    [ id = NameRef() { st.ident = id.name; } ] ";"
	{ return st; }
}

ContinueStat ContinueStatement() :
{ SymbolRef id; ContinueStat st = new ContinueStat(); }
{
	"continue"
	{ st.pos = getToken(0).getPos(); }
    [ id = NameRef() { st.ident = id.name; } ] ";"
	{ return st; }
}

ReturnStat ReturnStatement() :
{ ReturnStat st = new ReturnStat(); }
{
	"return"
	{ st.pos = getToken(0).getPos(); }
    [ st.expr = ExpressionColonComma() ] ";"
	{ return st; }
}

ThrowStat ThrowStatement() :
{ ThrowStat st = new ThrowStat(); }
{
	"throw"
	{ st.pos = getToken(0).getPos(); }
    st.expr = ExpressionColonComma() ";"
	{ return st; }
}

SynchronizedStat SynchronizedStatement() :
{ SynchronizedStat st = new SynchronizedStat(); }
{
	"synchronized"
	{ st.pos = getToken(0).getPos(); }
	"(" st.expr = ExpressionColonComma() ")"
	st.body = Block()
	{ return st; }
}

WithStat WithStatement() :
{ WithStat st = new WithStat(); }
{
	"with"
	{ st.pos = getToken(0).getPos(); }
	"(" st.expr = ExpressionColonComma() ")"
	st.body = Block()
	{ return st; }
}

TryStat TryStatement() :
{ ASTModifiers modifiers; TryStat st = new TryStat(); }
{
	"try"
	{ st.pos = getToken(0).getPos(); }
    st.body = Block()
	(
		st.catchers += CatchInfo()
	)*
	[
		st.finally_catcher = FinallyInfo()
	]
	{ return st; }
}

CatchInfo CatchInfo() :
{ ASTModifiers modifiers; CatchInfo st = new CatchInfo(); }
{
	"catch"
	{ st.pos = getToken(0).getPos(); }
	"("
		modifiers = Modifiers()
		st.arg = PizzaCaseFormalParameter(modifiers)
	")"
	st.body = Block()
	{ return st; }
}

FinallyInfo FinallyInfo() :
{ Token t; FinallyInfo st = new FinallyInfo(); }
{
	"finally"
	{ st.pos = getToken(0).getPos(); }
	st.body = Block()
	{ return st; }
}

