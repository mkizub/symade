/*******************************************************************************
 * Copyright (c) 2005-2007 UAB "MAKSINETA".
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License Version 1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *     "Maxim Kizub" mkizub@symade.com - initial design and implementation
 *******************************************************************************/
package kiev.ir.java15;

import syntax kiev.Syntax;

/**
 * @author Maxim Kizub
 * @version $Revision: 271 $
 *
 */

@ViewOf(vcast=true)
public view RNode of ASTNode extends Object implements Constants {
	public String toString();
	
	public int			pos;
	
	public:ro @virtual @abstract ComplexTypeDecl	ctx_tdecl;
	public:ro @virtual @abstract Method				ctx_method;

	public final ANode parent();
	public AttrSlot[] values();
	public final <N extends ANode> N replaceWithNode(N node, INode parent, AttrSlot slot);
	public final ASTNode replaceWith(()->ASTNode fnode, INode parent, AttrSlot slot);
	public final boolean isAttached();
	public final boolean isBreakTarget();
	public final boolean isResolved();
	public final void    setResolved(boolean on);
	public final boolean isAutoGenerated();
	public final void    setAutoGenerated(boolean on);
	public final boolean isBad();
	public final void    setBad(boolean on);

	public final Type getType(Env env);

	@getter public final ComplexTypeDecl get$ctx_tdecl()  { return Env.ctxTDecl((ASTNode)this); }
	@getter public final Method          get$ctx_method() { return Env.ctxMethod((ASTNode)this); }
	public boolean preGenerate(Env env) { return true; }

	public static void resolveSNode(ANode node, Env env) {
		((RSNode)(SNode)node).resolveDecl(env);
	}
	
	public static void resolveDNode(ANode node, Env env) {
		((RDNode)(DNode)node).resolveDecl(env);
	}
	
	public static void resolveENode(ANode node, Type reqType, Env env) {
		((RENode)(ENode)node).resolveENode(reqType,env);
	}
}

@ViewOf(vcast=true)
public static view RSNode of SNode extends RNode {
	public void resolveDecl(Env env) {}
}

@ViewOf(vcast=true)
public static view RDNode of DNode extends RNode {

	public:ro MNode[]	metas;
	public:ro String	sname;

	public final boolean isPublic();
	public final boolean isPrivate();
	public final boolean isProtected();
	public final boolean isPkgPrivate();
	public final boolean isStatic();
	public final boolean isFinal();
	public final boolean isSynchronized();
	public final boolean isFieldVolatile();
	public final boolean isMethodBridge();
	public final boolean isFieldTransient();
	public final boolean isMethodVarargs();
	public final boolean isNative();
	public final boolean isInterface();
	public final boolean isAbstract();
	public final boolean isMathStrict();
	public final boolean isSynthetic();
	
	public final boolean isStructView();
	public final boolean isTypeUnerasable();

	public final void setPublic();
	public final void setPrivate();
	public final void setProtected();
	public final void setPkgPrivate();
	public final void setStatic(boolean on);
	public final void setFinal(boolean on);
	public final void setSynchronized(boolean on);
	public final void setFieldVolatile(boolean on);
	public final void setMethodBridge(boolean on);
	public final void setFieldTransient(boolean on);
	public final void setMethodVarargs(boolean on);
	public final void setNative(boolean on);
	public final void setAbstract(boolean on);
	public final void setTypeUnerasable(boolean on);
	public final boolean isVirtual();
	public final void setVirtual(boolean on);
	public final boolean isForward();
	public final void setForward(boolean on);

	public final boolean isMacro();
	public final boolean isInterfaceOnly();
	
	public final int getFlags();
	
	public final void verifyMetas();
	public final boolean hasRuntimeVisibleMetas();
	public final boolean hasRuntimeInvisibleMetas();
	
	public void resolveDecl(Env env) { /* empty */ }
}

@ViewOf(vcast=true)
public static view RENode of ENode extends RNode {

	public		String			ident;
	public		Symbol			symbol;
	public:ro	DNode			dnode;
	
	//
	// Expr specific
	//

	// use as field (disable setter/getter calls for virtual fields)
	public final boolean isAsField();
	public final void setAsField(boolean on);
	// expression will generate void value
	public final boolean isGenVoidExpr();
	public final void setGenVoidExpr(boolean on);
	// used bt for()
	public final boolean isForWrapper();
	public final void setForWrapper(boolean on);
	// used for cast calls (to check for null)
	public final boolean isCastCall();
	public final void setCastCall(boolean on);

	//
	// Statement specific flags
	//
	
	// abrupted
	public final boolean isAbrupted();
	public final void setAbrupted(boolean on);
	// breaked
	public final boolean isBreaked();
	public final void setBreaked(boolean on);
	// method-abrupted
	public final boolean isMethodAbrupted();
	public final void setMethodAbrupted(boolean on);
	// auto-returnable
	public final boolean isAutoReturnable();
	public final void setAutoReturnable(boolean on);
	// reachable by direct control flow, with no jumps into
	public final boolean isDirectFlowReachable();
	public final void setDirectFlowReachable(boolean on);

	public final void replaceWithResolve(Env env, Type reqType, ()->ENode fnode);
	public final void replaceWithResolve(Env env, ()->ENode fnode);

	public final Operator getOper();
	public final ENode[] getEArgs();
	public final boolean valueEquals(Object o);
	public final boolean isConstantExpr(Env env);
	public final Object	getConstValue(Env env);
	public final Method resolveMethodAndNormalize(Env env) {
		ENode en = (ENode)this;
		return en.resolveMethodAndNormalize(env, en.parent(), en.pslot());
	}

	public void resolveENode(Type reqType, Env env) {
		throw new CompilerException(this,"Resolve call for e-node "+getClass()+" / "+((ENode)this).getClass());
	}

	private static void do_resolve(Type reqType, ASTNode node, Env env) {
		try {
			Kiev.runProcessorsOn(node);
		} catch (ReWalkNodeException e) {
			do_resolve(reqType, (ASTNode)e.replacer, env);
			return;
		}
		resolveENode(node, reqType, env);
	}
	
	public final void replaceWithNodeResolve(Env env, Type reqType, ENode node) {
		assert(isAttached());
		ENode self = (ENode)this;
		ASTNode n = this.replaceWithNode(node, self.parent(), self.pslot());
		assert(n == node);
		assert(n.isAttached());
		do_resolve(reqType,n,env);
	}

	public final void replaceWithResolve(Env env, Type reqType, ()->ENode fnode) {
		assert(isAttached());
		ENode self = (ENode)this;
		ASTNode n = this.replaceWith(fnode, self.parent(), self.pslot());
		assert(n.isAttached());
		do_resolve(reqType,n, env);
	}

	public final void replaceWithNodeResolve(Env env, ENode node) {
		assert(isAttached());
		ENode self = (ENode)this;
		ASTNode n = this.replaceWithNode(node, self.parent(), self.pslot());
		assert(n == node);
		assert(n.isAttached());
		do_resolve(null,n,env);
	}

	public final void replaceWithResolve(Env env, ()->ENode fnode) {
		assert(isAttached());
		ENode self = (ENode)this;
		ASTNode n = this.replaceWith(fnode, self.parent(), self.pslot());
		assert(n.isAttached());
		do_resolve(null,n,env);
	}
	
}

@ViewOf(vcast=true)
public final view RNopExpr of NopExpr extends RENode {

	public void resolveENode(Type reqType, Env env) {
		setResolved(true);
		if (isAutoReturnable())
			RReturnStat.autoReturn(reqType, this, env);
	}
}

@ViewOf(vcast=true)
public final view RArgExpr of ArgExpr extends RENode {

	public ENode			expr;
	
	public void resolveENode(Type reqType, Env env) {
		setResolved(true);
		resolveENode(expr,reqType,env);
	}
}

@ViewOf(vcast=true)
public final view RTypeRef of TypeRef extends RENode {

	public void resolveENode(Type reqType, Env env) {
		if (reqType ≢ null && reqType ≉ env.tenv.tpClass)
			toExpr(reqType,env);
		else
			getType(env); // calls resolving
	}
	
	public void toExpr(Type reqType, Env env) {
		Type st = getType(env);
		TypeDecl s = st.meta_type.tdecl;
		if (s.isPizzaCase()) {
			// Pizza case may be casted to int or to itself or super-class
			PizzaCase pcase = (PizzaCase)s;
			Type tp = Type.getRealType(reqType,st);
			if !(reqType.isInteger() || tp.isInstanceOf(reqType))
				throw new CompilerException(this,"Pizza case "+tp+" cannot be casted to type "+reqType);
			if (pcase.case_fields.length != 0)
				throw new CompilerException(this,"Empty constructor for pizza case "+tp+" not found");
			if (reqType.isInteger()) {
				ENode expr = new ConstIntExpr(pcase.tag);
				if( reqType ≢ env.tenv.tpInt )
					expr = new CastExpr(pos,reqType,expr);
				replaceWithNodeResolve(env, reqType, expr);
			}
			else if (s.isSingleton()) {
				replaceWithNodeResolve(env, reqType, new SFldExpr(pos, s.resolveField(env,nameInstance)));
			}
			else {
				replaceWithResolve(env, reqType, fun ()->ENode {return new NewExpr(pos,tp,ENode.emptyArray);});
			}
			return;
		}
		if (s.isSingleton()) {
			replaceWithNodeResolve(env, reqType, new SFldExpr(pos, s.resolveField(env, nameInstance)));
			return;
		}
		throw new CompilerException(this,"Type "+this+" is not a singleton");
	}
}

@ViewOf(vcast=true)
public view RTypeDecl of TypeDecl extends RDNode {
	public:ro			TypeRef[]				super_types;

	public boolean isClazz();
	public final boolean isStructInner();
}

@ViewOf(vcast=true)
public view RComplexTypeDecl of ComplexTypeDecl extends RTypeDecl {
	public:ro			TypeDef[]				args;
	public:ro			ASTNode[]				members;

	public final String qname();
}


